# 📡 `app.serve()` — TezX Runtime-Agnostic Request Handler

The `app.serve()` method is the **core universal handler** for processing HTTP requests in **TezX**. It adapts itself to different JavaScript runtimes by internally delegating requests to the appropriate logic.

---

## 🧠 What It Does

* Accepts a native `Request` object (based on the Fetch API).
* Optionally accepts runtime-specific arguments like `connInfo` (Deno), `req, res, server` (Node.js), or `server` (Bun).
* Processes the request using your defined middleware and routes.
* Returns a `Response` object.

This method allows you to **integrate TezX into any runtime** with **zero extra configuration**.

---

## ⚙️ How It Works Internally

```ts
public async serve(req: Request, ...args: any[]): Promise<Response>
```

* `req`: A standard `Request` object.
* `args`: Optional values like response objects, connections, or server instances.

  * Parses the request.
  * Creates a context.
  * Executes middleware chain.
  * Calls route handlers.
  * Returns a finalized `Response`.

---

## ✅ Usage Examples

### 🔷 Bun

```ts
// Simple usage
app.serve(req, server);

// Full Bun server with WebSocket support
Bun.serve({
  port: 3000,
  fetch: app.serve,
  websocket: {
    open(ws) {
      return ws.data?.open?.(ws);
    },
    message(ws, msg) {
      return ws.data?.message?.(ws, msg);
    },
    close(ws, code, reason) {
      return ws.data?.close?.(ws, { code, reason });
    },
  },
});
```

---

### 🟨 Deno

```ts
// Basic serve function
import { serve } from "https://deno.land/std/http/server.ts";

serve((req, connInfo) => app.serve(req, connInfo));

// Or using modern API
Deno.serve({ port: 8080 }, app.serve);
```

---

### 🟦 Node.js

```ts
import { createServer } from "http";
import { mountTezXOnNode } from "tezx/node";

// Simple server mounting
const server = createServer();
mountTezXOnNode(app, server);
server.listen(3000);

// OR: manual conversion if needed
const response = await app.serve(toWebRequest(req), req, res, server);
```

---

## 🔄 When to Use `app.serve()`

| Scenario                       | Use `app.serve()`? |
| ------------------------------ | ------------------ |
| Bun’s `Bun.serve`              | ✅ Yes              |
| Deno's `serve` or `Deno.serve` | ✅ Yes              |
| Node's `http.createServer`     | ✅ Yes              |
| Edge runtimes (like Vercel)    | ✅ Yes              |
| Cloudflare Workers             | ✅ Yes              |

---

## 📝 Example

```ts
const res = await app.serve(
  new Request("http://localhost/hello", { method: "GET" })
);
console.log(await res.text()); // → "Hello TezX!" (if route is defined)
```

---

## 🛠 Tip for TypeScript Users

Since `...args: any[]` can vary between environments, you can narrow down types like:

```ts
// For Deno
app.serve(req, connInfo as Deno.ServeHandlerInfo);

// For Node
app.serve(req, res, server);
```

---

## 🧪 Debugging Middleware Chain

Want to trace how `app.serve()` is executing?

```ts
app.use(async (ctx, next) => {
  console.log("Incoming request:", ctx.method, ctx.url);
  await next();
});
```

---

## 🔚 Summary

* ✅ Cross-runtime request handler
* 📦 Accepts Fetch API-compatible `Request`
* 🔁 Handles middleware, routes, and returns `Response`
* 💡 Plug-and-play with Node, Deno, and Bun

> `app.serve()` is the glue between the **runtime** and your **application logic**.
