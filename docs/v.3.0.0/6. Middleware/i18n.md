# üåç `i18n` Middleware for TezX

Advanced internationalization middleware supporting dynamic translation loading, fallback language chains, caching, and customizable message formatting.

---

## üìÑ Basic Usage

```ts
import { i18n } from "tezx/i18n";

app.use(
  i18n({
    loadTranslations: (lang) => import(`./locales/${lang}.json`),
    defaultLanguage: "en",
  }),
);
```

---

## üîß API: `i18n(options: I18nOptions): Middleware`

### Configuration Options

| Option                   | Type                                                                          | Default                           | Description                                          |
| ------------------------ | ----------------------------------------------------------------------------- | --------------------------------- | ---------------------------------------------------- |
| `loadTranslations`       | `(language: string) => Promise<{ translations: object, expiresAt?: number }>` | **Required**                      | Dynamically loads translations for a given language  |
| `defaultCacheDuration`   | `number`                                                                      | `3600000` (1 hour)                | Cache expiration time in milliseconds                |
| `isCacheValid`           | `(cached: object, language: string) => boolean`                               | `cached.expiresAt > Date.now()`   | Custom cache validation logic                        |
| `detectLanguage`         | `(ctx: Context) => string`                                                    | Query > Cookie > Header > default | Custom language detection logic                      |
| `defaultLanguage`        | `string`                                                                      | `'en'`                            | Fallback language if detection fails                 |
| `fallbackChain`          | `string[]`                                                                    | `[]`                              | Array of fallback languages in priority order        |
| `translationFunctionKey` | `string`                                                                      | `'t'`                             | Key on `ctx` where the translation function is added |
| `formatMessage`          | `(msg: string, vars?: Record<string, any>) => string`                         | Basic `{{var}}` interpolation     | Custom message formatting/interpolation function     |
| `cacheTranslations`      | `boolean`                                                                     | `true`                            | Enable or disable caching of translations            |

---

## üí¨ Translation Format

Translations can be structured as nested JSON objects:

```json
{
  "home": {
    "title": "Welcome, {{name}}!",
    "subtitle": "Your dashboard"
  },
  "common": {
    "logout": "Log out"
  }
}
```

---

## üß† Features

### 1. Language Detection

Default order: Query param (`?lang=fr`) ‚Üí Cookie (`lang=fr`) ‚Üí `Accept-Language` header ‚Üí `defaultLanguage`

Override with:

```ts
detectLanguage: (ctx) => ctx.cookies.get("user_lang") || "en";
```

### 2. Fallback Chain

Supports fallback languages, e.g.:

```ts
fallbackChain: ["fr-CA", "fr", "en"];
```

### 3. Cache with Expiry

Translations can be cached with expiration either from `expiresAt` returned by loader or default duration.

### 4. Message Interpolation

Supports variable interpolation inside messages:

```ts
ctx.t("home.title", { name: "Alice" }); // ‚Üí "Welcome, Alice!"
```

Custom formatter example:

```ts
formatMessage: (msg, vars) => msg.replace(/\{(\w+)\}/g, (_, k) => vars[k] ?? "");
```

### 5. Nested Key Support

Supports nested keys using dot notation:

```ts
ctx.t('user.profile.greeting', { name: 'John' });
```

---

## üß™ Advanced Example

```ts
app.use(
  i18n({
    loadTranslations: async (lang) => {
      const res = await fetch(`https://api.example.com/lang/${lang}`);
      const json = await res.json();
      return { translations: json.data, expiresAt: json.expiresAt };
    },
    defaultLanguage: "en",
    fallbackChain: ["en-GB", "en"],
    detectLanguage: (ctx) => ctx.req.headers.get("x-custom-lang") || "en",
    translationFunctionKey: "translate",
    formatMessage: (msg, vars) =>
      msg.replace(/\{\{(.*?)\}\}/g, (_, key) => vars?.[key.trim()] ?? ""),
    cacheTranslations: true,
    isCacheValid: (cached) => cached.expiresAt > Date.now(),
  }),
);
```

---

## üìå What `ctx` Provides After Middleware

| Property            | Type                                      | Description                     |
| ------------------- | ----------------------------------------- | ------------------------------- |
| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function            |
| `ctx.language`      | `string`                                  | Detected language               |
| `ctx.languageChain` | `string[]`                                | Ordered fallback language chain |

---

## ‚ùó Error Handling

If translations are missing for all languages in the chain, the middleware throws an error and sets:

```ts
ctx.setStatus = 500;
```

---

## üì§ Exported Types

You can import and use these types for strong typing:

```ts
import type {
  I18nOptions,
  loadTranslations,
  TranslationMap,
} from "tezx/i18n";
```

---
