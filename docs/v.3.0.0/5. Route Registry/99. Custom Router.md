# üìö Custom Routers & Middleware in TezX

TezX offers you **full control** over routing by allowing custom routers implementing the `RouteRegistry` interface. This flexibility lets you define your routing strategy, middleware layering, and parameter parsing ‚Äî all while seamlessly integrating with TezX's request lifecycle.

---

## üöÄ Overview

* Implement route registration per HTTP method (GET, POST, etc.)
* Register global middleware for **all methods** (`"ALL"` method)
* Support dynamic route parameters (e.g., `/user/:id`, `/post/:id?`)
* Combine middleware and method-specific handlers at runtime
* Enable modular router composition with `mergeRouter()`
* Clear TypeScript typings for maintainability and clarity
* Normalize and match paths robustly with param extraction

---

## üîß Powerful Custom Router Implementation

```ts
import {
  HTTPMethod,
  RouteMatchResult,
  HandlerType,
  Middleware,
  Callback,
  RouteRegistry,
} from "tezx";

type Segment = {
  type: "static" | "param" | "paramOptional" | "wildcard";
  value: string;
};

/**
 * Parses a URL path into segments with type info:
 * static segments, params, optional params, wildcards.
 */
function parsePath(path: string): Segment[] {
  return path
    .split("/")
    .filter(Boolean)
    .map((segment) => {
      if (segment.startsWith(":")) {
        if (segment.endsWith("?")) {
          return { type: "paramOptional", value: segment.slice(1, -1) };
        }
        return { type: "param", value: segment.slice(1) };
      }
      if (segment.startsWith("*")) {
        return { type: "wildcard", value: segment.slice(1) || "*" };
      }
      return { type: "static", value: segment };
    });
}

/**
 * Matches a registered route‚Äôs segments against request path segments,
 * returning whether it matches and extracted parameters.
 */
function matchPath(
  routeSegments: Segment[],
  requestSegments: string[],
): { matched: boolean; params: Record<string, string | null> } {
  const params: Record<string, string | null> = {};
  let i = 0,
    j = 0;

  while (i < routeSegments.length && j < requestSegments.length) {
    const routeSeg = routeSegments[i];
    const reqSeg = requestSegments[j];

    if (routeSeg.type === "static") {
      if (routeSeg.value !== reqSeg) {
        return { matched: false, params: {} };
      }
      i++;
      j++;
    } else if (routeSeg.type === "param") {
      params[routeSeg.value] = reqSeg;
      i++;
      j++;
    } else if (routeSeg.type === "paramOptional") {
      params[routeSeg.value] = reqSeg;
      i++;
      j++;
    } else if (routeSeg.type === "wildcard") {
      params[routeSeg.value] = requestSegments.slice(j).join("/");
      i++;
      j = requestSegments.length;
    }
  }

  // Allow trailing optional params without matching segments
  while (i < routeSegments.length) {
    if (routeSegments[i].type === "paramOptional") {
      params[routeSegments[i].value] = null;
      i++;
    } else {
      break;
    }
  }

  // Match only if all route & request segments accounted for
  return { matched: i === routeSegments.length && j === requestSegments.length, params };
}

export class CustomRouter implements RouteRegistry {
  name = "CustomRouter";

  private routes = new Map<
    HTTPMethod,
    { path: string; segments: Segment[]; handlers: HandlerType }[]
  >();

  constructor() {
    // Initialize all HTTP methods + ALL for middleware
    [
      "ALL",
      "GET",
      "POST",
      "PUT",
      "DELETE",
      "PATCH",
      "OPTIONS",
      "HEAD",
    ].forEach((method) => this.routes.set(method as HTTPMethod, []));
  }

  /**
   * Register route or middleware stack for a method + path.
   * Middlewares use method = "ALL".
   */
  addRoute(method: HTTPMethod, path: string, handlers: HandlerType): void {
    const normalizedPath = path.startsWith("/") ? path : "/" + path;
    const segments = parsePath(normalizedPath);
    this.routes.get(method)!.push({ path: normalizedPath, segments, handlers });
  }

  /**
   * Find matching middleware + handlers for a given method + path.
   */
  search(method: HTTPMethod, path: string): RouteMatchResult {
    const normalizedPath = path.startsWith("/") ? path : "/" + path;
    const requestSegments = normalizedPath.split("/").filter(Boolean);

    // Collect all middlewares registered under "ALL" matching this path
    const allMiddlewares = this.routes.get("ALL") ?? [];
    const middlewares: Middleware[] = [];
    for (const route of allMiddlewares) {
      if (matchPath(route.segments, requestSegments).matched) {
        middlewares.push(...route.handlers);
      }
    }

    // Find first matching route for this method
    const methodRoutes = this.routes.get(method) ?? [];
    let matchedRoute:
      | { handlers: HandlerType; params: Record<string, string | null> }
      | null = null;

    for (const route of methodRoutes) {
      const { matched, params } = matchPath(route.segments, requestSegments);
      if (matched) {
        matchedRoute = { handlers: route.handlers, params };
        break;
      }
    }

    if (!matchedRoute) {
      // Return empty handlers if no match, but include middleware
      return {
        method,
        middlewares,
        handlers: [],
        params: {},
      };
    }

    return {
      method,
      middlewares,
      handlers: matchedRoute.handlers,
      params: matchedRoute.params,
    };
  }

  /**
   * Merge another router under a base path prefix.
   * Useful for modular route composition.
   */
  mergeRouter(basePath: string, router: this): void {
    if (!basePath.startsWith("/")) basePath = "/" + basePath;
    for (const [method, routes] of router.routes.entries()) {
      for (const route of routes) {
        // Combine base path and child route path cleanly
        const combinedPath =
          basePath === "/"
            ? route.path
            : basePath.endsWith("/")
            ? basePath.slice(0, -1) + route.path
            : basePath + route.path;
        this.addRoute(method, combinedPath, route.handlers);
      }
    }
  }
}
```

---

## üõ† How to Use with TezX ‚Äî Example

```ts
import { TezX } from "tezx";
import { CustomRouter } from "./CustomRouter";

const app = new TezX({
  routeRegistry: new CustomRouter(),
  debugMode: true,
});

// Register global middleware on all methods for /api routes
app.use("/api", async (ctx, next) => {
  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);
  await next();
});

// Define GET handler with dynamic param
app.get("/api/users/:id", async (ctx) => {
  return ctx.json({ userId: ctx.params.id });
});

// Define POST handler for user creation
app.post("/api/users", async (ctx) => {
  const data = await ctx.body.json();
  return ctx.json({ created: data });
});

// Modular router example: admin routes
const adminRouter = new Router();
adminRouter.get("/dashboard", [
  async (ctx) => ctx.text("Admin Dashboard"),
]);
app.use("/admin", adminRouter);
```

---

## üí° Summary of Features

| Feature                        | Description                                                   |
| ------------------------------ | ------------------------------------------------------------- |
| **Dynamic Params**             | Support for `:param`, `:param?` (optional), and `*wildcard`   |
| **Middleware for ALL Methods** | Global middleware runs before method-specific handlers        |
| **Modular Router Composition** | Combine multiple routers under base paths via `mergeRouter()` |
| **Path Normalization**         | Ensures consistent matching with leading slashes              |
| **Efficient Lookup**           | Matches by comparing segmented paths with param extraction    |
| **Strict Typing**              | Full TypeScript support for safety and clarity                |
| **Easy to Extend**             | Add validation, param coercion, and logging as needed         |

---

## ‚öôÔ∏è Execution Flow in TezX

1. **Route Registration:** You add routes or middleware via `addRoute()` or `app.use()`.
2. **Incoming Request:** TezX calls `search(method, path)` on your router.
3. **Route Matching:** Your router returns middleware + handlers with extracted params.
4. **Middleware Execution:** Middleware registered on `"ALL"` runs first, controlling flow with `await next()`.
5. **Handler Execution:** Matched route handlers execute after middleware completes.
6. **Response Generation:** Handlers generate response; middleware can modify `ctx` at any step.

---

## üß© Middleware and `use()` Method

* Middleware registered with `app.use(path, handler)` internally uses the `"ALL"` HTTP method.
* This means middleware runs for **every HTTP method** on matching paths.
* Middleware stacks can be layered, reusable, and scoped to sub-paths.
* Supports async flow control with `next()`.

---
