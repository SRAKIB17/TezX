
# ðŸš€ TezX Router â€” Complete Developer Guide

`Router` is the heart of the **tezx** web framework, providing a modern, flexible, and high-performance way to handle HTTP routing, middleware, static assets, sub-routing, and even Server-Sent Events (SSE).

---

## Import & Initialization

```ts
import { Router } from "tezx";

// Create a new Router instance
const app = new Router({
  basePath: "/",           // Base path for all routes (default: "/")
  env: { NODE_ENV: "prod" } // Optional environment variables accessible in middleware
});
```

---

## Core Concepts

* **Route registration:** Define endpoints with HTTP methods (`GET`, `POST`, etc.).
* **Middleware support:** Chain multiple middlewares per route.
* **Route grouping:** Organize routes under common prefixes.
* **Sub-routers:** Modularize your API by mounting routers under paths.
* **Static files:** Serve assets like images, CSS, JS seamlessly.
* **SSE (Server-Sent Events):** Real-time server push via HTTP.

---

## 1. Defining Routes

### Basic Route Handler

```ts
app.get("/hello", (ctx) => {
  ctx.body = "Hello from TezX!";
});
```

* `ctx` is the request context, including request info, response methods, params, and more.
* Set response by assigning to `ctx.body`.

### Route with Middleware

```ts
const auth = async (ctx, next) => {
  if (!ctx.user) {
    ctx.setStatus = 401;
    return ctx.text("Unauthorized");
  }
  await next(); // Proceed to next middleware or handler
};

app.get("/profile", auth, (ctx) => {
 return ctx.json({ user: ctx.user });
});
```

* Middleware intercepts the request and can halt or continue the chain.
* Middleware functions accept `(ctx, next)` and must call `await next()` to continue.

### Multiple Middlewares

```ts
const log = (ctx, next) => {
  console.log(`${ctx.method} ${ctx.pathname}`);
  return next();
};

const adminOnly = (ctx, next) => {
  if (!ctx.user?.isAdmin) {
    ctx.setStatus = 403;
    return ctx.text("Forbidden");
  }
  return next();
};

app.get("/admin/dashboard", [auth, log, adminOnly], (ctx) => {
  return {
    body: "Admin Dashboard"
  }
});
```

---

## 2. HTTP Methods Supported

Use methods matching HTTP verbs:

* `.get(path, ...middleware, handler)`
* `.post(path, ...middleware, handler)`
* `.put(path, ...middleware, handler)`
* `.patch(path, ...middleware, handler)`
* `.delete(path, ...middleware, handler)`
* `.options(path, ...middleware, handler)`
* `.all(path, ...middleware, handler)` â€” match all HTTP methods

Example:

```ts
app.post("/submit", (ctx) => {
  const data = ctx.request.body;
  return ctx.json({ received: data });
});
```

---

## 3. Static File Serving

Serve files from a local folder under a route:

```ts
app.static("/assets", "./public/assets");
```

* Supports directory-based static serving.
* Use for images, CSS, JS, or any public assets.
* You can also serve at root:

```ts
app.static("./public");
```

---

## 4. Grouping Routes for Cleaner Code

Group related routes under a common prefix:

```ts
app.group("/api/v1", (router) => {
  router.get("/users", (ctx) => { /*...*/ });
  router.post("/users", (ctx) => { /*...*/ });
});
```

* `group` creates a new sub-router scoped to the prefix.
* Improves modularity and readability.

---

## 5. Mounting Sub-Routers

Build modular routers and mount them at a path:

```ts
const adminRouter = new Router();

adminRouter.use(auth); // Apply auth middleware to all admin routes

adminRouter.get("/dashboard", (ctx) => {
  return ctx.text("Welcome, admin!")
});

app.addRouter("/admin", adminRouter);
```

* `addRouter` mounts another router at the specified base path.
* Sub-routers can have their own middleware, routes, and groups.

---

## 6. Middleware Usage & Notes

* Middleware signature: `async (ctx, next) => { ... }`
* Call `await next()` to pass control.
* Can short-circuit by not calling `next()`.
* Can attach data to `ctx` (e.g., `ctx.user = ...`).
* Supports arrays of middlewares for routes or groups.

---

## 8. Example: Full Mini App

```ts
import { Router } from "tezx";

const app = new Router();

const logger = async (ctx, next) => {
  console.log(`${ctx.method} ${ctx.pathname}`);
  await next();
};

const auth = async (ctx, next) => {
  const token = ctx.headers["authorization"];
  if (token !== "secret-token") {
    ctx.setStatus = 401;
    return ctx.text("Unauthorized");
  }
  ctx.user = { name: "Alice" };
  await next();
};

app.use(logger);

app.get("/", (ctx) => {
  return ctx.text("Welcome to TezX Router!");
});

app.group("/api", (api) => {
  api.get("/public", (ctx) => {
    return ctx.text("Public API data");
  });

  api.get("/private", auth, (ctx) => {
    return ctx.text(`Hello ${ctx.user.name}, this is private data.`);
  });
});

app.static("/static", "./public");

export default app;
```

---

## 9. Tips for Success

* Use `.group()` and `.addRouter()` to keep routes modular and maintainable.
* Always validate input in middleware before reaching handlers.
* Use static serving for your frontend assets or uploads.
* Compose middlewares to reuse authentication, logging, or error handling.
* Use `.all()` to apply middleware or handlers for all HTTP methods on a path.

---
