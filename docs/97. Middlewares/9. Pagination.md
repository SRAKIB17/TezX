# Pagination Middleware

## Overview

The `paginationHandler` is an advanced middleware designed to streamline pagination in web applications. It automates query parameter parsing, supports dynamic data fetching, and provides comprehensive pagination metadata, making it ideal for APIs requiring paginated responses.

### Features

- **Automatic Parameter Handling**: Parses `page` and `limit` from query strings with sanitization.
- **Dynamic Data Integration**: Fetches paginated data via a configurable `getDataSource`.
- **Rich Metadata**: Includes total items, total pages, next/previous page indicators, and more.
- **Flexible Workflow**: Integrates with subsequent middleware via `next()` when `getDataSource` is used.
- **Error Handling**: Ensures robust input validation and fallback behavior.

### Dependencies

```typescript
import { Context } from "tezx";
import { Middleware } from "tezx";
```

- **`Context`**: Base context type for request handling, providing access to `req`, `body`, etc.
- **`Middleware`**: Type for middleware functions that process requests and optionally call `next()`.

---

## Types

### `PaginationOptions`

Configuration options for customizing pagination behavior.

```typescript
export type PaginationOptions = {
  /**
   * 🔢 Default page number when not specified
   * @default 1
   * @example 1 // Start from first page
   */
  defaultPage?: number;

  /**
   * 📏 Default items per page
   * @default 10
   * @example 25 // Show 25 items by default
   */
  defaultLimit?: number;

  /**
   * ⚠️ Maximum allowed items per page
   * @default 100
   * @example 50 // Never return more than 50 items
   */
  maxLimit?: number;

  /**
   * 🔍 Query parameter name for page number
   * @default "page"
   * @example "p" // Use ?p=2 instead of ?page=2
   */
  queryKeyPage?: string;

  /**
   * 🔍 Query parameter name for items limit
   * @default "limit"
   * @example "size" // Use ?size=20
   */
  queryKeyLimit?: string;

  /**
   * 📊 Key to read total count from response
   * @default "total"
   * @example "totalCount" // Read from response.totalCount
   */
  countKey?: string;

  /**
   * 📦 Key containing the data array in response
   * @default "data"
   * @example "items" // Process response.items array
   */
  dataKey?: string;

  /**
   * 🛠️ Function to fetch data dynamically
   * @param ctx - Request context
   * @param pagination - Pagination details (page, limit, offset)
   * @returns Promise resolving to an object with data and total count
   * @example
   * getDataSource: async (ctx, { page, limit }) => {
   *   return db.find().skip((page-1)*limit).limit(limit);
   * }
   */
  getDataSource?: <T extends Record<string, any> = {}>(
    ctx: Context<T>,
    pagination: { page: number; limit: number; offset: number },
  ) => Promise<{ [key: string]: any }>;
};
```

### `PaginationBodyType`

Structure of the response body when `getDataSource` is used.

```typescript
export type PaginationBodyType = {
  [x: string]: any;
  pagination: {
    page: number;
    limit: number;
    totalItems: any;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
    nextPage: number | null;
    prevPage: number | null;
  };
};
```

---

## Function

### `paginationHandler`

Creates a middleware function for handling pagination.

#### Signature

```typescript
export const paginationHandler = (options: PaginationOptions = {}): Middleware;
```

#### Parameters

- **`options: PaginationOptions`** (Optional) – Configuration object for pagination settings. Defaults to an empty object.

#### Returns

- **`Middleware`**: A function that processes pagination and either sets `ctx.body` or proceeds to `next()`.

#### Description

Handles pagination by:

1. Parsing and sanitizing `page` and `limit` query parameters.
2. Attaching pagination metadata to `ctx.pagination`.
3. Optionally fetching data via `getDataSource`, constructing a `PaginationBodyType` response, and setting `ctx.body`.
4. Supporting middleware chaining with `next()` when applicable.

---

## Examples

### 1. Basic Usage

Attaching pagination context without a data source.

```typescript
app.get("/users", paginationHandler(), async (ctx) => {
  const { page, limit, offset } = ctx.pagination;
  const users = await db.users.find().skip(offset).limit(limit);
  const total = await db.users.countDocuments();
  return ctx.json({ data: users, total });
});
```

**Request**: `GET /users?page=2&limit=20`  
**Effect**: Sets `ctx.pagination` with `page: 2`, `limit: 20`, `offset: 20`.  
**Response**:

```json
{
  "data": [
    /* 20 users */
  ],
  "total": 100
}
```

---

### 2. With Dynamic Data Source

Fetching data directly within the middleware.

```typescript
app.get(
  "/products",
  paginationHandler({
    getDataSource: async (ctx, { page, limit, offset }) => {
      const result = await Product.findAndCountAll({
        offset,
        limit,
      });
      return {
        data: result.rows,
        total: result.count,
      };
    },
  }),
  async (ctx) => {
    return ctx.json(ctx.body); // Pass through the pre-set body
  },
);
```

**Request**: `GET /products?page=3&limit=10`  
**Response**:

```json
{
  "data": [
    /* 10 products */
  ],
  "total": 50,
  "pagination": {
    "page": 3,
    "limit": 10,
    "totalItems": 50,
    "totalPages": 5,
    "hasNextPage": true,
    "hasPrevPage": true,
    "nextPage": 4,
    "prevPage": 2
  }
}
```

---

### 3. Custom Query Parameters and Keys

Using custom query names and response keys.

```typescript
app.get(
  "/articles",
  paginationHandler({
    queryKeyPage: "p",
    queryKeyLimit: "size",
    countKey: "totalArticles",
    dataKey: "articles",
    getDataSource: async (ctx, { offset, limit }) => {
      const articles = await Article.find().skip(offset).limit(limit);
      return {
        articles,
        totalArticles: await Article.countDocuments(),
      };
    },
  }),
);
```

**Request**: `GET /articles?p=1&size=5`  
**Response**:

```json
{
  "articles": [
    /* 5 articles */
  ],
  "totalArticles": 25,
  "pagination": {
    "page": 1,
    "limit": 5,
    "totalItems": 25,
    "totalPages": 5,
    "hasNextPage": true,
    "hasPrevPage": false,
    "nextPage": 2,
    "prevPage": null
  }
}
```

---

### 4. Middleware Chaining

Combining with additional middleware.

```typescript
app.get(
  "/orders",
  paginationHandler({
    getDataSource: async (ctx, { offset, limit }) => {
      const orders = await Order.find().skip(offset).limit(limit);
      return {
        data: orders,
        total: await Order.countDocuments(),
      };
    },
  }),
  async (ctx) => {
    const body = ctx.body as PaginationBodyType;
    return ctx.json({
      ...body,
      timestamp: new Date().toISOString(),
    });
  },
);
```

**Request**: `GET /orders?page=2&limit=10`  
**Response**:

```json
{
  "data": [
    /* 10 orders */
  ],
  "total": 30,
  "pagination": {
    "page": 2,
    "limit": 10,
    "totalItems": 30,
    "totalPages": 3,
    "hasNextPage": true,
    "hasPrevPage": true,
    "nextPage": 3,
    "prevPage": 1
  },
  "timestamp": "2025-04-07T12:00:00.000Z"
}
```

---

### 5. Input Sanitization

Handling invalid inputs with limits.

```typescript
app.get(
  "/posts",
  paginationHandler({
    maxLimit: 50,
    getDataSource: async (ctx, { offset, limit }) => {
      const posts = await Post.find().skip(offset).limit(limit);
      return {
        data: posts,
        total: await Post.countDocuments(),
      };
    },
  }),
);
```

**Request**: `GET /posts?page=-1&limit=100`  
**Effect**:

- `page` sanitized to `1`.
- `limit` capped at `50`.  
  **Response**: Contains first 50 posts with metadata.

---

## Best Practices

- **Data Source**: Use `getDataSource` for self-contained logic; omit it to delegate to subsequent middleware.
- **Custom Keys**: Align `countKey` and `dataKey` with your API’s response structure.
- **Limits**: Set `maxLimit` to prevent excessive resource usage.
- **Chaining**: Use `next()` to integrate with additional middleware for response customization.
- **Type Safety**: Extend `Context<T>` with custom properties (e.g., `ctx.user`) for type-safe access.

---

## Notes

- **Response Format**: When `getDataSource` is used, `ctx.body` is set to a `PaginationBodyType` object.
- **Middleware Flow**: Without `getDataSource`, only `ctx.pagination` is set, requiring `next()` for further processing.
- **Compatibility**: Works with Node.js, Bun, and Deno runtimes.

---
