# Pagination Handler Middleware

## Overview

The `paginationHandler` middleware provides comprehensive pagination capabilities for your API endpoints. It handles query parameter parsing, data fetching, and response formatting with pagination metadata.

## Installation

```typescript
import { paginationHandler } from "tezx/middleware";
```

## Basic Usage

```typescript
app.get('/users', paginationHandler(), getUsers);
```

## Advanced Usage with Data Source

```typescript
app.get('/products', paginationHandler({
    defaultLimit: 25,
    maxLimit: 50,
    getDataSource: async (ctx, { page, limit }) => {
        return await Product.findAndCountAll({
            offset: (page-1)*limit,
            limit
        });
    }
}),
(ctx) => {
    //ctx.pagination
    // Middleware will expect ctx.body to contain:
    return ctx.json(ctx.body)
}
);
```

## Configuration Options

### `defaultPage: number`

- **Default**: `1`
- Starting page when no page parameter is provided
- **Example**: `2` (start from second page by default)

### `defaultLimit: number`

- **Default**: `10`
- Default number of items per page
- **Example**: `25` (show 25 items per page by default)

### `maxLimit: number`

- **Default**: `100`
- Maximum allowed items per page (safety limit)
- **Example**: `50` (never return more than 50 items)

### `queryKeyPage: string`

- **Default**: `"page"`
- Query parameter name for page number
- **Example**: `"p"` (use ?p=2 instead of ?page=2)

### `queryKeyLimit: string`

- **Default**: `"limit"`
- Query parameter name for items per page
- **Example**: `"size"` (use ?size=20)

### `countKey: string`

- **Default**: `"total"`
- Response property name for total count
- **Example**: `"totalCount"` (read from response.totalCount)

### `dataKey: string`

- **Default**: `"data"`
- Response property name for data array
- **Example**: `"items"` (process response.items array)

### `getDataSource: Function`

- **Default**: `undefined`
- Optional function to fetch paginated data
- **Parameters**:
  - `ctx`: Request context
  - `pagination`: { page, limit, offset }
- **Returns**: Promise with { [countKey]: number, [dataKey]: any[] }
- **Example**:

```typescript
getDataSource: async (ctx, { page, limit }) => {
    return await Model.findAndCount({
        skip: (page-1)*limit,
        take: limit
    });
}
```

## Response Format

When using `getDataSource`, the middleware returns:

**`ctx.body`**

```json
{
    "data": [......], // Array of items (key configurable via dataKey)
    "total": 100, // Total count (key configurable via countKey)
    "pagination": {
        "page": 1,
        "limit": 10,
        "totalItems": 100,
        "totalPages": 10,
        "hasNextPage": true,
        "hasPrevPage": false,
        "nextPage": 2,
        "prevPage": null
    }
}
```

## Context Augmentation

The middleware adds a `pagination` property to the context:

```typescript
ctx.pagination = {
    page: number,
    limit: number,
    offset: number,
    queryKeyPage: string,
    queryKeyLimit: string
};
```

## Error Handling

The middleware handles several error cases:

- Invalid page/limit parameters (auto-corrects to defaults)
- Data source errors (returns 500 with error message)
- Malformed data source responses (validates structure)

## Best Practices

1. **Combine with other middleware**:

   ```typescript
   app.get('/secure-data', 
     authMiddleware(),
     paginationHandler(),
     getDataController
   );
   ```

2. **Customize for different endpoints**:

   ```typescript
   const strictPagination = paginationHandler({
       defaultLimit: 5,
       maxLimit: 20
   });

   const relaxedPagination = paginationHandler({
       defaultLimit: 50,
       maxLimit: 200
   });
   ```

3. **Implement efficient data sources**:

   ```typescript
   getDataSource: async (ctx, { page, limit }) => {
       const [data, total] = await Promise.all([
           db.query('SELECT * FROM items LIMIT ? OFFSET ?', [limit, offset]),
           db.query('SELECT COUNT(*) FROM items')
       ]);
       return { data, total: total[0].count };
   }
   ```

## Performance Considerations

1. **Database Optimization**:
   - Ensure your queries use indexes for pagination
   - Consider caching count queries for large datasets

2. **Memory Management**:
   - Be cautious with very large `maxLimit` values
   - Consider streaming for very large result sets

3. **Validation**:
   - Validate data source responses match expected structure
   - Implement timeouts for data source operations

## Example Implementations

### Sequelize Example

```typescript
app.get('/products', paginationHandler({
    getDataSource: async (ctx, { page, limit }) => {
        return await Product.findAndCountAll({
            offset: (page-1)*limit,
            limit
        });
    }
}),
(ctx) => {
    // Middleware will expect ctx.body to contain:
    return ctx.json(ctx.body)
}
);
```

### MongoDB Example

```typescript
app.get('/users', paginationHandler({
    getDataSource: async (ctx, { page, limit }) => {
        const [data, total] = await Promise.all([
            User.find().skip((page - 1) * limit).limit(limit),
            User.countDocuments()
        ]);
        return { data, total };
    }
}), (ctx) => {
    // Middleware will expect ctx.body to contain:
    return ctx.json(ctx.body)
});
```

### REST API Example

```typescript
app.get('/users', paginationHandler(), (ctx) => {
    // Middleware will expect ctx.body to contain:
    return ctx.json(ctx.pagination)
});
```
