
## `lazyLoadModules` Middleware

The `lazyLoadModules` middleware enables dynamic, lazy loading of modules in a `tezx` application based on route or query parameters. It supports caching, lifecycle hooks, and module validation to optimize performance and ensure reliability.

### Overview

This middleware is designed to:

- Load modules dynamically using a provided loader function.
- Cache loaded modules to reduce redundant loading.
- Provide lifecycle hooks for custom logic during module loading.
- Validate modules to ensure they meet specific criteria.
- Attach loaded modules to the request context for use in downstream middleware or handlers.

Import the middleware and related types:

```typescript
import { lazyLoadModules } from "tezx/middleware";
```

### Types and Interfaces

#### `LazyModuleLoader<T>`

A function that returns a `Promise` resolving to the module of type `T`.

```typescript
export type LazyModuleLoader<T> = () => Promise<T>;
```

#### `CacheItem<T>`

Represents a cached module with its expiration time.

```typescript
export interface CacheItem<T = any> {
  module: T;
  expiresAt: number; // Expiration timestamp
}
```

#### `LazyLoadOptions<T>`

Configuration options for the `lazyLoadModules` middleware.

| Property            | Type                                                                 | Description                                                                                           | Default                                  |
|---------------------|----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|------------------------------------------|
| `moduleKey`         | `(ctx: Context) => string`                                           | Function to extract the module name from the context.                                                  | `(ctx) => ctx.req.params[queryKeyModule] || ctx.req.query[queryKeyModule]` |
| `getModuleLoader`   | `(ctx: Context) => Promise<LazyModuleLoader<T> \| null> \| null \| LazyModuleLoader<T>` | Function to retrieve the module loader.                                                                | Required                                 |
| `queryKeyModule`    | `string`                                                             | Query parameter name to select the module.                                                             | `"module"`                               |
| `moduleContextKey`  | `string`                                                             | Key to attach the loaded module to the context.                                                        | `"module"`                               |
| `enableCache`       | `boolean`                                                            | Enable caching of loaded modules.                                                                     | `true`                                   |
| `cacheStorage`      | `{ get: (key: string) => CacheItem<T> \| undefined; set: (key: string, value: CacheItem<T>) => void; delete: (key: string) => void; }` | Custom cache storage implementation.                                                                   | `Map<string, CacheItem<T>>`              |
| `cacheTTL`          | `number`                                                             | Cache Time-To-Live (TTL) in milliseconds.                                                             | `3600000` (1 hour)                       |
| `lifecycleHooks`    | `{ onLoad?: (moduleName: string, ctx: Context) => void; onError?: (moduleName: string, error: Error, ctx: Context) => void; onComplete?: (moduleName: string, module: T, ctx: Context) => void; onCacheHit?: (moduleName: string, module: T, ctx: Context) => void; onCacheSet?: (moduleName: string, module: T, ctx: Context) => void; }` | Lifecycle hooks for custom actions during module loading.                                              | `{}`                                     |
| `validateModule`    | `(module: T) => boolean`                                             | Function to validate the loaded module.                                                                | `undefined`                              |

### Usage

The `lazyLoadModules` middleware is used to dynamically load modules based on a module name derived from the request. It can be integrated into a `tezx` application as follows.

#### Example

Below is an example of using the `lazyLoadModules` middleware in a `tezx` application to load feature modules dynamically.

```typescript
import { lazyLoadModules } from "tezx/middleware";

// Define a type for the expected module structure
interface FeatureModule {
  name: string;
  execute: (ctx: Context) => Promise<string>;
}

// Map of module loaders for different features
const moduleLoaders: Record<string, () => Promise<FeatureModule>> = {
  featureA: () => import("./features/featureA.js").then((mod) => mod.default),
  featureB: () => import("./features/featureB.js").then((mod) => mod.default),
};

// Lazy load middleware configuration
const lazyLoadOptions: LazyLoadOptions<FeatureModule> = {
  moduleKey: (ctx) => ctx.req.query.module as string, // Extract module name from query
  getModuleLoader: async (ctx: Context) => {
    const moduleName = ctx.req.query.module as string;
    return moduleLoaders[moduleName] || null; // Return loader or null if not found
  },
  queryKeyModule: "module",
  moduleContextKey: "featureModule",
  enableCache: true,
  cacheTTL: 60000, // Cache for 1 minute
  lifecycleHooks: {
    onLoad: (moduleName, ctx) => {
      console.log(`Loading module: ${moduleName}`);
    },
    onCacheHit: (moduleName, module, ctx) => {
      console.log(`Cache hit for module: ${moduleName}`);
    },
    onComplete: (moduleName, module, ctx) => {
      console.log(`Module ${moduleName} loaded successfully`);
    },
    onError: (moduleName, error, ctx) => {
      console.error(`Failed to load module ${moduleName}: ${error.message}`);
    },
  },
  validateModule: (module) => {
    return !!module && typeof module.execute === "function" && typeof module.name === "string";
  },
};

// Apply the lazy load middleware
app.use(lazyLoadModules<FeatureModule>(lazyLoadOptions));

// Route handler to use the loaded module
app.get("/feature", async (ctx) => {
  const module = ctx.featureModule as FeatureModule;
  if (!module) {
    ctx.setStatus = 404;
    return { error: "Module not found" };
  }
  const result = await module.execute(ctx);
  return { result };
});

```

#### Example Feature Module (`featureA.js`)

```typescript
import { Context } from "tezx";

const featureA = {
  name: "FeatureA",
  async execute(ctx: Context) {
    return `Executing FeatureA for request`;
  },
};

export default featureA;
```

#### Example Request

To load and execute `featureA`, make a request like:

```bash
GET http://localhost:3000/feature?module=featureA
```

**Response** (if successful):

```json
{
  "result": "Executing FeatureA for request"
}
```

If the module is not found or fails validation, an error response is returned with a 500 status.

### Error Handling

- If no module name is provided, the middleware logs a warning and proceeds to the next middleware.
- If no loader is found for the module, an error is thrown with a 500 status.
- If module validation fails, an error is thrown with a 500 status.
- Errors are logged via `GlobalConfig.debugging.error`, and the `onError` lifecycle hook is triggered.

### Best Practices

- **Module Validation**: Always provide a `validateModule` function to ensure loaded modules conform to the expected structure.
- **Cache Management**: Adjust `cacheTTL` based on your application's needs. Use a custom `cacheStorage` (e.g., Redis) for distributed systems.
- **Lifecycle Hooks**: Use lifecycle hooks to log metrics, trigger side effects, or integrate with observability tools.
- **Error Handling**: Implement robust error handling in the `onError` hook to gracefully handle module loading failures.

### Notes

- The middleware assumes the presence of a `GlobalConfig.debugging` object for logging. Ensure it is configured in your application.
- The `init` function on modules is optional and can be used to perform initialization logic with the context.

---
