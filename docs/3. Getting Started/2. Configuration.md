Below is a detailed documentation section for configuring the `TezX` server instance based on the provided code snippet and TypeScript type definitions. This includes explanations for each configuration option (`allowDuplicateMw`, `overwriteMethod`, `logger`, `env`, and `basePath`) and how they integrate into the `TezX` constructor.

---

### **TezX Configuration Documentation**

The `TezX` class constructor accepts a configuration object that defines how the server behaves, including middleware handling, route overwriting, logging, environment variables, and base path settings. Below is a comprehensive guide to configuring a `TezX` instance.

---

#### **Example Configuration**

```typescript
import { loadEnv, logger, TezX } from "./src/index";

const env = loadEnv();
const basePath = "/api"; // Example base path

const server = new TezX({
  logger: logger,          // Custom logger for request/response tracking
  env: env,               // Environment variables
  allowDuplicateMw: true, // Allow duplicate middleware
  basePath,               // Base path for all routes
  overwriteMethod: false  // Prevent overwriting existing route handlers
});
```

---

#### **Configuration Type Definition**

The `TezXConfig` type defines the available options for initializing a `TezX` instance. It extends `RouterConfig` to include routing-specific settings.

```typescript
export type TezXConfig = {
  /**
   * `allowDuplicateMw` determines whether duplicate middleware functions
   * are allowed in the router.
   *
   * - When `true`: The same middleware can be added multiple times.
   * - When `false`: Ensures each middleware is registered only once
   *   per route or application context.
   *
   * @default false
   */
  allowDuplicateMw?: boolean;

  /**
   * `overwriteMethod` controls whether existing route handlers
   * should be overwritten when a new handler for the same
   * HTTP method and path is added.
   *
   * - When `true`: The new handler replaces the existing one.
   * - When `false`: Prevents overwriting, ensuring that the
   *   first registered handler remains active.
   *
   * @default true
   */
  overwriteMethod?: boolean;

  /**
   * `logger` is an optional function that handles logging within the application.
   * It should conform to the `LoggerFnType`, which defines the expected signature
   * for the logging function.
   *
   * If provided, this function will be called for logging purposes throughout
   * the application.
   */
  logger?: LoggerFnType;
} & RouterConfig;

export type RouterConfig = {
  /**
   * `env` allows you to define environment variables for the router.
   * It is a record of key-value pairs where the key is the variable name
   * and the value can be either a string or a number.
   */
  env?: Record<string, string | number>;

  /**
   * `basePath` sets the base path for the router. This is useful for grouping
   * routes under a specific path prefix.
   */
  basePath?: string;
};
```

---

#### **Configuration Options Explained**

1. **`allowDuplicateMw`**
   - **Type**: `boolean`
   - **Default**: `false`
   - **Purpose**: Controls whether the same middleware function can be registered multiple times for a given route or context.
   - **Behavior**:
     - `true`: Allows duplicates (e.g., the same middleware can execute multiple times in the chain).
     - `false`: Ensures uniqueness, filtering out duplicate middleware registrations.
   - **Example**:

     ```typescript
     server.use((ctx, next) => next()); // First instance
     server.use((ctx, next) => next()); // Second instance (allowed if true)
     ```

2. **`overwriteMethod`**
   - **Type**: `boolean`
   - **Default**: `true`
   - **Purpose**: Determines if a new route handler for an existing HTTP method and path overwrites the previous handler.
   - **Behavior**:
     - `true`: New handler replaces the old one.
     - `false`: Original handler is preserved, and the new one is ignored.
   - **Example**:

     ```typescript
     server.get("/products", (ctx) => ctx.text("Old")); // Initial handler
     server.get("/products", (ctx) => ctx.text("New")); // Overwrites if true
     ```

3. **`logger`**
   - **Type**: `LoggerFnType` (custom function type, assumed to be defined elsewhere)
   - **Default**: `undefined`
   - **Purpose**: Provides a logging function for tracking requests, responses, or errors throughout the application.
   - **Behavior**: If supplied, `TezX` calls this function at appropriate points (e.g., request start/end).
   - **Example**:

     ```typescript
     const logger = (msg: string) => console.log(`[LOG] ${msg}`);
     const server = new TezX({ logger });
     ```

4. **`env`**
   - **Type**: `Record<string, string | number>`
   - **Default**: `undefined`
   - **Purpose**: Supplies environment variables to the application, typically loaded via `loadEnv`.
   - **Behavior**: Makes variables accessible within the app (e.g., for configuration).
   - **Example**:

     ```typescript
     const env = { PORT: "3001", API_KEY: "secret" };
     const server = new TezX({ env });
     console.log(server.config.env.PORT); // "3001"
     ```

5. **`basePath`**
   - **Type**: `string`
   - **Default**: `undefined`
   - **Purpose**: Sets a prefix for all routes registered with the server.
   - **Behavior**: Prepends the base path to all route definitions (e.g., `/api/products` instead of `/products`).
   - **Example**:

     ```typescript
     const server = new TezX({ basePath: "/api" });
     server.get("/products", (ctx) => ctx.text("Products")); // Accessible at /api/products
     ```

---

#### **Usage Example with Routes**

```typescript
import { denoAdapter, loadEnv, logger, Router, TezX } from "./src/index";

const env = loadEnv();
const basePath = "/api";

const server = new TezX({
  logger: logger,
  env: env,
  allowDuplicateMw: true,
  basePath,
  overwriteMethod: false
});

// Standalone route (becomes /api/products/test with basePath)
server.get("/products/test", (ctx) => ctx.text("from outside"));

// Product router
const productRouter = new Router({});
productRouter.group("", (group) => {
  group.use((ctx, next) => {
    console.log("inside router");
    return next();
  });
  group.get("/products", async (ctx) => ctx.json({}));
});
server.use("/", productRouter);

// Start server
denoAdapter(server).listen(3001, () => {
  console.log("Server running on http://localhost:3001");
});
```

- **Resulting Routes**:
  - `/api/products/test`
  - `/api/products`

---

#### **Key Interactions**

- **`allowDuplicateMw` + Middleware**: With `true`, middleware like `console.log("inside router")` can be added multiple times, executing repeatedly.
- **`overwriteMethod` + Routes**: With `false`, attempting to redefine `/products` wonâ€™t overwrite the original handler.
- **`basePath` + Routes**: All routes inherit `/api`, simplifying API versioning or prefixing.

---

#### **Best Practices**

1. **Set `overwriteMethod: false` in Production**: Prevents accidental route overwrites.
2. **Use `basePath` for Organization**: Group related routes under a prefix (e.g., `/v1`).
3. **Provide a Robust `logger`**: Include timestamps and request details for debugging.
4. **Validate `env` Usage**: Ensure critical variables (e.g., `PORT`) are accessed safely.

---

This documentation covers the configuration options comprehensively. Let me know if you need further details (e.g., `LoggerFnType` definition) or examples!
