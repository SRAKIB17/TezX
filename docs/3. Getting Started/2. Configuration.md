# üöÄ TezX Configuration Guide

The `TezX` framework is **highly configurable**, letting you fine-tune routing, environment handling, middleware, and even plug in your own **custom router**.

This guide explains every option you can pass to the `TezX` constructor, including **advanced use cases with `routeRegistry`**.

---

## ‚ö° Quick Example

```ts
import { TezX } from "tezx";
import { loadEnv } from "tezx/bun";

const env = loadEnv();

const app = new TezX({
  debugMode: true,
  env,
  basePath: "/api",
});
```

---

## üß† `TezXConfig` at a Glance

Here‚Äôs the configuration shape:

```ts
export type TezXConfig = {
  debugMode?: boolean;
  onPathResolve?: (pathname: string) => string;
  routeRegistry?: RouteRegistry; // plug in custom router
} & RouterConfig;

export type RouterConfig = {
  env?: Record<string, string | number>;
  basePath?: string;
};
```

---

## ‚öôÔ∏è Available Options

### 1. `debugMode`

* **Type**: `boolean`
* **Default**: `false`
* **What it does**: Enables verbose request/error logging for development.

```ts
const app = new TezX({ debugMode: true });
```

---

### 2. `env`

* **Type**: `Record<string, string | number>`
* **What it does**: Inject environment variables into the app.

```ts
const env = { PORT: "3001", API_KEY: "secret" };
const app = new TezX({ env });
console.log(process.env.PORT); // "3001"
```

---

### 3. `basePath`

* **Type**: `string`
* **What it does**: Prefixes all routes with a global path (ideal for **API versioning**).

```ts
const app = new TezX({ basePath: "/v1" });

app.get("/users", (ctx) => ctx.text("v1 Users"));
// ‚Üí accessible at /v1/users
```

---

### 4. `onPathResolve`

* **Type**: `(pathname: string) => string`
* **What it does**: Hook to rewrite or normalize request paths before routing.

```ts
const app = new TezX({
  onPathResolve: (path) => path.toLowerCase().replace(/\/+$/, ""),
});
```

---

### 5. `routeRegistry`

* **Type**: `RouteRegistry`
* **What it does**: Supply your own **custom router** implementation.
* **Why**: Lets you control route resolution, sub-routing, and middleware execution at a lower level.

---

## üß© Using a Custom Router (`routeRegistry`)

You can pass any router implementing the `RouteRegistry` interface to `TezX`.

This gives you **complete control** over how routes are matched and middleware is executed.

### Example: Plugging in a Custom Router

```ts
import { TezX } from "tezx";
import { PowerfulCustomRouter } from "./PowerfulCustomRouter";
const customRouter = new PowerfulCustomRouter();
const app = new TezX({
  debugMode: true,
  routeRegistry: customRouter,
});
```

### How It Works

* `TezX` internally calls `routeRegistry.search(method, path)` to resolve handlers.
* Middleware registered with `"ALL"` runs before method-specific handlers.
* Supports all HTTP methods + route parameters.

---

## üõ† Real-World Example: Sub-Routing with Custom Router

```ts
import { TezX } from "tezx";
import { CustomRouter } from "./CustomRouter";

const router = new CustomRouter();

router.addRoute("GET", "/hello", [
  async (ctx) => ctx.text("Hello from custom router!"),
]);

const app = new TezX({
  debugMode: true,
  routeRegistry: router,
  basePath: "/api",
});

app.use("/api", async (ctx, next) => {
  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);
  await next();
});

// Start server with Bun, Deno, or Node.js
```

---

## üì¶ Summary of Options

| Option          | Type                               | Purpose                                  |
| --------------- | ---------------------------------- | ---------------------------------------- |
| `debugMode`     | `boolean`                          | Enable verbose request/error logging     |
| `env`           | `Record<string, string \| number>` | Inject environment variables             |
| `basePath`      | `string`                           | Add global prefix to all routes          |
| `onPathResolve` | `(pathname: string) => string`     | Normalize/transform paths before routing |
| `routeRegistry` | `RouteRegistry`                    | Use a custom router implementation       |

---

## ‚úÖ Best Practices

* Use **`basePath`** for API versioning (e.g., `/v1`, `/v2`).
* Inject a **custom router** (`routeRegistry`) for fine-grained control.
* Use **`onPathResolve`** to normalize paths (lowercasing, trimming).
* Pass **`env`** for consistent environment configs across runtimes.

---
