# üì¶ RadixRouter

`RadixRouter` is a high-performance, memory-efficient HTTP routing system inspired by radix trees. Designed for flexibility and speed, it supports advanced routing patterns and middleware composition, making it ideal for scalable backend frameworks.

---

## üîç Overview

* **Static Routes:** Match exact paths like `/users`
* **Dynamic Parameters:** Capture URL segments (`/users/:id`)
* **Optional Parameters:** Support routes like `/users/:id?`
* **Wildcards:** Handle catch-all paths (`/files/*path`)
* **Middleware Stacking:** Support for global and route-specific middleware
* **Router Composition:** Merge routers for modular, maintainable routing

---

## üìÑ Class: `RadixRouter`

### Constructor

```ts
import { RadixRouter } from "tezx/registry";

const router = new RadixRouter();
```

Instantiates a new router with an optimized radix tree for path matching.

---

## ‚öôÔ∏è API Methods

### `addRoute`

```ts
addRoute(method: HTTPMethod, path: string, handlers: (Callback | Middleware)[]): void;
```

Registers a route with the specified HTTP method, path pattern, and middleware/handlers.

* **`method`**: HTTP method (e.g., `"GET"`, `"POST"`, `"PUT"`, `"DELETE"`)
* **`path`**: Route path, supporting dynamic (`:param`), optional (`:param?`), and wildcard (`*`, `*name`) segments
* **`handlers`**: Array of middleware or handler functions to execute on match

**Example:**

```ts
router.addRoute("GET", "/users/:id", [getUserHandler]);
router.addRoute("GET", "/files/*path", [serveFileHandler]);
```

---

### `search`

```ts
search(method: HTTPMethod, path: string): RouteMatchResult;
```

Finds and returns the route matching the given HTTP method and URL path.

**Returns:**

```ts
{
  method: HTTPMethod;
  middlewares: Middleware[];
  handlers: (Callback | Middleware)[];
  params: Record<string, string | null>;
}
```

**Example:**

```ts
const match = router.search("GET", "/users/42");
/*
{
  method: "GET",
  params: { id: "42" },
  handlers: [...],
  middlewares: [...]
}
*/
```

---

### `mergeRouter`

```ts
mergeRouter(basePath: string, childRouter: RadixRouter): void;
```

Composes a child router under a specified base path, enabling modular route organization.

**Use Case:**

Create feature-specific routers and merge under a common prefix.

**Example:**

```ts
const apiRouter = new RadixRouter();
apiRouter.addRoute("GET", "/users", [usersHandler]);

router.mergeRouter("/api", apiRouter);
// Now `/api/users` is handled by usersHandler
```

---

## üß© Internal: `parsePattern`

Transforms route patterns into segments for efficient radix tree insertion and matching.

```ts
type Segment = {
  type: "static" | "dynamic" | "wildcard";
  value?: string;
  paramName?: string;
  isOptional?: boolean;
};
```

---

## ‚ö° Matching Priority

Routes are matched in the following order to ensure deterministic behavior:

1. **Static segments** (`/users`)
2. **Dynamic segments** (`/users/:id`)
3. **Optional dynamic segments** (`/users/:id?`)
4. **Wildcard segments** (`/files/*path`)

Backtracking allows optional segments to gracefully fallback when no match is found.

---

## üìä Performance Metrics

`RadixRouter` delivers blazing fast route resolution even with hundreds of routes:

```text
Benchmark:
431 routes √ó 100,000 matches = 43.1 million matches
Completed in ~11,983 ms (~278 ns per match)
```

This performance makes it suitable for high-traffic, latency-sensitive applications.

---

## üõ† Types

### `RouteMatchResult<T>`

```ts
{
  method: HTTPMethod;
  middlewares: Middleware<T>[];
  handlers: HandlerType<T>;
  params: Record<string, string | null | undefined>;
}
```

### `RouteRegistry`

```ts
interface RouteRegistry {
  name: string;
  addRoute<T = any>(method: HTTPMethod, path: string, handler: HandlerType<T>): void;
  search(method: HTTPMethod, path: string): RouteMatchResult<T>;
  mergeRouter?(path: string, router: this): void;
}
```

---

## üöÄ Example Usage

```ts
const router = new RadixRouter();

router.addRoute("GET", "/hello", [
  (ctx) => ctx.text("Hello World"),
]);

router.addRoute("GET", "/user/:id?", [
  (ctx) => ctx.text(`User ID: ${ctx.params.id ?? "Guest"}`),
]);

const match = router.search("GET", "/user/123");
await match.handlers[0](context); // Executes matched handler
```
