{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": [
        {
          "originalPath": "0.v2.0.0üÜï.md",
          "id": 1,
          "name": "V2.0.0üÜï",
          "type": "file",
          "path": "release-note/v200",
          "content": "\n# üì¶ TezX 2.0.0 ‚Äî Modular Runtime Support\n\nTezX v2.0.0 introduces **runtime-aware modules** with clean separation of Node.js, Bun, and Deno environments.\n\n> üåü **Faster builds, smaller bundles, cleaner DX.**\n\n---\n\n## ‚úÖ Unified Yet Modular API\n\n### ‚ú® Import Based on Runtime\n\n| Runtime | Import From | Features                   |\n| ------- | ----------- | -------------------------- |\n| Node.js | `tezx/node` | `nodeAdapter`, `loadEnv()` |\n| Bun     | `tezx/bun`  | `bunAdapter`, `loadEnv()`  |\n| Deno    | `tezx/deno` | `denoAdapter`, `loadEnv()` |\n\n---\n\n## üìò Usage\n\n### ‚ñ∂Ô∏è Node.js\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/node\";\n\nconst env = loadEnv();\nconst app = nodeAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Hello from Node.js\"));\n```\n\n---\n\n### ‚ö° Bun\n\n```ts\nimport { bunAdapter, loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\nconst app = bunAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Powered by Bun!\"));\n```\n\n---\n\n### ü¶ï Deno\n\n```ts\nimport { denoAdapter, loadEnv } from \"tezx/deno\";\n\nconst env = loadEnv();\nconst app = denoAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Running in Deno\"));\n```\n\n> üîê Required for Deno:\n>\n> ```bash\n> deno run --allow-env --allow-net app.ts\n> ```\n\n---\n\n## üîç Migration Guide (v1 ‚Üí v2)\n\n### üîÅ Before (v1.x)\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/adapter\";\n```\n\n### ‚úÖ After (v2.0.0)\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/node\";\n```\n\n> Apply same for `bunAdapter` or `denoAdapter`.\n\n---\n\n## üéØ Why This Change?\n\n* ‚úÖ **Tree-shaking friendly**\n* ‚úÖ Smaller builds per runtime\n* ‚úÖ Platform-specific optimization\n* ‚úÖ Clear developer ergonomics\n* ‚úÖ Future plugin & extension readiness\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "2. Need to know.md",
      "id": 2,
      "name": "Need To Know",
      "type": "file",
      "path": "need-to-know",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typecript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```ts\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```ts\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { nodeAdapter,loadEnv } from \"tezx/node\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { bunAdapter } from \"tezx/bun\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { denoAdapter } from \"tezx/deno\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true,\n    \"removeComments\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\",\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n````ts\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * üîÑ Hook to transform or normalize the incoming request pathname before routing.\n   *\n   * This function allows you to customize how incoming paths are handled.\n   * You can use it to:\n   * - Remove trailing slashes\n   * - Normalize casing\n   * - Rewrite certain paths dynamically\n   * - Add localization or versioning prefixes\n   *\n   * @example\n   * ```ts\n   * onPathResolve: (pathname) => pathname.replace(/\\/+$/, \"\").toLowerCase()\n   * ```\n   *\n   * @param pathname - The raw incoming request path (e.g., `/Api/Users/`)\n   * @returns The transformed or resolved path used for routing (e.g., `/api/users`)\n   */\n  onPathResolve?: (pathname: string) => string;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n````\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```ts\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```ts\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```ts\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n---\n\n### **6. `onPathResolve`**\n\n- **Type**: `Function`\n- **Default**: `undefined`\n- **Purpose**: Sets a custom path resolver function for route paths.\n- **Behavior**: Allows modification of the path before it is used for routing. The function receives the original path and returns a modified path, if needed.\n- **Example**:\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => {\n    if (path === \"/home\") return \"/\";\n    if (path === \"/user-profile\") return \"/profile\";\n    return path;\n  },\n});\n```\n\n---\n\n## **Usage Example with Routes**\n\n```ts\nimport { Router, TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport {loadEnv, denoAdapter } from \"tezx/deno\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n```ts\nconst logger = (msg: string) =>\n  console.log(`[${new Date().toISOString()}] ${msg}`);\n```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n```ts\nconst port = app.config.env.PORT || \"3000\";\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "4. Adapter",
      "name": "Adapter",
      "path": "adapter",
      "type": "folder",
      "children": [
        {
          "originalPath": "bun",
          "name": "Bun",
          "path": "adapter/bun",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Bun.md",
              "id": 5,
              "name": "Bun",
              "type": "file",
              "path": "adapter/bun/bun",
              "content": "## `bunAdapter` Documentation\n\n### **Overview**\n\n`bunAdapter` is a function that configures and runs a Bun server integrated with the TezX framework. It handles HTTP requests, WebSocket connections, and custom error handling. The server can be configured to run on a Unix socket or a TCP/IP port and supports advanced features like Hot Module Replacement (HMR), custom request handling, and WebSocket management.\n\n---\n\n### **Usage**\n\n```typescript\nimport { bunAdapter } from \"tezx/bun\";\nimport { TezX } from \"tezx\";\n\n// Example TezX instance\nconst TezXInstance = new TezX();\n\n// Server options\nconst serverOptions = {\n  unix: \"/tmp/tezx.sock\", // Listen on a Unix socket\n  maxRequestBodySize: 1024 * 1024 * 64, // 64MB max request body size\n  development: {\n    hmr: true, // Enable hot module replacement for development\n  },\n  port: 3000, // Listen on port 3000\n  tls: {\n    // Optional TLS configuration for secure server\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n\n// Initialize Bun adapter\nconst adapter = bunAdapter(TezXInstance, serverOptions);\n\n// Start the server\nadapter.listen(3000, () => {\n  console.log(\"Bun server is up and running!\");\n});\n```\n\n---\n\n### **API Documentation**\n\n#### **`bunAdapter` Function**\n\n##### **Parameters**\n\n- **TezX** (`TezX<T>`): The TezX framework instance you want to use for request handling.\n- **options** (`Object`): Configuration options for the server. Can include:\n\n  - **unix** (`string`): If set, the HTTP server will listen on a Unix socket instead of a TCP port. **Cannot be used with `port`**.\n  - **maxRequestBodySize** (`number`): Maximum size of a request body (in bytes). Default is 128MB (`1024 * 1024 * 128`).\n  - **development** (`boolean | Object`): Configuration for development mode.\n\n    - **hmr** (`boolean`): If set to true, enables Hot Module Replacement (HMR) for routes (especially useful for React projects).\n\n  - **error** (`Function`): A custom error handler function that will be invoked when an error occurs.\n\n    - **Arguments**:\n      - `s`: Bun's `serve` instance.\n      - `error`: The `Error` object.\n\n  - **port** (`string | number`): The port number on which the server should listen. Defaults to `process.env.PORT` or `3000`.\n  - **hostname** (`string`): The hostname the server should listen on. Defaults to `0.0.0.0` (all interfaces).\n  - **tls** (`Bun.TLSOptions | Bun.TLSOptions[]`): Optional configuration for TLS/SSL certificates to enable HTTPS.\n  - **idleTimeout** (`number`): The number of seconds to wait before timing out a connection due to inactivity. Defaults to `10` seconds.\n  - **reusePort** (`boolean`): Whether the `SO_REUSEPORT` flag should be set to allow multiple processes to bind to the same port for load balancing.\n  - **ipv6Only** (`boolean`): If set to true, the server will only listen on IPv6 addresses.\n\n##### **Returns**\n\n- An object with a `listen` method, which starts the server.\n\n#### **`listen` Method**\n\n##### **Parameters**\n\n- **port** (`number`): The port number on which the server should listen.\n- **callback** (`Function` | `undefined`): An optional callback function that will be invoked after the server has started successfully.\n\n##### **Description**\n\n- The `listen` method starts the Bun server with the configured options. It listens either on a Unix socket or a TCP port (based on the configuration) and handles HTTP requests and WebSocket connections.\n- If the `unix` option is provided, the server listens on a Unix socket and does not use a TCP port. If `unix` is not provided, the server listens on the specified port or defaults to port `3000`.\n\n- The server can handle both HTTP requests and WebSocket connections, delegating requests to the TezX instance for processing.\n\n---\n\n### **WebSocket Handling**\n\nThe Bun server supports WebSocket connections and provides custom WebSocket handlers:\n\n- **open(ws)**: Called when a WebSocket connection is opened.\n- **message(ws, msg)**: Called when a message is received from the WebSocket client.\n- **close(ws, code, reason)**: Called when the WebSocket connection is closed.\n- **ping(ws, data)**: Called when a ping frame is received.\n- **pong(ws, data)**: Called when a pong frame is received.\n- **drain(ws)**: Called when the WebSocket‚Äôs message queue is drained.\n\n---\n\n### **Error Handling**\n\nYou can customize the error handling by providing an `error` handler in the options:\n\n```typescript\nconst serverOptions = {\n  error: (server: Bun.Serve, error: Error) => {\n    // Custom error handling logic\n    console.error(\"An error occurred:\", error);\n    return new Response(\"Internal Server Error\", { status: 500 });\n  },\n};\n```\n\n---\n\n### **Development Mode (HMR)**\n\nFor development purposes, you can enable Hot Module Replacement (HMR), which allows for live reloading of routes without restarting the server. This is especially useful when building single-page applications (SPAs) with frameworks like React.\n\nTo enable HMR:\n\n```typescript\nconst serverOptions = {\n  development: {\n    hmr: true, // Enables HMR for React or other frameworks\n  },\n};\n```\n\n---\n\n### **TLS Configuration**\n\nIf you need to serve the application over HTTPS, you can specify TLS options in the configuration:\n\n```typescript\nconst serverOptions = {\n  tls: {\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n```\n\n---\n\n### **Example Configuration:**\n\n```typescript\nimport { bunAdapter } from \"tezx/bun\";\nimport { TezX } from \"tezx\";\n\nconst TezXInstance = new TezX();\n\nconst serverOptions = {\n  unix: \"/tmp/tezx.sock\", // Listen on Unix socket\n  maxRequestBodySize: 1024 * 1024 * 64, // Limit body size to 64MB\n  development: {\n    hmr: true, // Enable HMR for development\n  },\n  error: (server, error) => {\n    console.error(error);\n    return new Response(\"An error occurred\", { status: 500 });\n  },\n  tls: {\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n\nconst adapter = bunAdapter(TezXInstance, serverOptions);\n\nadapter.listen(3000, () => {\n  console.log(\"Server is running at http://localhost:3000\");\n});\n```\n\n---\n"
            },
            {
              "originalPath": "2. Bun Configure.md",
              "id": 6,
              "name": "Bun Configure",
              "type": "file",
              "path": "adapter/bun/bun-configure",
              "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun;\nnpm install @types/bun;\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { bunAdapter ,loadEnv} from \"tezx/bun\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
            }
          ]
        },
        {
          "originalPath": "deno",
          "name": "Deno",
          "path": "adapter/deno",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Deno.md",
              "id": 7,
              "name": "Deno",
              "type": "file",
              "path": "adapter/deno/deno",
              "content": "## `denoAdapter` Documentation\n\n### **Overview**\n\nThe `denoAdapter` function is designed to adapt the TezX framework to the Deno runtime. It allows you to run a TezX-powered server on Deno, supporting both Unix socket and TCP/IP transport methods, with optional TLS encryption for secure communication.\n\n---\n\n### **Key Features**\n\n1. **Cross-Platform Support**: Works on both Unix sockets (`unix`) and TCP/IP (`tcp`) transport.\n2. **TLS/SSL Support**: Secure communication via HTTPS if TLS certificates are provided.\n3. **Flexible Configuration**: Allows custom configurations such as port, transport, and TLS settings.\n4. **Easy Integration**: Integrates seamlessly with the TezX framework, handling incoming requests and responses.\n5. **Logging & Debugging**: Logs server startup information with clear success messages, including protocol and address.\n\n---\n\n### **Usage Example**\n\n#### **1. Basic Setup**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX server instance\nconst app = new TezX();\n\n// Configure server options\nconst serverOptions = {\n  transport: \"tcp\", // Listen on TCP transport\n  port: 3000, // Port number\n};\n\n// Initialize Deno adapter with TezX instance and server options\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server and log success\nadapter.listen(3000, () => {\n  console.log(\"Deno server running on TCP at port 3000\");\n});\n```\n\n#### **2. Setup with TLS (Secure Server)**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX instance\nconst app = new TezX();\n\n// TLS configuration (certificate and key for HTTPS)\nconst serverOptions = {\n  transport: \"tcp\", // Listen on TCP\n  port: 443, // HTTPS port\n  tls: {\n    cert: \"path/to/cert.pem\", // Path to TLS certificate\n    key: \"path/to/key.pem\", // Path to private key\n  },\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server\nadapter.listen(443, () => {\n  console.log(\"Secure Deno server running on HTTPS port 443\");\n});\n```\n\n#### **3. Setup with Unix Socket**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX instance\nconst app = new TezX();\n\n// Unix socket configuration\nconst serverOptions = {\n  transport: \"unix\", // Listen on Unix socket\n  path: \"/tmp/tezx.sock\", // Path to the Unix socket\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server\nadapter.listen(undefined, () => {\n  console.log(\"Deno server running on Unix socket /tmp/tezx.sock\");\n});\n```\n\n---\n\n### **API Documentation**\n\n#### **`denoAdapter` Function**\n\n##### **Parameters**\n\n- **`TezX`** (`TezX<T>`): The TezX instance that handles the incoming requests.\n- **`options`** (`Deno.ServeUnixOptions | Deno.ServeTcpOptions | (Deno.ServeTcpOptions & Deno.TlsCertifiedKeyPem)`):\n  - **`transport`** (`string`): Specifies the transport method. Acceptable values:\n    - `\"unix\"`: Use Unix socket for communication.\n    - `\"tcp\"`: Use TCP/IP for communication (default if no transport is specified).\n  - **`port`** (`number`): The port number on which the server should listen (required for `\"tcp\"`).\n  - **`path`** (`string`): The file path to the Unix socket (required for `\"unix\"` transport).\n  - **`tls`** (`Deno.TlsCertifiedKeyPem`): Optional configuration for enabling TLS encryption. If provided, the server will run over HTTPS:\n    - **`cert`** (`string`): Path to the TLS certificate file.\n    - **`key`** (`string`): Path to the private key file.\n\n##### **Returns**\n\nAn object with a `listen` method for starting the server.\n\n#### **`listen` Method**\n\n##### **Parameters**\n\n- **`port`** (`number | undefined`): The port on which to start the server (used for TCP transport only). It is ignored for Unix socket transport.\n- **`callback`** (`Function | undefined`): A callback function that will be executed when the server starts.\n\n##### **Description**\n\nThe `listen` method starts the server based on the provided configuration. It will:\n\n- Bind the server to a TCP/IP port or Unix socket.\n- Enable TLS encryption if TLS certificates are provided.\n- Use the TezX framework to process requests.\n- Log success messages to the console, including the server's transport protocol and address.\n\n##### **Error Handling**\n\n- **`Error: Deno is not found`**: Thrown if the Deno environment is not detected.\n- **Other Errors**: Any issues encountered during server setup will throw a relevant error message (e.g., invalid transport configuration, missing TLS files, etc.).\n\n---\n\n### **Detailed Flow**\n\n1. **Server Configuration**:\n\n   - Based on the provided `options`, the `denoAdapter` function will set up a server that listens either on a TCP/IP port or a Unix socket.\n   - If no `tls` option is provided, the server runs over HTTP (TCP), otherwise, it will run over HTTPS (TCP with TLS certificates).\n\n2. **Request Handling**:\n\n   - The server listens for incoming requests. The `handleRequest` function is called for each request.\n   - The `handleRequest` function processes each request and prepares a response using TezX. It constructs a response that includes headers, status code, and body.\n\n3. **Logging and Debugging**:\n\n   - Upon server startup, a success message is logged to the console, indicating the protocol (HTTP or HTTPS) and the server's address/port or Unix socket path.\n   - This message is color-coded to make it easy to spot in the logs.\n\n4. **Error Handling**:\n   - If the server encounters issues, such as missing configuration or invalid transport type, appropriate error messages are thrown.\n   - The `Deno is not found` error ensures the server can only run in the Deno runtime environment.\n\n---\n\n### **Additional Notes**\n\n- **Security Considerations**:\n\n  - If using TLS, ensure that the certificate (`cert`) and key (`key`) files are secured and not exposed to the public.\n  - The `cert` and `key` files should be stored in a secure directory with limited access permissions.\n\n- **Debugging**:\n\n  - The logging message is colorful and easy to distinguish, providing quick insights into the server‚Äôs state.\n  - For development purposes, the log also shows the address and port of the server.\n\n- **Scalability**:\n\n  - This setup is ideal for small to medium-sized projects, and can be easily scaled by adjusting the server settings or adding additional features.\n\n- **Unix Socket**:\n  - Unix sockets are useful for communication between processes on the same machine. This method is typically faster than TCP for local communication.\n\n---\n\n### **Example: Running a Production-Ready Secure Server**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\nconst app = new TezX();\n\n// Production TLS options\nconst serverOptions = {\n  transport: \"tcp\",\n  port: 443, // HTTPS\n  tls: {\n    cert: \"/etc/ssl/certs/tezx-cert.pem\", // Path to certificate\n    key: \"/etc/ssl/private/tezx-key.pem\", // Path to private key\n  },\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the secure server\nadapter.listen(443, () => {\n  console.log(\"Secure TezX server running on HTTPS port 443\");\n});\n```\n\n---\n"
            },
            {
              "originalPath": "2. Deno Configure.md",
              "id": 8,
              "name": "Deno Configure",
              "type": "file",
              "path": "adapter/deno/deno-configure",
              "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```ts\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```ts\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```ts\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
            }
          ]
        },
        {
          "originalPath": "node",
          "name": "Node",
          "path": "adapter/node",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Node.md",
              "id": 9,
              "name": "Node",
              "type": "file",
              "path": "adapter/node/node",
              "content": "# üìÑ `nodeAdapter` ‚Äì Node.js Adapter for TezX\n\n### Overview\n\nThe `nodeAdapter` function bridges your `TezX` application to the native Node.js HTTP or HTTPS server, allowing you to serve requests via:\n\n- A **regular TCP port**\n- A **Unix domain socket**\n- Optionally, a **TLS-encrypted (HTTPS)** server\n\nIt provides flexibility for development and production environments, including support for WebSockets and streaming responses.\n\n---\n\n## ‚úÖ Function Signature\n\n```ts\nfunction nodeAdapter<T extends Record<string, any> = {}>(\n  TezX: TezX<T>,\n  options?: TezXServerOptions,\n): {\n  listen(port?: number, callback?: (msg: string) => void): void;\n};\n```\n\n---\n\n## üîß Parameters\n\n### 1. `TezX`\n\n- Type: `TezX<T>`\n- Description: Your TezX application instance that handles HTTP and WebSocket requests.\n\n### 2. `options` (optional)\n\n- Type: `TezXServerOptions` (see below)\n- Description: Configuration options for the Node.js HTTP/HTTPS server.\n\n#### Type: `TezXServerOptions`\n\n```ts\ntype UnixSocketOptions = ServerOptions & {\n  unix?: string;\n  enableSSL?: false;\n};\n\ntype SSLOptions = ServerOptions &\n  TlsOptions & {\n    enableSSL: true;\n  };\n\ntype TezXServerOptions = UnixSocketOptions | SSLOptions;\n```\n\n#### Common `ServerOptions` and `TlsOptions` include\n\n- `cert`: path to TLS certificate (required for HTTPS)\n- `key`: path to TLS private key (required for HTTPS)\n- `requestTimeout`, `keepAlive`, `noDelay`: optional server settings\n\n---\n\n## ‚ñ∂Ô∏è `listen()` Method\n\n### Parameters\n\n- `port` _(optional)_: `number` ‚Äì Port to bind the server (ignored if `unix` is specified).\n- `callback` _(optional)_: `(msg: string) => void` ‚Äì Function called when the server starts.\n\n### Returns\n\n- Starts the server and logs a formatted message to the console. Stores the server instance in `GlobalConfig.server`.\n\n---\n\n## üí° Features\n\n| Feature           | Description                                                                |\n| ----------------- | -------------------------------------------------------------------------- |\n| üîÅ Dual Transport | Supports TCP (`port`) or Unix socket (`unix`)                              |\n| üîê TLS Support    | Enables HTTPS with `cert` and `key` options                                |\n| üß† WebSockets     | Automatically upgrades WS requests if supported by the TezX response       |\n| üì¶ Streaming      | Pipes `Readable` streams from `Response.body` to the client                |\n| ‚ö†Ô∏è Error Handling | Throws clear errors for misconfigurations and unsupported environments     |\n| üñ•Ô∏è Color Logs     | Displays a colorful message when the server starts (protocol + URL/socket) |\n\n---\n\n## üß™ Example Usages\n\n### ‚úÖ Basic HTTP Server\n\n```ts\nconst adapter = nodeAdapter(app);\nadapter.listen(3000, (msg) => {\n  console.log(msg);\n});\n```\n\n### üîí HTTPS Server\n\n```ts\nconst adapter = nodeAdapter(app, {\n  enableSSL: true,\n  key: fs.readFileSync(\"certs/key.pem\"),\n  cert: fs.readFileSync(\"certs/cert.pem\"),\n});\nadapter.listen(443, (msg) => {\n  console.log(msg);\n});\n```\n\n### üõ†Ô∏è Unix Socket Server\n\n```ts\nconst adapter = nodeAdapter(app, {\n  unix: \"/tmp/tezx.sock\",\n});\nadapter.listen(() => {\n  console.log(\"Server running on /tmp/tezx.sock\");\n});\n```\n\n---\n\n## üîÅ WebSocket Handling (via TezX)\n\nHandlers supported: `open`, `message`, `close`, `ping`, `pong`, `drain`.\n\n**See websocket documentation**\n\n---\n\n## üìù Notes\n\n- You must use `enableSSL: true` to enable `https`. Without this, it defaults to HTTP.\n- If using Unix sockets, `port` will be ignored.\n- `listen()` uses dynamic `import(\"node:http\")` or `import(\"node:https\")` to load only the necessary module.\n- `TezX.serve()` must return either a `Response` or a compatible object with `.websocket()` and `.ctx`.\n\n---\n\n## üßØ Error Handling\n\n- If `TezX.serve()` does **not** return a valid `Response`, it throws:\n\n```bash\n  Error: Invalid response from TezX.serve\n```\n\n- If `import(\"node:http\")` or `import(\"node:https\")` fails, the error is caught and logged.\n\n---\n\n## ‚úÖ Output Example\n\nWhen the server starts successfully, you'll see:\n\n```bash\nNodeJS TezX Server running at http://localhost:3000/\n```\n\nOr for HTTPS:\n\n```bash\nNodeJS TezX Server running at https://localhost:443/\n```\n\nOr for Unix socket:\n\n```bash\nNodeJS TezX Server running at unix:///tmp/tezx.sock\n```\n\n---\n"
            },
            {
              "originalPath": "2. Node Configure.md",
              "id": 10,
              "name": "Node Configure",
              "type": "file",
              "path": "adapter/node/node-configure",
              "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx;\nnpm install @types/node;\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX } = require(\"tezx\");\nconst { logger } = require(\"tezx/middleware\");\nconst { nodeAdapter, loadEnv } = require(\"tezx/node\");\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true,\n    \"removeComments\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\",\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "5. API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Middleware API",
          "name": "Middleware API",
          "path": "api/0-middleware-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Merging Middlewares.md",
              "id": 11,
              "name": "Merging Middlewares",
              "type": "file",
              "path": "api/middleware-api/merging-middlewares",
              "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```ts\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n```ts\nconst app = new TezX({ allowDuplicateMw: false });\n```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n```ts\napp.use(\"/test\", (ctx, next) => {\n  logger().info(\"Middleware m1\");\n  return next();\n});\n```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 12,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware-api/middleware",
              "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```ts\nexport type Middleware<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => Promise<Response | void> | Response | NextCallback;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` or `await next()` (to continue), a `Response`, or a `Promise<Response>`.\n\n#### **Example**\n\n```ts\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  await next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n**Must be use return**\n\n```ts\nexport type CallbackReturn = Promise<Response> | Response;\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => CallbackReturn;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `Response` or `Promise<Response>`.\n\n#### **Example**\n\n```ts\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```ts\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.req.headers.get(\"Authorization\"));\n    await next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```ts\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```ts\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```ts\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```ts\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```ts\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```ts\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```ts\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n    await next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```ts\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  await next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```ts\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```ts\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n```ts\nserver\n  .use(syncOperation) // Fast sync task\n  .use(asyncMiddleware); // Slower async task\n```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n```ts\n// ‚ùå Avoid\napp.use(async (ctx, next) => {\n  await processLargeFile();\n  return next();\n});\n\n// ‚úÖ Prefer\napp.get(\"/process\", (ctx) => processLargeFile());\n```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n```ts\napp.use((ctx, next) => {\n  ctx.cachedData = expensiveOperation();\n  return next();\n});\n\napp.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `Response`.               |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "1. Router",
          "name": "Router",
          "path": "api/1-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Router Merging.md",
              "id": 13,
              "name": "Router Merging",
              "type": "file",
              "path": "api/router/router-merging",
              "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```ts\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```ts\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n```ts\napp.get(\"/test\", (ctx) => {\n  logger().info(\"Original /test handler\");\n  return ctx.text(\"Handler 1\");\n});\n```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n```ts\nconsole.log(app.routes); // Inspect route tree (if exposed)\n```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
            },
            {
              "originalPath": "2. Router API.md",
              "id": 14,
              "name": "Router API",
              "type": "file",
              "path": "api/router/router-api",
              "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```bash\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```ts\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```ts\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```ts\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```ts\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```ts\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```ts\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```ts\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
            },
            {
              "originalPath": "3. Route Parameter.md",
              "id": 15,
              "name": "Route Parameter",
              "type": "file",
              "path": "api/router/route-parameter",
              "content": "# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```ts\n\"/path/:parameterName\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```ts\n\"/path/:optionalParam?\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```ts\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```ts\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```ts\napp.get(\"/users/id/:id\", handleUser); // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```ts\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```ts\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n```ts\napp.get(\"/api/static\", handleStatic);\napp.get(\"/api/:id\", handleDynamic);\n```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n```ts\nconst id = parseInt(ctx.req.params.id);\nif (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n```\n\n3. **Limit Optional Parameters**\n\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n```ts\n// Matches /api/v1/2023/users or /api/v1/users\napp.get(\"/api/v1/:version?/:resource\", handleApi);\n```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n```ts\napp.get(\"/files/images/:id\", handleImage);\napp.get(\"/files/*path\", handleFile);\n```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```ts\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n| -------- | -------------------- | ---------------------------------- |\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```ts\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method, // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```ts\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods     | Custom Examples  |\n| -------------------- | ---------------- |\n| `GET`, `POST`, `PUT` | `PURGE`, `LOCK`  |\n| `PATCH`, `DELETE`    | `COPY`, `SEARCH` |\n| `HEAD`, `OPTIONS`    | `CUSTOM_API`     |\n\n### **Examples**\n\n#### **Custom Method**\n\n```ts\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```ts\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```ts\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```ts\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"]; // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method               | Path           | Priority | Match Example      |\n| -------------------- | -------------- | -------- | ------------------ |\n| `get()`              | `/cache/clear` | Highest  | `GET /cache/clear` |\n| `addMethod(\"PURGE\")` | `/cache`       | High     | `PURGE /cache`     |\n| `all()`              | `/cache/*`     | Medium   | `POST /cache/123`  |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n```ts\napp.get(\"/api\", specificHandler); // Higher priority\napp.all(\"/*api\", globalMiddleware); // Lower priority\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Context API.md",
              "id": 16,
              "name": "Context API",
              "type": "file",
              "path": "api/context/context-api",
              "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```ts\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```ts\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```ts\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```ts\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```ts\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```ts\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```ts\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```ts\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```ts\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
            },
            {
              "originalPath": "2. Advanced Context.md",
              "id": 17,
              "name": "Advanced Context",
              "type": "file",
              "path": "api/context/advanced-context",
              "content": "# **Advanced Context**\n\n### üîß `ctx.body` ‚Äì Passing Data Between Middlewares and Fallback Response\n\n#### Overview\n\n`ctx.body` is a powerful mechanism used to **pass data between middlewares** or to define a **fallback response** when no explicit `Response` is returned. It simplifies middleware handling and automatically wraps the body into a `Response` if no response is explicitly provided.\n\n---\n\n### üß† Core Concept of `ctx.body`\n\n1. **Middleware-to-Middleware Communication**  \n   `ctx.body` serves as a shared state, passing data between multiple middleware functions. You can set data in one middleware and access it in the next.\n\n2. **Automatic Fallback Response**  \n   If no explicit `Response` is returned from a route handler or middleware, the framework automatically checks `ctx.body`. If `ctx.body` contains data, it is automatically wrapped into a `Response` and returned.\n\n---\n\n### üß™ How It Works\n\n- **Setting `ctx.body`:**  \n  When you set `ctx.body` in any middleware or route handler, the framework will automatically handle the response if nothing else is returned.\n\n- **Return Behavior:**  \n  If no `Response` is explicitly returned, `ctx.body` will be wrapped in an appropriate `Response` object:\n  - If `ctx.body` is a string, it will be treated as `text/plain`.\n  - If `ctx.body` is an object, it will be treated as `application/json`.\n  - If `ctx.body` is `undefined`, it will result in an error.\n\n---\n\n### üìÑ API\n\n#### Setter\n\n```ts\nset body(value: any)\n```\n\n- Stores any value in the context body.\n- Overwrites previous value if set again.\n\n#### Getter\n\n```ts\nget body(): any\n```\n\n- Retrieves the current value of the context body.\n\n---\n\n### ‚öôÔ∏è How It Works Internally\n\n```ts\nif (!response) {\n  if (ctx.body) {\n    return ctx.send(ctx.body); // auto-wraps body into a Response\n  } else {\n    throw new Error(\"No response or body set\");\n  }\n}\n```\n\n---\n\n### üìÑ Example Code for `ctx.body`\n\n#### Basic Example\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  // No need to return a Response here; it will be inferred.\n  return (ctx.body = \"Hello, world!\" as any);\n});\n```\n\nIn this example:\n\n- `ctx.body = \"Hello, world!\"` sets the response body.\n- The framework will automatically return a `Response` with `text/plain` as the content type.\n\n#### Example with JSON Response\n\n```ts\napp.get(\"/status\", (ctx) => {\n  // It will be automatically returned as JSON\n  return (ctx.body = { success: true, version: \"1.0.0\" } as any);\n});\n```\n\nHere:\n\n- `ctx.body` is set to an object. It will be automatically returned as `application/json`.\n\n#### Middleware Example\n\n```ts\napp.use(async (ctx, next) => {\n  // Set data in ctx.body\n  ctx.body = { user: await getUserData(ctx) };\n  return next(); // Pass to next middleware or final handler\n});\n\napp.use(async (ctx) => {\n  // Modify ctx.body in another middleware\n  ctx.body.token = await generateToken(ctx.body.user);\n  return ctx.body as any; // Directly return ctx.body\n});\n```\n\nIn this example:\n\n- The `ctx.body` is shared between two middleware functions. The first sets user data, and the second adds a token before returning the response.\n\n**Response**:\n\n```json\n{ \"user\": 6563, \"token\": 3545 }\n```\n\n#### Handling with `next()`\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.body = { status: \"Processing\" };\n  return await next(); // Move to next middleware and always return keyword use\n});\n\napp.get(\"/complete\", (ctx) => {\n  ctx.body = { status: \"Complete\", result: \"Success\" };\n  return ctx.body as any; // Send final response\n});\n```\n\nHere:\n\n- `ctx.body` is modified by each middleware, and the final response is sent at the end of the chain.\n\n---\n\n### üßØ Best Practices for Using `ctx.body`\n\n1. **Always return `next()` in middleware when you are not finishing the request.**\n\n   - If you don‚Äôt explicitly return a `Response`, use `return next()` to let the next middleware or handler process the request.\n\n2. **Ensure `ctx.body` is properly set if you're relying on it for a fallback response.**\n\n   - If no `Response` is returned and `ctx.body` is empty or undefined, the request will fail.\n\n3. **Use `ctx.body` for response construction but avoid relying on it for complex responses like file downloads or streaming.**\n   - For advanced responses like file streaming or complex headers, it's better to manually handle the response rather than rely on `ctx.body`.\n\n---\n\n### ‚öôÔ∏è Advanced Example with Error Handling\n\n```ts\napp.use(async (ctx, next) => {\n  try {\n    ctx.body = await someAsyncOperation();\n    return await next(); // Pass to next middleware\n  } catch (error) {\n    ctx.status = 500; // Set error status code\n    return (ctx.body = { error: \"Something went wrong\" } as any);\n  }\n});\n\napp.get(\"/data\", (ctx) => {\n  // If an error occurred in previous middleware, it will automatically return the error response\n  return ctx.body as any;\n});\n```\n\nIn this case:\n\n- If an error happens in `someAsyncOperation()`, it sets `ctx.body` to an error message, and the error response is automatically returned.\n\n---\n\n### üß† Summary\n\n| Feature                              | Supported          |\n| ------------------------------------ | ------------------ |\n| Acts as a shared state               | ‚úÖ                 |\n| Automatic fallback response          | ‚úÖ                 |\n| Works with strings, objects, streams | ‚úÖ (if supported)  |\n| Replaces `return Response`           | ‚úÖ in simple cases |\n\n---\n"
            },
            {
              "originalPath": "3. State.md",
              "id": 18,
              "name": "State",
              "type": "file",
              "path": "api/context/state",
              "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```ts\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```ts\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```ts\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```ts\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```ts\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```ts\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n```ts\nctx.state.set(\"auth:user\", authenticatedUser);\n```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n```ts\nctx.state.delete(\"temporaryData\");\n```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n```ts\ninterface AppState {\n  user?: { id: number; name: string };\n  requestId?: string;\n}\n\nctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.state.set(\"startTime\", Date.now());\n  await next();\n});\n\napp.get(\"/test\", (ctx) => {\n  const elapsed = Date.now() - ctx.state.get(\"startTime\");\n  return ctx.json({ elapsed });\n});\n```\n\n---\n"
            },
            {
              "originalPath": "4. Context Propagation.md",
              "id": 19,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```ts\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```ts\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```ts\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```ts\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
            },
            {
              "originalPath": "5. Cookies.md",
              "id": 20,
              "name": "Cookies",
              "type": "file",
              "path": "api/context/cookies",
              "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```ts\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n```ts\nconst session = ctx.cookies.get(\"sessionToken\");\nif (!session) return ctx.status(401).json({ error: \"No session\" });\n```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n```ts\nctx.cookies.set(\"key\", \"value\");\nlogger().info(\"Cookie set: key\");\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Request",
          "name": "Request",
          "path": "api/3-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 21,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```ts\ninterface UrlRef {\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```ts\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```ts\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```ts\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```ts\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```ts\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
            },
            {
              "originalPath": "2. Body Parser.md",
              "id": 22,
              "name": "Body Parser",
              "type": "file",
              "path": "api/request/body-parser",
              "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```ts\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```ts\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```ts\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```ts\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n```ts\nconst stream = file.stream();\nconst transformer = new TransformStream();\n// Process stream\n```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n```ts\nconst form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n```ts\nctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```ts\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```ts\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Response",
          "name": "Response",
          "path": "api/4-response",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Response.md",
              "id": 23,
              "name": "Response",
              "type": "file",
              "path": "api/response/response",
              "content": "# **Response**\n\n---\n\n### **Type Definitions**\n\n```typescript\nexport type NextCallback = () => Promise<any>;\n\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => Promise<Response> | Response;\n```\n\n- **`NextCallback`**: A function returning a `Promise` for middleware chaining.\n- **`Callback<T>`**: A handler function that can return:\n  - `Promise<Response>`: Asynchronous response or no response.\n  - `Response`: A native HTTP response object.\n\n---\n\n## **Custom Response**\n\nFor fine-grained control, return a native `Response` object directly:\n\n```typescript\napp.get(\"/data\", async (ctx: ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## **Response Methods**\n\n### **`json`**\n\n#### **Description**\n\nSerializes and sends a JSON response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  return ctx.json({ message: \"Success\" }, 200);\n});\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  return ctx.html(\"<h1>Hello</h1>\", 200);\n});\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  return ctx.text(\"Hello, World!\", 200);\n});\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  return ctx.xml(\"<note><msg>Hello</msg></note>\", 200);\n});\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type inference.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (e.g., `string`, `object`).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with inferred `Content-Type`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  return ctx.send(\"Custom Content\", 200);\n});\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Location` header.\n\n#### **Usage**\n\n```typescript\napp.get(\"/redirect\", (ctx: ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nTriggers a file download.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name for the downloaded file.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/download\", async (ctx: ctx) => {\n  return ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n});\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream.\n\n#### **Usage**\n\n```typescript\napp.get(\"/file\", async (ctx: ctx) => {\n  return ctx.sendFile(\"/path/to/image.jpg\");\n});\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "5. Headers API",
          "name": "Headers API",
          "path": "api/5-headers-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "1.Request Headers.md",
              "id": 24,
              "name": "Request Headers",
              "type": "file",
              "path": "api/headers-api/request-headers",
              "content": "\n# `ctx.req.headers` API\n\n## Overview\n\n`ctx.req.headers` provides a **read-only**, case-insensitive, iterable interface for inspecting HTTP request headers in a structured and consistent way.\n\nThis API is designed to:\n\n* Safely access request headers\n* Normalize case handling\n* Support iteration\n* Enable easy debugging via `.toJSON()`\n\n---\n\n## Interface\n\n```ts\nctx.req.headers: {\n  get(key: string): string | null;\n  has(key: string): boolean;\n  entries(): HeadersIterator<[string, string]>;\n  keys(): HeadersIterator<string>;\n  values(): HeadersIterator<string>;\n  forEach(callbackfn: (value: string, key: string, parent: Headers) => void): void;\n  toJSON(): Record<string, string>;\n}\n```\n\n---\n\n## Methods\n\n### ‚ñ∏ `get(key: string): string | null`\n\nRetrieves the first value for a given header.\n\n* **Params:** `key` ‚Äî Header name (case-insensitive)\n* **Returns:** The first header value, or `null` if not found\n\n```ts\nconst type = ctx.req.headers.get(\"content-type\");\n// \"application/json\"\n```\n\n---\n\n### ‚ñ∏ `has(key: string): boolean`\n\nChecks whether a header exists in the request.\n\n* **Params:** `key` ‚Äî Header name (case-insensitive)\n* **Returns:** `true` if the header is present, `false` otherwise\n\n```ts\nif (ctx.req.headers.has(\"authorization\")) {\n  console.log(\"Auth header found.\");\n}\n```\n\n---\n\n### ‚ñ∏ `entries(): HeadersIterator<[string, string]>`\n\nIterates over `[key, value]` pairs for each header.\n\n* **Returns:** An iterator of header entries\n\n```ts\nfor (const [key, value] of ctx.req.headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n```\n\n---\n\n### ‚ñ∏ `keys(): HeadersIterator<string>`\n\nIterates over all header names.\n\n* **Returns:** An iterator of header names\n\n```ts\nfor (const key of ctx.req.headers.keys()) {\n  console.log(`Header name: ${key}`);\n}\n```\n\n---\n\n### ‚ñ∏ `values(): HeadersIterator<string>`\n\nIterates over all header values.\n\n* **Returns:** An iterator of string values\n\n```ts\nfor (const value of ctx.req.headers.values()) {\n  console.log(`Value: ${value}`);\n}\n```\n\n---\n\n### ‚ñ∏ `forEach(callback: (value, key, parent) => void): void`\n\nRuns a callback for each header.\n\n* **Params:**\n\n  * `callbackfn` ‚Äî Function that receives:\n\n    * `value`: string\n    * `key`: string\n    * `parent`: Headers\n\n```ts\nctx.req.headers.forEach((value, key) => {\n  console.log(`${key}: ${value}`);\n});\n```\n\n---\n\n### ‚ñ∏ `toJSON(): Record<string, string>`\n\nConverts headers to a plain object with values joined (if multiple).\n\n* **Returns:** An object representation of headers.\n\n```ts\nconsole.log(ctx.req.headers.toJSON());\n// { \"accept\": \"text/html,application/json\", \"user-agent\": \"Mozilla/...\" }\n```\n\n---\n\n## Characteristics\n\n| Feature          | Description                    |\n| ---------------- | ------------------------------ |\n| Immutable        | Read-only access               |\n| Case-insensitive | Keys normalized to lowercase   |\n| Iterable         | Supports entries, keys, values |\n| JSON-ready       | `toJSON()` for debugging/logs  |\n\n---\n\n## Example Use Cases\n\n### üîê Authorization Guard\n\n```ts\napp.use((ctx) => {\n  if (!ctx.req.headers.has(\"authorization\")) {\n    return ctx.text(\"Unauthorized\", 401);\n  }\n});\n```\n\n### üìã Logging Incoming Headers\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"Headers:\", ctx.req.headers.toJSON());\n  return next();\n});\n```\n\n---\n"
            },
            {
              "originalPath": "1.Response Headers.md",
              "id": 25,
              "name": "Response Headers",
              "type": "file",
              "path": "api/headers-api/response-headers",
              "content": "# Response Headers\n\n## Overview\n\n`ctx.headers` is a `Headers` object, which is the standard Web API interface for HTTP headers. It allows manipulation of HTTP response headers with a familiar API similar to what browsers and Node.js provide.\n\n## Key Methods on the Built-in `Headers` Object\n\n### 1. `append(name: string, value: string): void`\n\nAdd a new value to an existing header or create it if missing.\n\n```typescript\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n```\n\n---\n\n### 2. `set(name: string, value: string): void`\n\nSet or overwrite a header value.\n\n```typescript\nheaders.set(\"Content-Type\", \"text/html\");\n```\n\n**NB: `ctx.header` use function**\n\n---\n\n### 3. `get(name: string): string | null`\n\nGet the **first** value of a header (returns `null` if missing).\n\n```typescript\nconst contentType = headers.get(\"content-type\"); // e.g. \"text/html\" or null\n```\n\n---\n\n### 4. `has(name: string): boolean`\n\nCheck if a header exists.\n\n```typescript\nconst hasCacheControl = headers.has(\"cache-control\"); // true or false\n```\n\n---\n\n### 5. `delete(name: string): void`\n\nRemove a header.\n\n```typescript\nheaders.delete(\"x-powered-by\");\n```\n\n---\n\n### 6. Iteration\n\nHeaders are iterable with:\n\n* `headers.entries()` ‚Üí iterator of `[name, value]` pairs\n* `headers.keys()` ‚Üí iterator of header names\n* `headers.values()` ‚Üí iterator of header values\n\nExample:\n\n```typescript\nfor (const [name, value] of headers.entries()) {\n  console.log(`${name}: ${value}`);\n}\n```\n\n---\n\n## Example: Using `ctx.headers` as a `Headers` object\n\n```typescript\n// Example: Context interface with headers as built-in Headers object\ninterface Context {\n  headers: Headers;  // response headers to send back to client\n}\n\n// Initialize context with empty Headers\nconst ctx: Context = {\n  headers: new Headers(),\n};\n\n// --- Setting headers ---\nctx.headers.set(\"Content-Type\", \"application/json\");\nctx.headers.set(\"Cache-Control\", \"no-cache\");\n\n// --- Appending headers ---\nctx.headers.append(\"Vary\", \"Accept-Encoding\");\nctx.headers.append(\"Vary\", \"User-Agent\");\n\n// --- Checking if header exists ---\nif (ctx.headers.has(\"X-Powered-By\")) {\n  console.log(\"X-Powered-By header is set\");\n} else {\n  console.log(\"X-Powered-By header not set, setting now\");\n  ctx.headers.set(\"X-Powered-By\", \"MyServer\");\n}\n\n// --- Reading headers ---\nconst contentType = ctx.headers.get(\"content-type\");\nconsole.log(\"Content-Type:\", contentType); // application/json\n\nconst varyHeader = ctx.headers.get(\"vary\");\nconsole.log(\"Vary:\", varyHeader); // Accept-Encoding, User-Agent\n\n// --- Deleting headers ---\nctx.headers.delete(\"X-Powered-By\");\n\n// --- Iterating headers ---\nconsole.log(\"All headers:\");\nfor (const [key, value] of ctx.headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n\n// --- Output final headers as plain object ---\nfunction headersToObject(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n  for (const [key, value] of headers.entries()) {\n    result[key] = value;\n  }\n  return result;\n}\n\nconsole.log(\"Headers as object:\", headersToObject(ctx.headers));\n```\n\n---\n\n### Explanation\n\n* **`ctx.headers`** is a native `Headers` object.\n* You **set** headers with `.set(key, value)` which overwrites existing values.\n* Use `.append(key, value)` to add multiple values for headers like `Vary`.\n* `.get(key)` fetches the first value of the header (comma-separated if multiple).\n* `.has(key)` checks existence.\n* `.delete(key)` removes the header.\n* You can iterate with `.entries()` over `[key, value]` pairs.\n* The `headersToObject()` helper converts the headers into a plain JS object for logging or other uses.\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "6. Websocket.md",
      "id": 26,
      "name": "Websocket",
      "type": "file",
      "path": "websocket",
      "content": "# WebSocket Server\n\nThis document provides detailed information about implementing and using a WebSocket server with the `upgradeWebSocket` middleware from the `tezx/ws` module. The middleware enables WebSocket upgrades for HTTP servers across different JavaScript runtimes (Deno, Node.js, and Bun) with customizable event handlers and configuration options.\n\n## Overview\n\nThe `upgradeWebSocket` middleware facilitates WebSocket connections by upgrading HTTP requests to WebSocket protocol. It supports runtime-specific configurations for Deno, Node.js, and Bun, allowing developers to handle WebSocket events such as `open`, `message`, `close`, and more. The middleware integrates with the `tezx` framework, leveraging its `Context` object for request handling and environment detection for runtime-specific behavior.\n\nThe provided code snippet demonstrates a basic WebSocket server that:\n\n- Upgrades HTTP requests to WebSocket connections.\n- Handles WebSocket events (`open`, `message`, `close`).\n- Serves an `index.html` file for non-WebSocket requests.\n- Supports a simple ping-pong mechanism and message echoing.\n\n---\n\n## Key Components\n\n### WebSocket Event Handlers\n\nThe `WebSocketEvent` type defines the supported WebSocket event handlers, which are invoked during the WebSocket lifecycle:\n\n```typescript\nexport type WebSocketEvent = {\n  open?: WebSocketHandler; // Triggered when the connection is opened\n  message?: WebSocketHandler<string | Buffer | ArrayBuffer>; // Triggered on incoming messages\n  close?: WebSocketHandler<{ code: number; reason: string }>; // Triggered when the connection is closed\n  error?: WebSocketHandler<Error | any>; // Triggered on errors (not supported in Bun)\n  drain?: WebSocketHandler; // Triggered on socket drain (not supported in Deno/Node)\n  ping?: WebSocketHandler<Buffer>; // Triggered on ping frames (not supported in Deno)\n  pong?: WebSocketHandler<Buffer>; // Triggered on pong frames (not supported in Deno)\n};\n```\n\nEach handler is a function that takes a `WebSocket` instance and optional data, returning `void` or `Promise<void>`.\n\n### WebSocket Callback\n\nThe `WebSocketCallback` type defines a function that returns the `WebSocketEvent` handlers based on the request context:\n\n```typescript\nexport type WebSocketCallback = (ctx: Context) => WebSocketEvent;\n```\n\nThis allows dynamic configuration of WebSocket behavior based on the incoming request.\n\n### WebSocket Options\n\nThe `WebSocketOptions` interface provides configuration options for the WebSocket connection, with runtime-specific properties:\n\n```typescript\nexport type WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => CallbackReturn; // Custom error handler\n  protocol: string; // ‚úÖ Deno: Supported subprotocols\n  idleTimeout?: number; // ‚úÖ Deno: Idle timeout in seconds\n  perMessageDeflate?: boolean | PerMessageDeflateOptions; // ‚úÖ Node.js: Compression settings\n  maxPayload?: number; // ‚úÖ Node.js: Maximum message size in bytes\n};\n```\n\n### For **Nodejs**\n\nFor **Node.js**, here's how you can implement WebSocket upgrades using the `ws` library.\n\n<https://www.npmjs.com/package/ws>\n\nFirst, install the `ws` library:\n\n```bash\nnpm install ws\n```\n\n### Per-Message Deflate Options\n\nThe `PerMessageDeflateOptions` interface (**‚úÖ Node.js** only) configures compression for WebSocket messages:\n\n```typescript\ninterface PerMessageDeflateOptions {\n  serverNoContextTakeover?: boolean; // Disable server context takeover\n  clientNoContextTakeover?: boolean; // Disable client context takeover\n  serverMaxWindowBits?: number; // Server window size\n  clientMaxWindowBits?: number; // Client window size\n  zlibDeflateOptions?: ZlibOptions; // Zlib compression options\n  zlibInflateOptions?: ZlibInflateOptions; // Zlib decompression options\n  threshold?: number; // Minimum message size for compression\n  concurrencyLimit?: number; // Limit concurrent zlib operations\n}\n```\n\n### Zlib Options\n\nThe `ZlibOptions` interface (**‚úÖ Node.js** only) configures compression/decompression behavior:\n\n```typescript\ninterface ZlibOptions {\n  flush?: number; // Default flush flag\n  finishFlush?: number; // Flush flag for end()\n  chunkSize?: number; // Compression chunk size\n  windowBits?: number; // Window size (8‚Äì15)\n  level?: number; // Compression level (0‚Äì9)\n  memLevel?: number; // Memory allocation (1‚Äì9)\n  strategy?: number; // Compression strategy\n  dictionary?: NodeJS.ArrayBufferView | ArrayBuffer; // Compression dictionary\n  info?: boolean; // Return buffer and engine info\n}\n```\n\n---\n\n## Middleware: `upgradeWebSocket`\n\nThe `upgradeWebSocket` function is a middleware that handles WebSocket upgrades:\n\n```typescript\nexport function upgradeWebSocket(\n  callback: WebSocketCallback,\n  options: WebSocketOptions = {},\n): Middleware;\n```\n\n### Parameters\n\n- `callback`: A `WebSocketCallback` function that returns the `WebSocketEvent` handlers.\n- `options`: Optional `WebSocketOptions` to configure the WebSocket behavior.\n\n### Behavior\n\n1. Validates WebSocket headers (`upgrade`, `connection`, `sec-websocket-key`).\n2. Detects the runtime environment (Deno, Node.js, Bun) using `EnvironmentDetector`.\n3. Delegates the upgrade process to the appropriate transport (`DenoTransport`, `NodeTransport`, or Bun).\n4. Invokes the `onUpgradeError` handler if the upgrade fails or headers are invalid.\n\n### Returns\n\nA `Middleware` function compatible with the `tezx` framework, which either upgrades the connection or passes control to the next handler.\n\n---\n\n## Example Implementation\n\nBelow is a complete example demonstrating the WebSocket server using the `upgradeWebSocket` middleware, including a client-side HTML file to interact with the server.\n\n### Complete Code Example\n\n#### `src/server.ts`\n\n```typescript\nimport { upgradeWebSocket } from \"tezx/ws\";\n\n// Mock server setup (replace with actual HTTP server for your runtime)\nconst socket: WebSocket[] = [];\n// WebSocket route\napp.get(\n  \"/\",\n  upgradeWebSocket(\n    (ctx: Context) => {\n      return {\n        // make sure it is work with nodejs\n        open: (ws: WebSocket) => {\n          socket.push(ws);\n          console.log(\"WebSocket connected\");\n          ws.send(\"üëã Welcome to TezX WebSocket!\");\n        },\n        message: (ws: WebSocket, msg: string | Buffer | ArrayBuffer) => {\n          if (typeof msg === \"string\" && msg === \"ping\") {\n            ws.send(\"pong üèì\");\n          } else {\n            ws.send(\"Echo: \" + msg);\n          }\n        },\n        close: (ws: WebSocket, data: { code: number; reason: string }) => {\n          console.log(`WebSocket closed: ${data?.reason}`);\n        },\n      };\n    },\n    {\n      maxPayload: 2 * 1024 * 1024, // 2MB\n      perMessageDeflate: {\n        threshold: 1024, // Compress messages > 1KB\n      },\n    },\n  ),\n  (ctx: Context) => {\n    return ctx.sendFile(\"index.html\");\n  },\n);\n```\n\n#### `index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>TezX WebSocket Demo</title>\n    <style>\n      * {\n        box-sizing: border-box;\n      }\n\n      body {\n        font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n        background: #f7f9fc;\n        padding: 30px;\n        color: #333;\n      }\n\n      h1 {\n        text-align: center;\n        color: #444;\n        margin-bottom: 30px;\n      }\n\n      .container {\n        max-width: 600px;\n        margin: 0 auto;\n        background: #fff;\n        border-radius: 10px;\n        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.05);\n        padding: 20px;\n      }\n\n      #messages {\n        border: 1px solid #ddd;\n        border-radius: 6px;\n        padding: 12px;\n        height: 250px;\n        overflow-y: auto;\n        background-color: #fafafa;\n        font-size: 14px;\n        margin-bottom: 15px;\n      }\n\n      #input {\n        width: 100%;\n        padding: 10px;\n        border: 1px solid #ccc;\n        border-radius: 6px;\n        font-size: 14px;\n        margin-bottom: 10px;\n      }\n\n      .buttons {\n        display: flex;\n        gap: 10px;\n        justify-content: flex-end;\n      }\n\n      button {\n        padding: 8px 16px;\n        font-size: 14px;\n        border: none;\n        border-radius: 6px;\n        cursor: pointer;\n        transition: all 0.2s ease;\n      }\n\n      button:hover {\n        opacity: 0.9;\n      }\n\n      button:active {\n        transform: scale(0.97);\n      }\n\n      .send-btn {\n        background-color: #4caf50;\n        color: white;\n      }\n\n      .ping-btn {\n        background-color: #2196f3;\n        color: white;\n      }\n\n      .message {\n        margin-bottom: 8px;\n        padding: 6px 10px;\n        border-radius: 4px;\n      }\n\n      .message.client {\n        background: #e8f5e9;\n        color: #2e7d32;\n      }\n\n      .message.server {\n        background: #e3f2fd;\n        color: #1565c0;\n      }\n\n      .message.system {\n        background: #fff3e0;\n        color: #ef6c00;\n        font-style: italic;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>TezX WebSocket Demo</h1>\n    <div class=\"container\">\n      <div id=\"messages\"></div>\n      <input id=\"input\" type=\"text\" placeholder=\"Type a message...\" />\n      <div class=\"buttons\">\n        <button class=\"send-btn\" onclick=\"sendMessage()\">Send</button>\n        <button class=\"ping-btn\" onclick=\"sendPing()\">Ping</button>\n      </div>\n    </div>\n\n    <script>\n      const ws = new WebSocket(`ws://${location.host}`);\n      const messages = document.getElementById(\"messages\");\n      const input = document.getElementById(\"input\");\n\n      ws.onopen = () => {\n        appendMessage(\"Connected to WebSocket server\", \"system\");\n      };\n\n      ws.onmessage = (event) => {\n        appendMessage(`Server: ${event.data}`, \"server\");\n      };\n\n      ws.onclose = () => {\n        appendMessage(\"Disconnected from WebSocket server\", \"system\");\n      };\n\n      ws.onerror = (error) => {\n        appendMessage(`Error: ${error}`, \"system\");\n      };\n\n      function appendMessage(message, type = \"client\") {\n        const div = document.createElement(\"div\");\n        div.textContent = message;\n        div.className = `message ${type}`;\n        messages.appendChild(div);\n        messages.scrollTop = messages.scrollHeight;\n      }\n\n      function sendMessage() {\n        const message = input.value;\n        if (message && ws.readyState === WebSocket.OPEN) {\n          ws.send(message);\n          appendMessage(`Client: ${message}`, \"client\");\n          input.value = \"\";\n        }\n      }\n\n      function sendPing() {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(\"ping\");\n          appendMessage(\"Client: ping\", \"client\");\n        }\n      }\n    </script>\n  </body>\n</html>\n```\n\n## Limitations and Considerations\n\n1. **Runtime-Specific Features**:\n\n   - Some events (`ping`, `pong`, `drain`) are not supported in Deno or Node.js.\n   - `perMessageDeflate` and `maxPayload` are Node.js-only.\n\n2. **Scalability**:\n\n   - Storing WebSocket instances in an array (`socket.push(ws)`) may lead to memory leaks. Use a proper connection management system in production.\n\n3. **Testing**:\n   - Test WebSocket behavior under different runtimes and edge cases (e.g., large payloads, connection drops).\n"
    },
    {
      "originalPath": "9. Static File.md",
      "id": 27,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```ts\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```ts\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  return ctx.text(\"Custom response overriding static file\");\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "originalPath": "96. Middlewares",
      "name": "Middlewares",
      "path": "middlewares",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. CORS Middleware.md",
          "id": 28,
          "name": "CORS Middleware",
          "type": "file",
          "path": "middlewares/cors-middleware",
          "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// ‚ùå Avoid in production\ncors({ origin: \"*\" });\n// ‚úÖ Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.req.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
        },
        {
          "originalPath": "10. i18nMiddleware.md",
          "id": 29,
          "name": "I18nMiddleware",
          "type": "file",
          "path": "middlewares/i18nmiddleware",
          "content": "# üåç `i18n`\n\n> Advanced internationalization (i18n) middleware for `tezx` with dynamic translation loading, fallback language chains, caching, and custom message formatting.\n\n---\n\n## üìÑ Usage\n\n### ‚úÖ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/middleware\";\n\napp.use(\n  i18n({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## üîß API: `i18n(options: I18nOptions): Middleware`\n\n### üß© Interface: `I18nOptions`\n\n| Option                   | Type                                                          | Default                           | Description                                   |\n| ------------------------ | ------------------------------------------------------------- | --------------------------------- | --------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations, expiresAt? }>` | **Required**                      | Function that dynamically loads translations. |\n| `defaultCacheDuration`   | `number`                                                      | `3600000` (1 hr)                  | Time (ms) before cache expires.               |\n| `isCacheValid`           | `(cached, language) => boolean`                               | `expiresAt > Date.now()`          | Custom logic to validate cached translations. |\n| `detectLanguage`         | `(ctx: Context) => string`                                    | Query > Cookie > Header > default | Custom language detection.                    |\n| `defaultLanguage`        | `string`                                                      | `'en'`                            | Fallback language if detection fails.         |\n| `fallbackChain`          | `string[]`                                                    | `[]`                              | Array of fallback languages in priority.      |\n| `translationFunctionKey` | `string`                                                      | `'t'`                             | Key name attached to `ctx` for translating.   |\n| `formatMessage`          | `(message: string, options?: Record<string, any>) => string`  | Basic `{{var}}` replace           | Message interpolation.                        |\n| `cacheTranslations`      | `boolean`                                                     | `true`                            | Enable/disable translation caching.           |\n\n---\n\n## üí¨ Translation Format\n\nYou can structure translations as nested objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## üß† Features Explained\n\n### 1. üåê Language Detection\n\nDefault flow:\n\n- Query Param: `?lang=fr`\n- Cookie: `lang=fr`\n- Header: `Accept-Language: fr`\n- Fallback: `'en'`\n\nYou can override this behavior:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n---\n\n### 2. üîÅ Fallback Chain\n\nSupport fallback chains like:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n---\n\n### 3. üß† Cache with Expiry\n\n```ts\ncacheTranslations: true,\ndefaultCacheDuration: 1000 * 60 * 60 // 1 hour\n```\n\nOr use expiration from backend:\n\n```ts\nloadTranslations: async (lang) => {\n  const result = await fetchFromAPI(lang);\n  return {\n    translations: result.data,\n    expiresAt: Date.now() + 60000, // 1 min\n  };\n};\n```\n\n---\n\n### 4. üß© Message Interpolation\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" });\n// Output: \"Welcome, Alice!\"\n```\n\nYou can customize it:\n\n```ts\nformatMessage: (msg, vars) => {\n  return msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n};\n```\n\n---\n\n### 5. üìö Nested Key Support\n\n```ts\n// JSON\n{\n  \"user\": {\n    \"profile\": {\n      \"greeting\": \"Hello, {{name}}\"\n    }\n  }\n}\n\n// Access\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## üß™ Advanced Example\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return {\n        translations: json.data,\n        expiresAt: json.expiresAt, // Optional\n      };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.req.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) => {\n      return msg.replace(\n        /\\{\\{(.*?)\\}\\}/g,\n        (_, key) => vars?.[key.trim()] ?? \"\",\n      );\n    },\n    cacheTranslations: true,\n    isCacheValid: (cached, lang) => {\n      return cached.expiresAt > Date.now();\n    },\n  }),\n);\n```\n\n---\n\n## üìå What `ctx` contains after middleware\n\n| Property            | Type                                      | Description             |\n| ------------------- | ----------------------------------------- | ----------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function    |\n| `ctx.language`      | `string`                                  | Selected language       |\n| `ctx.languageChain` | `string[]`                                | Language fallback chain |\n\n---\n\n## ‚ùó Error Handling\n\nIf no translations are found for any language in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## üì§ Exported Types\n\nYou can reuse types for strong typing in your app:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/middleware\";\n```\n\n---\n"
        },
        {
          "originalPath": "11. Lazy Load Modules.md",
          "id": 30,
          "name": "Lazy Load Modules",
          "type": "file",
          "path": "middlewares/lazy-load-modules",
          "content": "## `lazyLoadModules` Middleware\n\nThe `lazyLoadModules` middleware enables dynamic, lazy loading of modules in a `tezx` application based on route or query parameters. It supports caching, lifecycle hooks, and module validation to optimize performance and ensure reliability.\n\n### Overview\n\nThe `lazyLoadModules` middleware enables dynamic, lazy loading of modules in a `tezx/middleware` application based on runtime parameters (e.g., query, route, or custom logic). It supports caching, lifecycle hooks, module validation, and an optional `init` function for module-specific initialization. The `init` function is a critical feature, allowing modules to perform asynchronous setup, validate prerequisites, or short-circuit the request lifecycle. This document provides a unified explanation of the `init` function‚Äôs work procedure, its integration with the middleware, and a consolidated example that incorporates the diverse use cases from four demos.\n\n### Key Features\n\n- **Dynamic Module Loading**: Load modules on-demand via configurable loaders.\n- **Caching**: Cache modules with customizable TTL and storage (e.g., `Map`, Redis).\n- **Lifecycle Hooks**: Execute custom logic at stages like load, cache hit, or error.\n- **Module Validation**: Ensure modules meet structural or behavioral criteria.\n- **Initialization via `init`**: Perform asynchronous setup or early responses per module.\n- **Flexible Module Identification**: Support query parameters, route parameters, or custom logic.\n\nImport the middleware and related types:\n\n```typescript\nimport { lazyLoadModules } from \"tezx/middleware\";\n```\n\n### Type Definitions\n\n```typescript\nexport type LazyModuleLoader<T> = () => Promise<T>;\nexport interface CacheItem<T = any> {\n  module: T;\n  expiresAt: number;\n}\ninterface LazyLoadOptions<T> {\n  moduleKey?: (ctx: Context) => string;\n  getModuleLoader: (\n    ctx: Context,\n  ) => Promise<LazyModuleLoader<T> | null> | null | LazyModuleLoader<T>;\n  queryKeyModule?: string;\n  moduleContextKey?: string;\n  enableCache?: boolean;\n  cacheStorage?: {\n    get: (key: string) => CacheItem<T> | undefined;\n    set: (key: string, value: CacheItem<T>) => void;\n    delete: (key: string) => void;\n  };\n  cacheTTL?: number;\n  lifecycleHooks?: {\n    onLoad?: (moduleName: string, ctx: Context) => void;\n    onError?: (moduleName: string, error: Error, ctx: Context) => void;\n    onComplete?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheHit?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheSet?: (moduleName: string, module: T, ctx: Context) => void;\n  };\n  validateModule?: (module: T) => boolean;\n}\n```\n\n### Middleware Signature\n\n```typescript\nexport const lazyLoadModules = <T = any>(options: LazyLoadOptions<T>): Middleware;\n```\n\n---\n\n## Work Procedure of the `init` Function\n\n### Purpose\n\nThe `init` function is an optional, asynchronous method exported by a module to:\n\n- Perform setup tasks (e.g., initializing resources, fetching configurations).\n- Validate request-specific prerequisites (e.g., API keys, tokens).\n- Modify the `Context` object for downstream use.\n- Return early responses to short-circuit the middleware chain (e.g., errors, redirects).\n\n### Code Context\n\nThe `init` function is invoked in the middleware as follows:\n\n```typescript\nif (module.init && typeof module.init === \"function\") {\n  const initResult = await module.init(ctx);\n  if (initResult) {\n    return initResult;\n  }\n}\n```\n\n### Operational Workflow\n\nThe `init` function is processed within the middleware pipeline as follows:\n\n1. **Module Identification**:\n\n   - The middleware determines the module name using `moduleKey`, `queryKeyModule`, or route parameters.\n   - Example: `ctx.req.query.module` (Demo 1, 3), `ctx.req.params.module` (Demo 2), or `ctx.req.body.moduleName` (Demo 4).\n\n2. **Module Loading**:\n\n   - The `getModuleLoader` function returns a `LazyModuleLoader`, which dynamically imports the module.\n   - The loaded module is validated using `validateModule` (if provided).\n\n3. **init Function Detection**:\n\n   - The middleware checks if the module exports an `init` function (`module.init && typeof module.init === \"function\"`).\n   - If absent, the middleware skips to caching or context attachment.\n\n4. **init Invocation**:\n\n   - The `init` function is called with the `Context` object (`ctx`):\n\n     ```typescript\n     const initResult = await module.init(ctx);\n     ```\n\n   - The `Context` provides access to `req`, `res`, and custom properties, enabling request-specific logic.\n   - Asynchronous operations (e.g., database queries, API calls) are awaited.\n\n5. **Result Processing**:\n\n   - **Truthy Result**: If `initResult` is non-falsy (e.g., `{ error: \"Unauthorized\" }`), the middleware returns it, halting further processing (e.g., no caching, no `next`).\n   - **Falsy Result**: If `initResult` is `null`, `undefined`, or absent, the middleware continues.\n   - The `Context` may be modified (e.g., `ctx.config = {...}`) for use by the module or downstream middleware.\n\n6. **Post-Initialization**:\n\n   - The module is cached (if `enableCache` is true) with the specified `cacheTTL`.\n   - The module is attached to the context (`ctx[moduleContextKey] = module`).\n   - The `onComplete` lifecycle hook is triggered.\n   - The middleware proceeds to `await next()`.\n\n7. **Error Handling**:\n   - Errors thrown by `init` are caught in the middleware‚Äôs `try-catch` block.\n   - The `onError` hook is invoked, and the response status is set to 500 (`ctx.setStatus = 500`).\n   - The error is re-thrown for upstream handling.\n\n### Integration Points\n\n- **Before `init`**: Module loading and validation ensure the module is valid.\n- **During `init`**: The function performs setup, validation, or early responses.\n- **After `init`**: Caching, context attachment, and lifecycle hooks complete the cycle.\n- **Short-Circuiting**: A truthy `initResult` bypasses caching, context attachment, and `next`.\n\n---\n\n#### `LazyLoadOptions<T>`\n\nConfiguration options for the `lazyLoadModules` middleware.\n\n| Property           | Description                                               | Default                                                                      |\n| ------------------ | --------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| `moduleKey`        | Function to extract the module name from the context.     | `(ctx) => ctx.req.params[queryKeyModule] \\|\\| ctx.req.query[queryKeyModule]` |\n| `getModuleLoader`  | Function to retrieve the module loader.                   | Required                                                                     |\n| `queryKeyModule`   | Query parameter name to select the module.                | `\"module\"`                                                                   |\n| `moduleContextKey` | Key to attach the loaded module to the context.           | `\"module\"`                                                                   |\n| `enableCache`      | Enable caching of loaded modules.                         | `true`                                                                       |\n| `cacheStorage`     | Custom cache storage implementation.                      | `Map<string, CacheItem<T>>`                                                  |\n| `cacheTTL`         | Cache Time-To-Live (TTL) in milliseconds.                 | `3600000` (1 hour)                                                           |\n| `lifecycleHooks`   | Lifecycle hooks for custom actions during module loading. | `{}`                                                                         |\n| `validateModule`   | Function to validate the loaded module.                   | `undefined`                                                                  |\n\n---\n\n## Consolidated Example: Unified Production-Ready Application\n\nThis example combines features from all four demos:\n\n- **Query-based loading** (Demo 1).\n- **Route-based loading** (Demo 2).\n- **Async `init` function** (Demo 3).\n- **Custom module key with validation** (Demo 4).\n\nIt demonstrates a production-ready setup with robust error handling, caching, lifecycle hooks, and a complex `init` function.\n\n### File Structure\n\n```bash\nproject/\n‚îú‚îÄ‚îÄ modules/\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard.js\n‚îÇ   ‚îú‚îÄ‚îÄ orders.js\n‚îÇ   ‚îú‚îÄ‚îÄ auth.js\n‚îÇ   ‚îú‚îÄ‚îÄ report.js\n‚îî‚îÄ‚îÄ server.js\n```\n\n### Code\n\n**`server.js`**:\n\n```typescript\nimport { Context } from \"tezx\";\nimport { lazyLoadModules, CacheItem } from \"tezx/middleware\";\n\n// Custom cache storage\nconst customCache = new Map<string, CacheItem>();\nconst cacheStorage = {\n  get: (key: string) => customCache.get(key),\n  set: (key: string, value: CacheItem) => customCache.set(key, value),\n  delete: (key: string) => customCache.delete(key),\n};\n\n// Module loader map\nconst moduleLoaders: Record<string, () => Promise<any>> = {\n  dashboard: () => import(\"./modules/dashboard.js\"),\n  orders: () => import(\"./modules/orders.js\"),\n  auth: () => import(\"./modules/auth.js\"),\n  report: () => import(\"./modules/report.js\"),\n};\n\n// Middleware configuration\nconst lazyLoadMiddleware = lazyLoadModules({\n  moduleKey: (ctx: Context) => {\n    // Prioritize body, then query, then params\n    return (\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module\n    );\n  },\n  getModuleLoader: async (ctx: Context) => {\n    const moduleName =\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module;\n    return moduleLoaders[moduleName] || null;\n  },\n  queryKeyModule: \"module\",\n  moduleContextKey: \"loadedModule\",\n  enableCache: true,\n  cacheTTL: 120000, // 2 minutes\n  cacheStorage,\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) =>\n      console.log(\n        `Loading ${moduleName} for request ID: ${ctx.req.id || \"unknown\"}`,\n      ),\n    onCacheHit: (moduleName, module, ctx) =>\n      console.log(`Cache hit for ${moduleName}`),\n    onCacheSet: (moduleName, module, ctx) =>\n      console.log(`Cached ${moduleName}`),\n    onComplete: (moduleName, module, ctx) =>\n      console.log(`Completed loading ${moduleName}`),\n    onError: (moduleName, error, ctx) =>\n      console.error(`Error in ${moduleName}: ${error.message}`),\n  },\n  validateModule: (module) => {\n    // Require handler function and version property\n    return (\n      typeof module.handler === \"function\" && typeof module.version === \"string\"\n    );\n  },\n});\n\n// Create Tezx app\napp.use(lazyLoadMiddleware);\n\n// Routes\napp.get(\"/api/query\", async (ctx: Context) => {\n  // Query-based (Demo 1, 3)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.get(\"/api/route/:module\", async (ctx: Context) => {\n  // Route-based (Demo 2)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.post(\"/api/body\", async (ctx: Context) => {\n  // Body-based (Demo 4)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 400;\n  return { error: \"Invalid or missing module\" };\n});\n```\n\n**`modules/dashboard.js`** (Demo 1-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Dashboard module\",\n  data: { widgets: [\"chart\", \"table\"] },\n});\n```\n\n**`modules/orders.js`** (Demo 2-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Orders module\",\n  data: { orderId: ctx.req.query.orderId || 123 },\n});\n```\n\n**`modules/auth.js`** (Demo 3-inspired, with complex `init`):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  const apiKey = ctx.req.headers[\"x-api-key\"];\n  if (!apiKey) {\n    return {\n      status: 401,\n      error: \"API key required\",\n    };\n  }\n  try {\n    // Simulate async config fetch\n    const config = await fetchConfig(apiKey);\n    ctx.authConfig = config; // Attach to context\n    return null;\n  } catch (error) {\n    return {\n      status: 500,\n      error: `Auth initialization failed: ${error.message}`,\n    };\n  }\n};\nexport const handler = (ctx) => ({\n  message: \"Auth module\",\n  data: { token: \"abc123\", config: ctx.authConfig },\n});\n\n// Simulated async function\nasync function fetchConfig(apiKey) {\n  return { apiKey, settings: { scope: \"user\" } };\n}\n```\n\n**`modules/report.js`** (Demo 4-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  return null;\n};\nexport const handler = (ctx) => ({\n  message: \"Report module\",\n  data: { type: ctx.req.body?.reportType || \"sales\" },\n});\n```\n\n### Example Features\n\n- **Unified Module Identification**: Supports query (`/api/query?module=...`), route (`/api/route/:module`), and body (`POST /api/body`) inputs.\n- **Robust `init` Function**: The `auth` module demonstrates a complex `init` with API key validation, async configuration fetch, and context modification.\n- **Custom Cache Storage**: Uses a `Map`-based cache with a 2-minute TTL.\n- **Strict Validation**: Ensures modules have a `handler` function and `version` property.\n- **Comprehensive Lifecycle Hooks**: Logs all stages (load, cache hit, cache set, complete, error).\n- **Error Handling**: Gracefully handles missing modules, validation failures, and `init` errors.\n\n---\n"
        },
        {
          "originalPath": "12. Detect Bot.md",
          "id": 31,
          "name": "Detect Bot",
          "type": "file",
          "path": "middlewares/detect-bot",
          "content": "# DetectBot Middleware\n\nThe `DetectBot` middleware provides a sophisticated and extensible mechanism for identifying and managing bot traffic in web applications. By integrating multiple detection methods‚Äîsuch as User-Agent analysis, IP blacklisting, query parameter checks, rate limiting, and custom logic‚Äîit offers comprehensive protection against unwanted bot activity while allowing fine-grained control over detection and response strategies.\n\n## Key Features\n\n- **User-Agent Analysis**: Identifies bots based on predefined or custom User-Agent patterns.\n- **IP Blacklisting**: Supports integration with external IP reputation services or custom blacklists.\n- **Query Parameter Detection**: Flags requests containing specific query parameters as potential bots.\n- **Rate Limiting**: Enforces request frequency limits to detect aggressive bot behavior.\n- **Custom Detection Logic**: Enables developers to implement application-specific bot identification rules.\n- **Confidence-Based Scoring**: Employs a weighted scoring system for nuanced bot classification.\n- **Configurable Responses**: Allows blocking of bots or execution of custom response logic.\n\n## Installation\n\nInstall the middleware as part of the `tezx` package:\n\n```bash\nnpm install tezx\n```\n\nImport the middleware into your project:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n```\n\n## Configuration Options\n\nThe `detectBot` middleware accepts an optional `DetectBotOptions` object to tailor its functionality. The table below outlines all available options, their types, default values, and descriptions:\n\n| Option                  | Type                                                                        | Default Value                                                                               | Description                                                                                         |\n| ----------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| `botUserAgents`         | `string[]`                                                                  | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]`                                                       | Substrings in User-Agent headers that indicate bot traffic.                                         |\n| `maxRequests`           | `number`                                                                    | `30`                                                                                        | Maximum requests allowed within the rate-limiting window.                                           |\n| `windowMs`              | `number`                                                                    | `60000` (1 minute)                                                                          | Time window (in milliseconds) for rate-limiting calculations.                                       |\n| `isBlacklisted`         | `(ctx: Context, remoteAddress: string) => boolean \\| Promise<boolean>`      | `() => false`                                                                               | Asynchronous function to determine if an IP is blacklisted.                                         |\n| `queryKeyBot`           | `string`                                                                    | `\"bot\"`                                                                                     | Query parameter key signaling bot traffic (e.g., `?bot=true`).                                      |\n| `onBotDetected`         | `\"block\" \\| ((ctx: Context, result: BotDetectionResult) => CallbackReturn)` | `\"block\"`                                                                                   | Action to perform upon bot detection: `\"block\"` or a custom callback.                               |\n| `enableRateLimiting`    | `boolean`                                                                   | `false`                                                                                     | Enables rate-limiting detection.                                                                    |\n| `customBotDetector`     | `(ctx: Context) => boolean \\| Promise<boolean>`                             | `() => false`                                                                               | Custom asynchronous logic to identify bots.                                                         |\n| `customBlockedResponse` | `(ctx: Context, result: BotDetectionResult) => CallbackReturn`              | `(ctx, { reason }) => { ctx.setStatus = 403; return ctx.json({ error: \"Bot detected\" }); }` | Custom response for blocked requests.                                                               |\n| `storage`               | `{ get, set, delete, clearExpired }`                                        | `Map` (in-memory)                                                                           | Custom storage implementation for rate-limiting data (e.g., Redis). Defaults to an in-memory `Map`. |\n| `confidenceThreshold`   | `number` (0-1)                                                              | `0.5`                                                                                       | Minimum confidence score required to classify a request as a bot with multiple indicators.          |\n\n## Usage Examples\n\n### Basic Configuration\n\nApply the middleware with default settings to block detected bots:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n\napp.use(detectBot());\n\napp.get(\"/\", (ctx) => {\n  return ctx.json({ message: \"Hello, human!\" });\n});\n\napp.listen(3000);\n```\n\n- **Behavior**: Automatically blocks requests from User-Agents containing \"bot\", \"spider\", \"crawl\", or \"slurp\" with a `403 Forbidden` response.\n\n### Advanced Configuration\n\nCustomize detection with IP blacklisting, rate limiting, and a tailored response:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n\n// Simulated IP reputation service\nasync function checkIPReputation(ip: string): Promise<boolean> {\n  const blacklist = [\"192.168.1.100\", \"10.0.0.1\"];\n  return blacklist.includes(ip);\n}\n\napp.use(\n  detectBot({\n    botUserAgents: [\"bot\", \"crawler\", \"spider\"],\n    maxRequests: 10,\n    windowMs: 30000, // 30 seconds\n    isBlacklisted: async (ctx, ip) => await checkIPReputation(ip),\n    enableRateLimiting: true,\n    customBotDetector: async (ctx) => {\n      // Flag requests without a referrer as potential bots\n      return !ctx.req.headers.get(\"referer\");\n    },\n    onBotDetected: (ctx, { reason, indicators }) => {\n      ctx.setStatus = 403;\n      return ctx.json({\n        error: \"Access Denied\",\n        reason,\n        indicators,\n      });\n    },\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.json({ message: \"Welcome, verified user!\" });\n});\n\napp.listen(3000);\n```\n\n- **Behavior**:\n  - Blocks requests with specified bot-like User-Agents.\n  - Rejects requests from blacklisted IPs.\n  - Enforces a limit of 10 requests per IP every 30 seconds.\n  - Identifies requests lacking a referrer as bots.\n  - Returns a detailed JSON error response upon detection.\n\n### Distributed Rate Limiting with Redis\n\nIntegrate Redis for scalable rate limiting across multiple instances:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key: string) => {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : undefined;\n  },\n  set: async (key: string, value: { count: number; resetTime: number }) => {\n    await redis.set(\n      key,\n      JSON.stringify(value),\n      \"PX\",\n      value.resetTime - Date.now(),\n    );\n  },\n  clearExpired: async () => {\n    // Redis automatically handles expiration via PX\n    //  if (now >= entry.resetTime) {\n    //                     .....delete(key);\n    //                 }\n  },\n};\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    maxRequests: 50,\n    windowMs: 60000, // 1 minute\n    storage: redisStorage,\n  }),\n);\n\napp.listen(3000);\n```\n\n- **Behavior**: Utilizes Redis to maintain rate-limiting state across distributed server instances, enforcing 50 requests per minute per IP.\n\n## Detection Mechanism\n\nThe middleware employs a multi-step process to classify requests:\n\n1. **Indicator Collection**: Gathers evidence such as User-Agent matches, blacklisted IPs, query parameters, rate limit breaches, and custom detector results.\n2. **Confidence Scoring**: When multiple indicators are present, calculates a confidence score (`0.3 * number of indicators`, capped at 1).\n3. **Bot Classification**:\n   - A request is flaggedS considered a bot if any single indicator is detected or if the confidence score exceeds the `confidenceThreshold` (default: 0.5).\n\n## Error Handling\n\n- **Blocking**: If `onBotDetected` is set to `\"block\"`, the `customBlockedResponse` function is invoked.\n- **Custom Logic Errors**: Failures in `isBlacklisted` or `customBotDetector` are logged via `GlobalConfig.debugging.warn`, allowing the request to proceed to avoid false positives.\n\n## Best Practices\n\n- **Optimize Rate Limits**: Calibrate `maxRequests` and `windowMs` to align with expected traffic patterns.\n- **Leverage Custom Detection**: Use `customBotDetector` to address domain-specific bot characteristics.\n- **Enable Logging**: Activate debugging in `GlobalConfig` to monitor detection events and refine rules.\n- **Scale Effectively**: Employ external storage (e.g., Redis) for high-traffic or multi-instance deployments.\n\n## Sample Output\n\nFor a request from `Googlebot` with IP `192.168.1.100` and query `?bot=true`:\n\n```json\n{\n  \"error\": \"Access Denied\",\n  \"reason\": \"Multiple Indicators\",\n  \"indicators\": [\"User-Agent\", \"Blacklisted IP\", \"Query Parameter\"]\n}\n```\n\n---\n"
        },
        {
          "originalPath": "13. Basic Auth.md",
          "id": 32,
          "name": "Basic Auth",
          "type": "file",
          "path": "middlewares/basic-auth",
          "content": "# **basicAuth Middleware**\n\n## **Overview**\n\nThe `basicAuth` middleware provides flexible authentication for web applications, supporting **Basic Authentication**, **API Key**, and **Bearer Token** methods. It includes advanced features like **rate limiting**, **IP-based tracking**, and **Role-Based Access Control (RBAC)**, making it suitable for securing APIs and web routes. The middleware integrates seamlessly with the framework‚Äôs `Context` and `Middleware` types, ensuring type safety and runtime compatibility across Node.js, Bun, and Deno.\n\n---\n\n## **Type Definitions**\n\n```typescript\ntype AuthMethod = \"basic\" | \"api-key\" | \"bearer-token\";\n\ntype DynamicBasicAuthOptions = {\n  validateCredentials: (\n    method: AuthMethod,\n    credentials: Record<string, any>,\n    ctx: Context,\n  ) => boolean | Promise<boolean>;\n  getRealm?: (ctx: Context) => string;\n  onUnauthorized?: (ctx: Context, error?: Error) => CallbackReturn;\n  rateLimit?: {\n    storage?: {\n      get: (key: string) => { count: number; resetTime: number } | undefined;\n      set: (key: string, value: { count: number; resetTime: number }) => void;\n      clearExpired: () => void;\n    };\n    maxRequests: number;\n    windowMs: number;\n  };\n  supportedMethods?: AuthMethod[];\n  checkAccess?: (\n    ctx: Context,\n    credentials: Record<string, any>,\n  ) => boolean | Promise<boolean>;\n};\n\nexport const basicAuth: (options: DynamicBasicAuthOptions) => Middleware;\n```\n\n- **`AuthMethod`**: Enum for supported authentication types (`basic`, `api-key`, `bearer-token`).\n- **`DynamicBasicAuthOptions`**: Configuration object for customizing authentication behavior.\n- **`Middleware`**: Framework type for middleware functions, accepting a `Context` and `next` callback.\n\n---\n\n## **Configuration Options**\n\n| Property              | Type                                                                                                  | Description                                                                  | Default                                |\n| --------------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------- |\n| `validateCredentials` | `(method: AuthMethod, credentials: Record<string, any>, ctx: Context) => boolean \\| Promise<boolean>` | Validates provided credentials. **Required**.                                | N/A                                    |\n| `getRealm`            | `(ctx: Context) => string`                                                                            | Dynamically sets the authentication realm for the `WWW-Authenticate` header. | `() => \"Restricted Area\"`              |\n| `onUnauthorized`      | `(ctx: Context, error?: Error) => CallbackReturn`                                                     | Handles unauthorized access with a custom response.                          | Sets `401` with `WWW-Authenticate`     |\n| `rateLimit`           | `{ storage?, maxRequests: number, windowMs: number }`                                                 | Configures rate limiting by IP.                                              | None (disabled by default)             |\n| `supportedMethods`    | `AuthMethod[]`                                                                                        | List of allowed authentication methods.                                      | `[\"basic\", \"api-key\", \"bearer-token\"]` |\n| `checkAccess`         | `(ctx: Context, credentials: Record<string, any>) => boolean \\| Promise<boolean>`                     | Optional RBAC check for fine-grained access control.                         | None (disabled by default)             |\n\n---\n\n## **Features**\n\n- **Multiple Authentication Methods**: Supports Basic Auth, API Key, and Bearer Token.\n- **Rate Limiting**: Prevents brute-force attacks with IP-based request limits.\n- **Role-Based Access Control**: Optionally enforces access policies post-authentication.\n- **Dynamic Realm**: Customizes the authentication prompt based on request context.\n- **Custom Error Handling**: Allows tailored responses for unauthorized access.\n- **Type-Safe**: Leverages TypeScript for robust integration with the framework.\n\n---\n\n## **Usage Examples**\n\nBelow are complete examples demonstrating all possible use cases of the `basicAuth` middleware.\n\n### **Basic Authentication**\n\nProtect a route using Basic Authentication with a simple username/password check.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"basic\") return false;\n      const { username, password } = credentials;\n      return username === \"admin\" && password === \"secret\";\n    },\n  }),\n);\n\napp.get(\"/protected\", (ctx) => {\n  return ctx.json({ message: \"Welcome, authenticated user!\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -u admin:secret http://localhost:3000/protected\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Welcome, authenticated user!\" }\n```\n\n**Invalid Credentials**:\n\n```bash\ncurl -u admin:wrong http://localhost:3000/protected\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **API Key Authentication**\n\nUse an API key passed via the `x-api-key` header.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    supportedMethods: [\"api-key\"],\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"api-key\") return false;\n      return credentials.apiKey === \"my-api-key-123\";\n    },\n  }),\n);\n\napp.get(\"/api/data\", (ctx) => {\n  return ctx.json({ data: \"Sensitive information\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -H \"x-api-key: my-api-key-123\" http://localhost:3000/api/data\n```\n\n**Response**:\n\n```json\n{ \"data\": \"Sensitive information\" }\n```\n\n**Invalid Key**:\n\n```bash\ncurl -H \"x-api-key: wrong-key\" http://localhost:3000/api/data\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **Bearer Token Authentication**\n\nSecure a route with a Bearer Token.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    supportedMethods: [\"bearer-token\"],\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"bearer-token\") return false;\n      return credentials.token === \"valid-jwt-token\";\n    },\n  }),\n);\n\napp.get(\"/secure\", (ctx) => {\n  return ctx.json({ message: \"Token verified!\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -H \"Authorization: Bearer valid-jwt-token\" http://localhost:3000/secure\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Token verified!\" }\n```\n\n**Invalid Token**:\n\n```bash\ncurl -H \"Authorization: Bearer invalid-token\" http://localhost:3000/secure\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **Rate Limiting**\n\nLimit requests by IP to prevent abuse.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return credentials.username === \"user\" && credentials.password === \"pass\";\n    },\n    rateLimit: {\n      maxRequests: 3, // Allow 3 requests\n      windowMs: 60 * 1000, // Per minute\n    },\n  }),\n);\n\napp.get(\"/rate-limited\", (ctx) => {\n  return ctx.json({ message: \"Access granted\" });\n});\n```\n\n**Requests**:\n\n```bash\ncurl -u user:pass http://localhost:3000/rate-limited  # 1st: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 2nd: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 3rd: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 4th: Blocked\n```\n\n**Blocked Response**:\n\n```json\n{ \"error\": \"Rate limit exceeded. Retry after 60 seconds.\" }\n```\n\n**Headers**:\n\n```bash\nRetry-After: 60\n```\n\n---\n\n### **Role-Based Access Control**\n\nRestrict access based on user roles after authentication.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      if (\n        credentials.username === \"admin\" &&\n        credentials.password === \"admin123\"\n      ) {\n        credentials.role = \"admin\";\n        return true;\n      }\n      if (\n        credentials.username === \"user\" &&\n        credentials.password === \"user123\"\n      ) {\n        credentials.role = \"user\";\n        return true;\n      }\n      return false;\n    },\n    checkAccess: async (ctx, credentials) => {\n      return credentials.role === \"admin\"; // Only admins allowed\n    },\n  }),\n);\n\napp.get(\"/admin-only\", (ctx) => {\n  return ctx.json({ message: \"Admin access granted\" });\n});\n```\n\n**Admin Request**:\n\n```bash\ncurl -u admin:admin123 http://localhost:3000/admin-only\n```\n\n```json\n{ \"message\": \"Admin access granted\" }\n```\n\n**User Request**:\n\n```bash\ncurl -u user:user123 http://localhost:3000/admin-only\n```\n\n```json\n{ \"error\": \"Access denied.\" }\n```\n\n---\n\n### **Custom Unauthorized Handler**\n\nCustomize the response for unauthorized access.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return false; // Simulate failure\n    },\n    onUnauthorized: (ctx, error) => {\n      ctx.status = 401;\n      ctx.body = {\n        status: \"error\",\n        message: `Authentication failed: ${error?.message}`,\n        timestamp: new Date().toISOString(),\n      };\n      return;\n    },\n  }),\n);\n\napp.get(\"/custom-error\", (ctx) => {\n  return ctx.json({ message: \"This won‚Äôt be reached\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl http://localhost:3000/custom-error\n```\n\n**Response**:\n\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"Authentication failed: Invalid credentials.\",\n  \"timestamp\": \"2025-04-15T12:00:00.000Z\"\n}\n```\n\n---\n\n### **Dynamic Realm**\n\nCustomize the `WWW-Authenticate` realm dynamically.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return false; // Simulate failure\n    },\n    getRealm: (ctx) => {\n      return ctx.url.pathname === \"/admin\" ? \"Admin Portal\" : \"User Area\";\n    },\n  }),\n);\n\napp.get(\"/admin\", (ctx) => {\n  return ctx.json({ message: \"Admin area\" });\n});\n\napp.get(\"/user\", (ctx) => {\n  return ctx.json({ message: \"User area\" });\n});\n```\n\n**Admin Request**:\n\n```bash\ncurl http://localhost:3000/admin\n```\n\n**Response Headers**:\n\n```bash\nWWW-Authenticate: Basic realm=\"Admin Portal\"\n```\n\n**User Request**:\n\n```bash\ncurl http://localhost:3000/user\n```\n\n**Response Headers**:\n\n```bash\nWWW-Authenticate: Basic realm=\"User Area\"\n```\n\n---\n\n## **Best Practices**\n\n- **Validate Credentials Securely**: Use hashed passwords or token verification libraries (e.g., JWT) in `validateCredentials`.\n- **Enable Rate Limiting**: Always configure `rateLimit` for public APIs to prevent abuse.\n- **Use RBAC Sparingly**: Only implement `checkAccess` for routes requiring fine-grained control to avoid performance overhead.\n- **Log Errors**: Use `GlobalConfig.debugging.error` for monitoring authentication failures in production.\n- **Restrict Supported Methods**: Explicitly set `supportedMethods` to only those required by your application.\n- **Test Unauthorized Cases**: Ensure `onUnauthorized` provides clear feedback for debugging and user experience.\n\n---\n\n## **Error Handling**\n\nThe middleware handles errors gracefully:\n\n- **Missing Auth Header**: Triggers `onUnauthorized` with an \"Unsupported authentication method\" error.\n- **Invalid Credentials**: Calls `onUnauthorized` with an \"Invalid credentials\" error.\n- **Rate Limit Exceeded**: Returns a `Retry-After` header and error message.\n- **RBAC Failure**: Invokes `onUnauthorized` with an \"Access denied\" error.\n- **Unexpected Errors**: Caught and passed to `onUnauthorized` for custom handling.\n\n---\n"
        },
        {
          "originalPath": "14. .Detect Locale.md",
          "id": 33,
          "name": "Detect Locale",
          "type": "file",
          "path": "middlewares/detect-locale",
          "content": "# `detectLocale` Middleware\n\n## Overview\n\nThe `detectLocale` middleware is designed to detect and set a user's preferred locale in a web application. It supports multiple detection methods, including query parameters, cookies, HTTP `Accept-Language` headers, and custom logic, making it highly flexible for internationalization (i18n). The middleware attaches the detected locale to the request context, enabling subsequent middleware or route handlers to deliver localized content. It is built with TypeScript for type safety and is compatible with runtimes like Node.js, Bun, and Deno.\n\n---\n\n## Features\n\n- **Multiple Detection Methods**: Supports locale detection via query parameters, cookies, `Accept-Language` headers, and custom detectors.\n- **Configurable Defaults**: Set a fallback locale and customize key names for query parameters, cookies, and context storage.\n- **Type-Safe**: Built with TypeScript for robust type checking and integration with custom context properties.\n- **Flexible Context Storage**: Store the detected locale under a custom key in the context object.\n- **Debugging Support**: Logs detected locales via `debugMode` for easy troubleshooting.\n- **Cross-Runtime Compatibility**: Works seamlessly with Node.js, Bun, and Deno.\n\n---\n\n## Configuration Options\n\nThe middleware is configured via a `DetectLocaleOptions` object, which allows fine-grained control over locale detection behavior.\n\n### `DetectLocaleOptions`\n\n| Property               | Type                                    | Description                                                                | Required | Default Value |\n| ---------------------- | --------------------------------------- | -------------------------------------------------------------------------- | -------- | ------------- |\n| `supportedLocales`     | `string[]`                              | List of allowed locales (e.g., `[\"en\", \"fr\", \"bn\"]`).                      | Yes      | N/A           |\n| `defaultLocale`        | `string`                                | Fallback locale if no match is found.                                      | No       | `\"en\"`        |\n| `queryKeyLocale`       | `string`                                | Query parameter name for locale (e.g., `lang` in `/?lang=fr`).             | No       | `\"lang\"`      |\n| `cookieKeyLocale`      | `string`                                | Cookie name for storing locale preference.                                 | No       | `\"locale\"`    |\n| `localeContextKey`     | `string`                                | Key used to store the detected locale in the context (e.g., `ctx.locale`). | No       | `\"locale\"`    |\n| `customLocaleDetector` | `(ctx: Context) => string \\| undefined` | Custom function to detect locale programmatically.                         | No       | None          |\n\n---\n\n## Middleware Workflow\n\nThe `detectLocale` middleware follows a prioritized detection process:\n\n1. **Query Parameter**:\n\n   - Checks the query parameter specified by `queryKeyLocale` (e.g., `/?lang=fr`).\n   - Validates against `supportedLocales`.\n\n2. **Cookie Value**:\n\n   - Checks the cookie specified by `cookieKeyLocale` (e.g., `locale=fr`).\n   - Validates against `supportedLocales`.\n\n3. **Accept-Language Header**:\n\n   - Parses the `Accept-Language` header (e.g., `en,fr;q=0.9`).\n   - Selects the first supported locale from the header‚Äôs ordered list.\n\n4. **Custom Detector** (if provided):\n\n   - Invokes `customLocaleDetector` to programmatically determine the locale.\n   - Validates the result against `supportedLocales`.\n\n5. **Default Locale**:\n   - Falls back to `defaultLocale` if no valid locale is detected.\n\n**Final Step**:\n\n- Stores the detected locale in `ctx[localeContextKey]`.\n- Calls `next()` to proceed to the next middleware or route handler.\n\n---\n\n## Usage Examples\n\nBelow are complete examples demonstrating all possible use cases for the `detectLocale` middleware.\n\n### Example 1: Query Parameter Detection\n\nDetects the locale from a query parameter (e.g., `/?lang=fr`).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\nimport { Middleware } from \"tezx\"; // Assuming a framework app instance\n\nconst localeMiddleware: Middleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  queryKeyLocale: \"lang\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl http://localhost:3000/welcome?lang=fr\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 2: Cookie-Based Detection\n\nDetects the locale from a cookie (e.g., `locale=en`).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  cookieKeyLocale: \"locale\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example** (with cookie set):\n\n```bash\ncurl --cookie \"locale=en\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Welcome!\" }\n```\n\n---\n\n### Example 3: Accept-Language Header Detection\n\nDetects the locale from the `Accept-Language` header.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl -H \"Accept-Language: fr,en;q=0.9\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 4: Custom Locale Detector\n\nUses a custom detector to determine the locale based on user-specific logic (e.g., database lookup).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  customLocaleDetector: (ctx) => {\n    // Mock user profile lookup\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl -H \"x-user-id: user123\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n```\n\n---\n\n### Example 5: Default Locale Fallback\n\nFalls back to the default locale when no other detection method provides a valid locale.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"fr\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example** (no locale specified):\n\n```bash\ncurl http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 6: Combining All Detection Methods\n\nCombines query parameters, cookies, headers, and a custom detector, with a custom context key.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"en\",\n  queryKeyLocale: \"language\",\n  cookieKeyLocale: \"user_locale\",\n  localeContextKey: \"userLocale\",\n  customLocaleDetector: (ctx) => {\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.userLocale; // Custom context key\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  ctx.body = { message: messages[locale] };\n  return;\n});\n```\n\n**Request Examples**:\n\n1. **Query Parameter**:\n\n   ```bash\n   curl http://localhost:3000/welcome?language=fr\n   ```\n\n   **Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n2. **Cookie**:\n\n   ```bash\n   curl --cookie \"user_locale=bn\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n   ```\n\n3. **Accept-Language Header**:\n\n   ```bash\n   curl -H \"Accept-Language: en,fr;q=0.9\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"Welcome!\" }\n   ```\n\n4. **Custom Detector**:\n\n   ```bash\n   curl -H \"x-user-id: user123\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n   ```\n\n5. **Default Fallback**:\n\n   ```bash\n   curl http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"Welcome!\" }\n   ```\n\n---\n\n## Best Practices\n\n- **Validate Supported Locales**: Ensure `supportedLocales` includes all locales your application supports to avoid unexpected behavior.\n- **Consistent Naming**: Use clear, consistent names for `queryKeyLocale`, `cookieKeyLocale`, and `localeContextKey` to align with your API conventions.\n- **Custom Detectors**: Use `customLocaleDetector` for advanced logic, such as database-driven locale preferences or geolocation-based detection.\n- **Debugging**: Enable debugging during development to log detected locales for troubleshooting.\n- **Cookie Security**: Set secure and HTTP-only flags on locale cookies to prevent client-side access.\n- **Header Parsing**: Handle complex `Accept-Language` headers carefully, as clients may send malformed values.\n\n---\n\n## Error Handling\n\nThe middleware is designed to be robust and fault-tolerant:\n\n- **Invalid Query Parameter**: Ignores unsupported query parameter values and proceeds to the next detection method.\n- **Invalid Cookie**: Ignores unsupported cookie values and proceeds to the next detection method.\n- **Malformed Accept-Language Header**: Filters out unsupported or invalid locales and proceeds to the next detection method.\n- **Invalid Custom Detector**: Ignores invalid results from `customLocaleDetector` and falls back to `defaultLocale`.\n- **Missing Locale**: Always falls back to `defaultLocale`, ensuring a valid locale is set.\n\n---\n\n## Type Definitions\n\n```typescript\ntype DetectLocaleOptions = {\n  supportedLocales: string[];\n  defaultLocale?: string;\n  queryKeyLocale?: string;\n  cookieKeyLocale?: string;\n  localeContextKey?: string;\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\nexport const detectLocale: (options: DetectLocaleOptions) => Middleware;\n```\n\n---\n"
        },
        {
          "originalPath": "15. Request Timeout.md",
          "id": 34,
          "name": "Request Timeout",
          "type": "file",
          "path": "middlewares/request-timeout",
          "content": "# `requestTimeout` Middleware Documentation\n\nThe `requestTimeout` middleware is designed to enforce fully dynamic request timeouts in a middleware-based application. It allows developers to specify a timeout duration dynamically based on the request context, handle timeout errors, log timeout events, and perform cleanup operations after a timeout occurs.\n\n## Overview\n\nThe middleware integrates with a routing system that uses a `Context` object to manage request and response data. The middleware is highly customizable through the `TimeoutOptions` configuration, enabling developers to tailor timeout behavior to specific use cases.\n\n## API Reference\n\n### `TimeoutOptions`\n\nThe `TimeoutOptions` type defines the configuration options for the `requestTimeout` middleware.\n\n| Property          | Type                                             | Description                                                                                                                         |\n| ----------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |\n| `getTimeout`      | `(ctx: Context) => number`                       | **Required.** Function to dynamically determine the timeout duration (in milliseconds) based on the request context.                |\n| `onTimeout`       | `(ctx: Context, error: Error) => CallbackReturn` | **Optional.** Custom function to handle timeout errors. Defaults to setting a 504 Gateway Timeout status and a JSON error response. |\n| `logTimeoutEvent` | `(ctx: Context, error: Error) => void`           | **Optional.** Logging function for timeout events. Defaults to logging a warning with request details via `debugging.warn`.         |\n| `cleanup`         | `(ctx: Context) => void`                         | **Optional.** Custom function to clean up resources after a timeout. Defaults to an empty function.                                 |\n\n### `requestTimeout`\n\nThe `requestTimeout` function creates a middleware that enforces dynamic timeouts.\n\n**Signature:**\n\n```typescript\nrequestTimeout(options: TimeoutOptions): Middleware\n```\n\n**Parameters:**\n\n- `options`: An object conforming to the `TimeoutOptions` type.\n\n**Returns:**\n\n- A `Middleware` function that can be used in a middleware pipeline.\n\n## Usage\n\nThe middleware is typically used in a middleware-based framework (e.g., Express-like routers). Below are several examples demonstrating how to use the `requestTimeout` middleware in different scenarios.\n\n### Example 1: Basic Timeout with Default Behavior\n\nThis example sets a fixed 5-second timeout for all requests.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => 5000, // 5 seconds\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- All requests will timeout after 5 seconds.\n- The default `onTimeout` sets a 504 status and returns `{ error: \"Request timed out.\" }`.\n- Timeout events are logged using the default `logTimeoutEvent`.\n- No custom cleanup is performed.\n\n### Example 2: Dynamic Timeout Based on Request Path\n\nThis example sets different timeout durations based on the request path.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => {\n    if (ctx.path.startsWith(\"/api/slow\")) {\n      return 10000; // 10 seconds for slow endpoints\n    }\n    return 3000; // 3 seconds for others\n  },\n  onTimeout: (ctx, error) => {\n    ctx.setStatus = 504;\n    ctx.body = {\n      error: `Request to ${ctx.path} timed out after ${getTimeout(ctx)}ms.`,\n    };\n  },\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- Requests to `/api/slow/*` have a 10-second timeout, while others have a 3-second timeout.\n- The custom `onTimeout` provides a detailed error message including the request path and timeout duration.\n\n### Example 3: Custom Logging and Cleanup\n\nThis example demonstrates custom logging and cleanup for timeout events.\n\n```typescript\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => 5000, // 5 seconds\n  logTimeoutEvent: (ctx, error) => {\n    logger.error(\n      `Timeout occurred: ${ctx.method} ${ctx.path} - ${error.message}`,\n    );\n  },\n  cleanup: (ctx) => {\n    // Release database connections or other resources\n    db.releaseConnection(ctx.requestId);\n  },\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- Timeout events are logged using a custom `Logger` utility.\n- The `cleanup` function releases database connections associated with the request.\n\n### Example 4: Combining with Other Middleware\n\nThis example shows how to combine `requestTimeout` with other middleware in a pipeline.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\nimport { authenticate } from \"./auth-middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => {\n    // Longer timeout for authenticated users\n    return ctx.user ? 10000 : 5000; // 10s for authenticated, 5s otherwise\n  },\n});\n\napp.use(authenticate); // Authenticate user first\napp.use(timeoutMiddleware); // Apply timeout\n```\n\n```ts\napp.get(\"/\", async (ctx) => {\n  await new Promise((resolve) => setTimeout(resolve, 6000)); // 6 seconds\n  return await ctx.json({});\n});\n```\n\nIn this case:\n\n- The `authenticate` middleware populates `ctx.user` if the request is authenticated.\n- The timeout is dynamically set based on the authentication status.\n\n## Error Handling\n\nThe middleware handles errors as follows:\n\n- **Timeout Errors**: If the request exceeds the timeout duration, the `onTimeout` function is called, and the error is not propagated further.\n- **Other Errors**: Non-timeout errors (e.g., errors thrown by `next()`) are re-thrown to be handled by downstream middleware or error handlers.\n- **Cleanup**: The `cleanup` function is always called in the `finally` block, ensuring resources are released even if an error occurs.\n\n## Best Practices\n\n1. **Dynamic Timeout Logic**:\n\n   - Use `getTimeout` to adjust timeouts based on request characteristics (e.g., path, method, user role).\n   - Avoid overly short timeouts that may interrupt legitimate requests.\n\n2. **Error Handling**:\n\n   - Customize `onTimeout` to provide meaningful error responses to clients.\n   - Ensure `onTimeout` sets an appropriate HTTP status code (e.g., 504 Gateway Timeout).\n\n3. **Logging**:\n\n   - Use `logTimeoutEvent` to record timeout events for monitoring and debugging.\n   - Include relevant context (e.g., `ctx.method`, `ctx.path`) in logs.\n\n4. **Resource Cleanup**:\n\n   - Implement `cleanup` to release resources like database connections, file handles, or timers.\n   - Ensure `cleanup` is idempotent to handle multiple calls safely.\n\n5. **Testing**:\n   - Test timeout behavior under various conditions (e.g., slow network, heavy load).\n   - Verify that `cleanup` is called in all scenarios (success, timeout, error).\n\n## Limitations\n\n- The middleware relies on `setTimeout`, which may not be precise for very short durations due to JavaScript's event loop.\n- It assumes the `Context` object has properties like `method`, `path`, `setStatus`, and `body`. Ensure your framework's `Context` is compatible.\n- The middleware does not handle concurrent requests explicitly; ensure your application handles concurrency appropriately.\n"
        },
        {
          "originalPath": "16. Cache Control.md",
          "id": 35,
          "name": "Cache Control",
          "type": "file",
          "path": "middlewares/cache-control",
          "content": "\n# `cacheControl` Middleware\n\n`tezx/middleware`\n\n### üì¶ Import\n\n```ts\nimport { cacheControl } from 'tezx/middleware';\n```\n\n---\n\n## üß† Description\n\n`cacheControl` is an HTTP caching middleware that dynamically applies headers like `Cache-Control`, `Expires`, `Vary`, and `ETag` based on request conditions. It supports custom rules, smart revalidation, and automatic header management for production-ready caching.\n\n---\n\n## üîß Usage\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 60,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"],\n  },\n  rules: [\n    {\n      condition: (ctx) => ctx.pathname.startsWith(\"/api/\"),\n      maxAge: 10,\n      scope: \"private\",\n      enableETag: true,\n    },\n  ],\n  logEvent: (event, ctx, error) => {\n    console.log(`[CACHE EVENT] ${event}`, ctx.pathname, error?.message);\n  },\n}));\n```\n\n---\n\n## ‚öôÔ∏è `DynamicCacheOptions`\n\n### Properties\n\n| Property          | Type                                      | Description                                                           |\n| ----------------- | ----------------------------------------- | --------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings`                           | Default cache behavior if no rule matches.                            |\n| `rules`           | `CacheRule[]` (optional)                  | List of custom rules that match specific conditions.                  |\n| `useWeakETag`     | `boolean` (optional)                      | Whether to use weak ETags (e.g., `W/\"etag\"`). Default: `false`.       |\n| `logEvent`        | `(event, ctx, error?) => void` (optional) | Logging callback for cache events like \"cached\", \"no-cache\", \"error\". |\n\n---\n\n## üßæ `CacheRule`\n\n```ts\ntype CacheRule = {\n  condition: (ctx: Context) => boolean;\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\nDefines a rule based on custom logic (`condition`) to dynamically apply different caching behavior.\n\n---\n\n## üßæ `CacheSettings`\n\n```ts\ntype CacheSettings = {\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\nDefines standard cache parameters applied by default or when a rule is matched.\n\n---\n\n## üì• Example: Static + Dynamic Cache\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 300,\n    scope: \"public\",\n    enableETag: true,\n  },\n  rules: [\n    {\n      condition: (ctx) => ctx.pathname.startsWith(\"/assets/\"),\n      maxAge: 86400,\n      scope: \"public\",\n      enableETag: false,\n    },\n    {\n      condition: (ctx) => ctx.pathname === \"/profile\",\n      maxAge: 30,\n      scope: \"private\",\n      enableETag: true,\n    }\n  ]\n}));\n```\n\n---\n\n## üß™ ETag Generation\n\n* ETag is generated using `md5` hash of the response body.\n* If `useWeakETag: true`, it‚Äôs returned as `W/\"etag\"`, which is less strict and more cache-friendly.\n* Automatically responds with `304 Not Modified` if client-sent `If-None-Match` matches.\n\n---\n\n## üì§ Headers Set\n\n* `Cache-Control`\n* `Expires`\n* `ETag` *(optional)*\n* `Vary` *(optional)*\n\n---\n\n## üîê Compatibility\n\n* Works for `GET` and `HEAD` requests only.\n* Skips caching logic for other HTTP methods.\n* Safe to use across dynamic and static responses.\n\n---\n"
        },
        {
          "originalPath": "2. Logger.md",
          "id": 36,
          "name": "Logger",
          "type": "file",
          "path": "middlewares/logger",
          "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```bash\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
        },
        {
          "originalPath": "3. Powered By.md",
          "id": 37,
          "name": "Powered By",
          "type": "file",
          "path": "middlewares/powered-by",
          "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
        },
        {
          "originalPath": "4. Request ID.md",
          "id": 38,
          "name": "Request ID",
          "type": "file",
          "path": "middlewares/request-id",
          "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
        },
        {
          "originalPath": "5. Secure Headers.md",
          "id": 39,
          "name": "Secure Headers",
          "type": "file",
          "path": "middlewares/secure-headers",
          "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
        },
        {
          "originalPath": "6. XSS protection.md",
          "id": 40,
          "name": "XSS Protection",
          "type": "file",
          "path": "middlewares/xss-protection",
          "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```ts\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```ts\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```ts\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
        },
        {
          "originalPath": "7. Sanitize Headers.md",
          "id": 41,
          "name": "Sanitize Headers",
          "type": "file",
          "path": "middlewares/sanitize-headers",
          "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```ts\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```ts\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```ts\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```ts\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n```ts\n// Recommended security-focused setup\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    normalizeKeys: true,\n  }),\n);\n```\n\n2. **Information Hiding**:\n\n```ts\n// Hide server technology information\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
        },
        {
          "originalPath": "8. Rate Limiter.md",
          "id": 42,
          "name": "Rate Limiter",
          "type": "file",
          "path": "middlewares/rate-limiter",
          "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n**Note: It works with `app.use` api**\n\n## Installation\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```ts\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```ts\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```ts\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```ts\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({ error: `Try again in ${retryAfter} seconds` });\n  };\n  ```\n\n```ts\n\n  /**\n   * üîÑ Custom cache storage implementation (e.g., using `Map`, `Redis`, etc.).\n   * By default, it uses a `Map<string, { count: number; resetTime: number }>`.\n   */\n  storage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    clearExpired: () => void;\n  };\n\n```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```ts\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```ts\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      });\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n```ts\n// Planned future usage\napp.use(\n  rateLimiter({\n    maxRequests: 1000,\n    windowMs: 3600000,\n    storage: \"redis\",\n    redisClient: redis.createClient(),\n  }),\n);\n```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```ts\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```ts\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```ts\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
        },
        {
          "originalPath": "9. Pagination.md",
          "id": 43,
          "name": "Pagination",
          "type": "file",
          "path": "middlewares/pagination",
          "content": "# PaginationHandler Middleware\n\nThe `paginationHandler` middleware provides a robust and flexible solution for implementing pagination in web applications. It automates the handling of pagination parameters, integrates with dynamic data sources, and enriches responses with comprehensive metadata, enabling developers to efficiently manage paginated data retrieval and presentation.\n\n## Key Features\n\n- **Parameter Parsing**: Automatically extracts and sanitizes pagination parameters from query strings.\n- **Dynamic Data Fetching**: Supports integration with custom data sources for flexible data retrieval.\n- **Pagination Metadata**: Provides detailed information such as total items, total pages, and navigation links.\n- **Configurable Options**: Allows customization of defaults, limits, and response structure.\n- **Error Handling**: Ensures safe parsing and bounds checking for pagination inputs.\n\n## Import the middleware into your project\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n```\n\n## Configuration Options\n\nThe `paginationHandler` middleware accepts an optional `PaginationOptions` object to customize its behavior. The table below details all available options, their types, default values, and descriptions:\n\n| Option          | Type                                                                                                             | Default Value | Description                                                                                  |\n| --------------- | ---------------------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------------- |\n| `defaultPage`   | `number`                                                                                                         | `1`           | Default page number when not specified in the query.                                         |\n| `defaultLimit`  | `number`                                                                                                         | `10`          | Default number of items per page when not specified.                                         |\n| `maxLimit`      | `number`                                                                                                         | `100`         | Maximum allowed items per page to prevent excessive resource usage.                          |\n| `queryKeyPage`  | `string`                                                                                                         | `\"page\"`      | Query parameter name for the page number (e.g., `?page=2`).                                  |\n| `queryKeyLimit` | `string`                                                                                                         | `\"limit\"`     | Query parameter name for items per page (e.g., `?limit=20`).                                 |\n| `countKey`      | `string`                                                                                                         | `\"total\"`     | Key in the response object containing the total item count.                                  |\n| `dataKey`       | `string`                                                                                                         | `\"data\"`      | Key in the response object containing the paginated data array.                              |\n| `getDataSource` | `(ctx: Context, pagination: { page: number; limit: number; offset: number }) => Promise<{ [key: string]: any }>` | `undefined`   | Function to dynamically fetch paginated data and total count based on pagination parameters. |\n\n## Usage Examples\n\n### Basic Configuration\n\nApply the middleware to attach pagination context without a data source:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\napp.use(paginationHandler());\n\napp.get(\"/users\", (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  return ctx.json({\n    message: `Page ${page}, Limit ${limit}, Offset ${offset}`,\n  });\n});\n```\n\n- **Behavior**: Parses `page` and `limit` from the query string (e.g., `?page=2&limit=20`), sets defaults if omitted, and attaches pagination details to `ctx.pagination`.\n- **Sample Request**: `GET /users?page=2&limit=20`\n- **Response**:\n\n  ```json\n  {\n    \"message\": \"Page 2, Limit 20, Offset 20\"\n  }\n  ```\n\n### Advanced Configuration with Data Source\n\nIntegrate with a dynamic data source for full pagination functionality:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\n// Simulated database query (e.g., using Sequelize or similar ORM)\nasync function fetchProducts(\n  ctx: Context,\n  { page, limit, offset }: { page: number; limit: number; offset: number },\n) {\n  const products = await Product.findAll({\n    offset,\n    limit,\n  });\n  const total = await Product.count();\n  return { items: products, totalCount: total };\n}\n\napp.get(\n  \"/products\",\n  paginationHandler({\n    defaultPage: 1,\n    defaultLimit: 5,\n    maxLimit: 50,\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalCount\",\n    dataKey: \"items\",\n    getDataSource: fetchProducts,\n  }),\n  (ctx) => {\n    return ctx.json(ctx.body);\n  },\n);\n```\n\n- **Behavior**:\n  - Parses `p` and `size` from the query (e.g., `?p=2&size=10`).\n  - Limits `size` to 50 if exceeded.\n  - Fetches data using the provided `getDataSource` function.\n  - Returns a structured response with items, total count, and pagination metadata.\n- **Sample Request**: `GET /products?p=2&size=10`\n- **Response** (assuming 25 total products):\n\n  ```json\n  {\n    \"items\": [\n      /* array of 10 products */\n    ],\n    \"totalCount\": 25,\n    \"pagination\": {\n      \"page\": 2,\n      \"limit\": 10,\n      \"totalItems\": 25,\n      \"totalPages\": 3,\n      \"hasNextPage\": true,\n      \"hasPrevPage\": true,\n      \"nextPage\": 3,\n      \"prevPage\": 1\n    }\n  }\n  ```\n\n### Custom Response Structure\n\nCustomize the response keys for compatibility with existing APIs:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\nasync function fetchUsers(ctx: Context, { page, limit, offset }) {\n  const users = await User.findAll({ offset, limit });\n  const total = await User.count();\n  return { records: users, count: total };\n}\n\napp.get(\n  \"/users\",\n  paginationHandler({\n    countKey: \"count\",\n    dataKey: \"records\",\n    getDataSource: fetchUsers,\n  }),\n);\n```\n\n- **Behavior**: Uses `records` and `count` as keys instead of defaults.\n- **Sample Request**: `GET /users?page=1&limit=5`\n- **Response** (assuming 12 total users):\n\n  ```json\n  {\n    \"records\": [\n      /* array of 5 users */\n    ],\n    \"count\": 12,\n    \"pagination\": {\n      \"page\": 1,\n      \"limit\": 5,\n      \"totalItems\": 12,\n      \"totalPages\": 3,\n      \"hasNextPage\": true,\n      \"hasPrevPage\": false,\n      \"nextPage\": 2,\n      \"prevPage\": null\n    }\n  }\n  ```\n\n## Pagination Mechanism\n\n1. **Parameter Extraction**: Reads `queryKeyPage` and `queryKeyLimit` from the request query string.\n2. **Sanitization**: Ensures `page` is at least 1 and `limit` is between 1 and `maxLimit`.\n3. **Offset Calculation**: Computes `offset = (page - 1) * limit` for data retrieval.\n4. **Data Fetching**: Invokes `getDataSource` (if provided) with pagination details.\n5. **Metadata Generation**: Calculates total pages, navigation flags, and page links based on the total count.\n\n## Error Handling\n\n- **Invalid Inputs**: Non-numeric or negative `page` and `limit` values are coerced to defaults or bounds (e.g., `page < 1` becomes 1, `limit > maxLimit` becomes `maxLimit`).\n- **Missing Data Source**: If `getDataSource` is omitted, the middleware attaches pagination details to `ctx.pagination` and proceeds to the next handler.\n\n## Best Practices\n\n- **Set Reasonable Limits**: Configure `maxLimit` to balance performance and usability.\n- **Customize Keys**: Align `countKey` and `dataKey` with your API‚Äôs existing structure.\n- **Optimize Data Queries**: Ensure `getDataSource` leverages database-level pagination (e.g., `OFFSET` and `LIMIT` in SQL).\n- **Handle Edge Cases**: Test with empty datasets or extreme page numbers to verify behavior.\n\n## Sample Output\n\nFor a request to `/products?p=3&size=5` with 13 total items:\n\n```json\n{\n  \"items\": [\n    /* 3 products (offset 10-12) */\n  ],\n  \"totalCount\": 13,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 5,\n    \"totalItems\": 13,\n    \"totalPages\": 3,\n    \"hasNextPage\": false,\n    \"hasPrevPage\": true,\n    \"nextPage\": null,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "98. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Load Environment.md",
          "id": 44,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```ts\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```ts\n// For deno environment\nimport { loadEnv } from \"tezx/deno\";\n// For bun environment\nimport { loadEnv } from \"tezx/bun\";\n// For node environment\nimport { loadEnv } from \"tezx/node\";\n\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```ts\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.req.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```ts\nconst app = new Tezx<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```ts\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Tezx({\n  env,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```ts\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Tezx<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```ts\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Basic.md",
          "id": 45,
          "name": "Basic",
          "type": "file",
          "path": "examples/basic",
          "content": ""
        },
        {
          "originalPath": "1. Uploader.md",
          "id": 46,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
        },
        {
          "originalPath": "4. Basic Auth Client.md",
          "id": 47,
          "name": "Basic Auth Client",
          "type": "file",
          "path": "examples/basic-auth-client",
          "content": "### **1. Using cURL**\n\nYou can pass Basic Auth credentials using the `-u` flag in `cURL`. For example:\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\nAlternatively, you can manually set the `Authorization` header:\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\n**Explanation:**\n\n- The `-u` flag automatically encodes the `username:password` string in Base64.\n- The manual method uses `base64` to encode the credentials and sets the `Authorization` header explicitly.\n\n---\n\n### **2. Using Postman**\n\n1. Open Postman and create a new request.\n2. Go to the **Authorization** tab.\n3. Select **Basic Auth** from the dropdown menu.\n4. Enter the `username` and `password` in the respective fields.\n5. Click **Send**.\n\nPostman will automatically encode the credentials and add the `Authorization` header for you.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\nYou can pass Basic Auth credentials in JavaScript using the `fetch` API:\n\n```javascript\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n**Explanation:**\n\n- The `btoa` function encodes the `username:password` string in Base64.\n- The encoded string is added to the `Authorization` header.\n\n---\n\n### **4. Using Axios**\n\nIf you're using **Axios**, you can pass Basic Auth credentials like this:\n\n```javascript\nconst axios = require(\"axios\");\n\nconst username = \"admin\";\nconst password = \"password123\";\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username,\n      password,\n    },\n  })\n  .then((response) => console.log(response.data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n**Explanation:**\n\n- The `auth` option automatically encodes the credentials and adds the `Authorization` header.\n\n---\n"
        },
        {
          "originalPath": "5. SSE implement.md",
          "id": 48,
          "name": "SSE Implement",
          "type": "file",
          "path": "examples/sse-implement",
          "content": "\n# üì° `app.sse(path, handler)`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## ‚úÖ Syntax\n\n```ts\napp.sse(path: string, handler: (ctx: Context) => Promise<Response> | Response)\n```\n\n---\n\n## üß† Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n---\n\n## üì• Parameters\n\n| Name      | Type       | Description                                     |\n| --------- | ---------- | ----------------------------------------------- |\n| `path`    | `string`   | The route path (e.g. `/events`)                 |\n| `handler` | `Function` | An async or sync function that returns a stream |\n\n---\n\n## üì§ Returns\n\n* The route is registered to send `ReadableStream` data in SSE-compliant format (`data: ...\\n\\n`).\n* The handler must return a response with appropriate headers.\n\n---\n\n## üì¶ Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## üìã Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.sse(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## üß™ Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"üî¥ Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n\n## üö® Notes\n\n* Only supports `GET` method (per SSE spec).\n* Requires `ReadableStream` and `TextEncoder`, which are supported in Node.js 18+, Bun, and modern runtimes.\n* Don't forget to clear intervals/timers on disconnect via `ctx.rawRequest?.signal`.\n\n---\n\n## ‚úÖ Ideal Use Cases\n\n* Live notifications\n* Real-time clock or status updates\n* Live logs / debugging streams\n* Chat message delivery (broadcast style)\n\n---\n\n## üß© Coming Soon Ideas (optional for docs)\n\n> You can optionally add features like:\n\n* `ctx.pushSSE(data)` helper\n* Broadcasting across multiple connections\n* Named event support (`event: custom\\n`)\n\n---\n\n## üìò Summary\n\n`app.sse()` is the easiest way to build **real-time push updates** over HTTP with zero frontend dependencies.\n\n---\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "release-note/v200",
      "name": "V2.0.0üÜï",
      "folder": "Release Note",
      "content": "\n# üì¶ TezX 2.0.0 ‚Äî Modular Runtime Support\n\nTezX v2.0.0 introduces **runtime-aware modules** with clean separation of Node.js, Bun, and Deno environments.\n\n> üåü **Faster builds, smaller bundles, cleaner DX.**\n\n---\n\n## ‚úÖ Unified Yet Modular API\n\n### ‚ú® Import Based on Runtime\n\n| Runtime | Import From | Features                   |\n| ------- | ----------- | -------------------------- |\n| Node.js | `tezx/node` | `nodeAdapter`, `loadEnv()` |\n| Bun     | `tezx/bun`  | `bunAdapter`, `loadEnv()`  |\n| Deno    | `tezx/deno` | `denoAdapter`, `loadEnv()` |\n\n---\n\n## üìò Usage\n\n### ‚ñ∂Ô∏è Node.js\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/node\";\n\nconst env = loadEnv();\nconst app = nodeAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Hello from Node.js\"));\n```\n\n---\n\n### ‚ö° Bun\n\n```ts\nimport { bunAdapter, loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\nconst app = bunAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Powered by Bun!\"));\n```\n\n---\n\n### ü¶ï Deno\n\n```ts\nimport { denoAdapter, loadEnv } from \"tezx/deno\";\n\nconst env = loadEnv();\nconst app = denoAdapter();\n\napp.get(\"/\", (ctx) => ctx.text(\"Running in Deno\"));\n```\n\n> üîê Required for Deno:\n>\n> ```bash\n> deno run --allow-env --allow-net app.ts\n> ```\n\n---\n\n## üîç Migration Guide (v1 ‚Üí v2)\n\n### üîÅ Before (v1.x)\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/adapter\";\n```\n\n### ‚úÖ After (v2.0.0)\n\n```ts\nimport { nodeAdapter, loadEnv } from \"tezx/node\";\n```\n\n> Apply same for `bunAdapter` or `denoAdapter`.\n\n---\n\n## üéØ Why This Change?\n\n* ‚úÖ **Tree-shaking friendly**\n* ‚úÖ Smaller builds per runtime\n* ‚úÖ Platform-specific optimization\n* ‚úÖ Clear developer ergonomics\n* ‚úÖ Future plugin & extension readiness\n\n---\n"
    },
    {
      "id": 2,
      "path": "need-to-know",
      "name": "Need To Know",
      "folder": ".",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typecript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```ts\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```ts\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { nodeAdapter,loadEnv } from \"tezx/node\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { bunAdapter } from \"tezx/bun\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { denoAdapter } from \"tezx/deno\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true,\n    \"removeComments\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\",\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n````ts\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * üîÑ Hook to transform or normalize the incoming request pathname before routing.\n   *\n   * This function allows you to customize how incoming paths are handled.\n   * You can use it to:\n   * - Remove trailing slashes\n   * - Normalize casing\n   * - Rewrite certain paths dynamically\n   * - Add localization or versioning prefixes\n   *\n   * @example\n   * ```ts\n   * onPathResolve: (pathname) => pathname.replace(/\\/+$/, \"\").toLowerCase()\n   * ```\n   *\n   * @param pathname - The raw incoming request path (e.g., `/Api/Users/`)\n   * @returns The transformed or resolved path used for routing (e.g., `/api/users`)\n   */\n  onPathResolve?: (pathname: string) => string;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n````\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```ts\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```ts\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```ts\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n---\n\n### **6. `onPathResolve`**\n\n- **Type**: `Function`\n- **Default**: `undefined`\n- **Purpose**: Sets a custom path resolver function for route paths.\n- **Behavior**: Allows modification of the path before it is used for routing. The function receives the original path and returns a modified path, if needed.\n- **Example**:\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => {\n    if (path === \"/home\") return \"/\";\n    if (path === \"/user-profile\") return \"/profile\";\n    return path;\n  },\n});\n```\n\n---\n\n## **Usage Example with Routes**\n\n```ts\nimport { Router, TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport {loadEnv, denoAdapter } from \"tezx/deno\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n```ts\nconst logger = (msg: string) =>\n  console.log(`[${new Date().toISOString()}] ${msg}`);\n```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n```ts\nconst port = app.config.env.PORT || \"3000\";\n```\n\n---\n"
    },
    {
      "id": 5,
      "path": "adapter/bun/bun",
      "name": "Bun",
      "folder": "Adapter/Bun",
      "content": "## `bunAdapter` Documentation\n\n### **Overview**\n\n`bunAdapter` is a function that configures and runs a Bun server integrated with the TezX framework. It handles HTTP requests, WebSocket connections, and custom error handling. The server can be configured to run on a Unix socket or a TCP/IP port and supports advanced features like Hot Module Replacement (HMR), custom request handling, and WebSocket management.\n\n---\n\n### **Usage**\n\n```typescript\nimport { bunAdapter } from \"tezx/bun\";\nimport { TezX } from \"tezx\";\n\n// Example TezX instance\nconst TezXInstance = new TezX();\n\n// Server options\nconst serverOptions = {\n  unix: \"/tmp/tezx.sock\", // Listen on a Unix socket\n  maxRequestBodySize: 1024 * 1024 * 64, // 64MB max request body size\n  development: {\n    hmr: true, // Enable hot module replacement for development\n  },\n  port: 3000, // Listen on port 3000\n  tls: {\n    // Optional TLS configuration for secure server\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n\n// Initialize Bun adapter\nconst adapter = bunAdapter(TezXInstance, serverOptions);\n\n// Start the server\nadapter.listen(3000, () => {\n  console.log(\"Bun server is up and running!\");\n});\n```\n\n---\n\n### **API Documentation**\n\n#### **`bunAdapter` Function**\n\n##### **Parameters**\n\n- **TezX** (`TezX<T>`): The TezX framework instance you want to use for request handling.\n- **options** (`Object`): Configuration options for the server. Can include:\n\n  - **unix** (`string`): If set, the HTTP server will listen on a Unix socket instead of a TCP port. **Cannot be used with `port`**.\n  - **maxRequestBodySize** (`number`): Maximum size of a request body (in bytes). Default is 128MB (`1024 * 1024 * 128`).\n  - **development** (`boolean | Object`): Configuration for development mode.\n\n    - **hmr** (`boolean`): If set to true, enables Hot Module Replacement (HMR) for routes (especially useful for React projects).\n\n  - **error** (`Function`): A custom error handler function that will be invoked when an error occurs.\n\n    - **Arguments**:\n      - `s`: Bun's `serve` instance.\n      - `error`: The `Error` object.\n\n  - **port** (`string | number`): The port number on which the server should listen. Defaults to `process.env.PORT` or `3000`.\n  - **hostname** (`string`): The hostname the server should listen on. Defaults to `0.0.0.0` (all interfaces).\n  - **tls** (`Bun.TLSOptions | Bun.TLSOptions[]`): Optional configuration for TLS/SSL certificates to enable HTTPS.\n  - **idleTimeout** (`number`): The number of seconds to wait before timing out a connection due to inactivity. Defaults to `10` seconds.\n  - **reusePort** (`boolean`): Whether the `SO_REUSEPORT` flag should be set to allow multiple processes to bind to the same port for load balancing.\n  - **ipv6Only** (`boolean`): If set to true, the server will only listen on IPv6 addresses.\n\n##### **Returns**\n\n- An object with a `listen` method, which starts the server.\n\n#### **`listen` Method**\n\n##### **Parameters**\n\n- **port** (`number`): The port number on which the server should listen.\n- **callback** (`Function` | `undefined`): An optional callback function that will be invoked after the server has started successfully.\n\n##### **Description**\n\n- The `listen` method starts the Bun server with the configured options. It listens either on a Unix socket or a TCP port (based on the configuration) and handles HTTP requests and WebSocket connections.\n- If the `unix` option is provided, the server listens on a Unix socket and does not use a TCP port. If `unix` is not provided, the server listens on the specified port or defaults to port `3000`.\n\n- The server can handle both HTTP requests and WebSocket connections, delegating requests to the TezX instance for processing.\n\n---\n\n### **WebSocket Handling**\n\nThe Bun server supports WebSocket connections and provides custom WebSocket handlers:\n\n- **open(ws)**: Called when a WebSocket connection is opened.\n- **message(ws, msg)**: Called when a message is received from the WebSocket client.\n- **close(ws, code, reason)**: Called when the WebSocket connection is closed.\n- **ping(ws, data)**: Called when a ping frame is received.\n- **pong(ws, data)**: Called when a pong frame is received.\n- **drain(ws)**: Called when the WebSocket‚Äôs message queue is drained.\n\n---\n\n### **Error Handling**\n\nYou can customize the error handling by providing an `error` handler in the options:\n\n```typescript\nconst serverOptions = {\n  error: (server: Bun.Serve, error: Error) => {\n    // Custom error handling logic\n    console.error(\"An error occurred:\", error);\n    return new Response(\"Internal Server Error\", { status: 500 });\n  },\n};\n```\n\n---\n\n### **Development Mode (HMR)**\n\nFor development purposes, you can enable Hot Module Replacement (HMR), which allows for live reloading of routes without restarting the server. This is especially useful when building single-page applications (SPAs) with frameworks like React.\n\nTo enable HMR:\n\n```typescript\nconst serverOptions = {\n  development: {\n    hmr: true, // Enables HMR for React or other frameworks\n  },\n};\n```\n\n---\n\n### **TLS Configuration**\n\nIf you need to serve the application over HTTPS, you can specify TLS options in the configuration:\n\n```typescript\nconst serverOptions = {\n  tls: {\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n```\n\n---\n\n### **Example Configuration:**\n\n```typescript\nimport { bunAdapter } from \"tezx/bun\";\nimport { TezX } from \"tezx\";\n\nconst TezXInstance = new TezX();\n\nconst serverOptions = {\n  unix: \"/tmp/tezx.sock\", // Listen on Unix socket\n  maxRequestBodySize: 1024 * 1024 * 64, // Limit body size to 64MB\n  development: {\n    hmr: true, // Enable HMR for development\n  },\n  error: (server, error) => {\n    console.error(error);\n    return new Response(\"An error occurred\", { status: 500 });\n  },\n  tls: {\n    cert: \"path/to/cert.pem\",\n    key: \"path/to/key.pem\",\n  },\n};\n\nconst adapter = bunAdapter(TezXInstance, serverOptions);\n\nadapter.listen(3000, () => {\n  console.log(\"Server is running at http://localhost:3000\");\n});\n```\n\n---\n"
    },
    {
      "id": 6,
      "path": "adapter/bun/bun-configure",
      "name": "Bun Configure",
      "folder": "Adapter/Bun",
      "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun;\nnpm install @types/bun;\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { bunAdapter ,loadEnv} from \"tezx/bun\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
    },
    {
      "id": 7,
      "path": "adapter/deno/deno",
      "name": "Deno",
      "folder": "Adapter/Deno",
      "content": "## `denoAdapter` Documentation\n\n### **Overview**\n\nThe `denoAdapter` function is designed to adapt the TezX framework to the Deno runtime. It allows you to run a TezX-powered server on Deno, supporting both Unix socket and TCP/IP transport methods, with optional TLS encryption for secure communication.\n\n---\n\n### **Key Features**\n\n1. **Cross-Platform Support**: Works on both Unix sockets (`unix`) and TCP/IP (`tcp`) transport.\n2. **TLS/SSL Support**: Secure communication via HTTPS if TLS certificates are provided.\n3. **Flexible Configuration**: Allows custom configurations such as port, transport, and TLS settings.\n4. **Easy Integration**: Integrates seamlessly with the TezX framework, handling incoming requests and responses.\n5. **Logging & Debugging**: Logs server startup information with clear success messages, including protocol and address.\n\n---\n\n### **Usage Example**\n\n#### **1. Basic Setup**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX server instance\nconst app = new TezX();\n\n// Configure server options\nconst serverOptions = {\n  transport: \"tcp\", // Listen on TCP transport\n  port: 3000, // Port number\n};\n\n// Initialize Deno adapter with TezX instance and server options\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server and log success\nadapter.listen(3000, () => {\n  console.log(\"Deno server running on TCP at port 3000\");\n});\n```\n\n#### **2. Setup with TLS (Secure Server)**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX instance\nconst app = new TezX();\n\n// TLS configuration (certificate and key for HTTPS)\nconst serverOptions = {\n  transport: \"tcp\", // Listen on TCP\n  port: 443, // HTTPS port\n  tls: {\n    cert: \"path/to/cert.pem\", // Path to TLS certificate\n    key: \"path/to/key.pem\", // Path to private key\n  },\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server\nadapter.listen(443, () => {\n  console.log(\"Secure Deno server running on HTTPS port 443\");\n});\n```\n\n#### **3. Setup with Unix Socket**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\n// Initialize TezX instance\nconst app = new TezX();\n\n// Unix socket configuration\nconst serverOptions = {\n  transport: \"unix\", // Listen on Unix socket\n  path: \"/tmp/tezx.sock\", // Path to the Unix socket\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the server\nadapter.listen(undefined, () => {\n  console.log(\"Deno server running on Unix socket /tmp/tezx.sock\");\n});\n```\n\n---\n\n### **API Documentation**\n\n#### **`denoAdapter` Function**\n\n##### **Parameters**\n\n- **`TezX`** (`TezX<T>`): The TezX instance that handles the incoming requests.\n- **`options`** (`Deno.ServeUnixOptions | Deno.ServeTcpOptions | (Deno.ServeTcpOptions & Deno.TlsCertifiedKeyPem)`):\n  - **`transport`** (`string`): Specifies the transport method. Acceptable values:\n    - `\"unix\"`: Use Unix socket for communication.\n    - `\"tcp\"`: Use TCP/IP for communication (default if no transport is specified).\n  - **`port`** (`number`): The port number on which the server should listen (required for `\"tcp\"`).\n  - **`path`** (`string`): The file path to the Unix socket (required for `\"unix\"` transport).\n  - **`tls`** (`Deno.TlsCertifiedKeyPem`): Optional configuration for enabling TLS encryption. If provided, the server will run over HTTPS:\n    - **`cert`** (`string`): Path to the TLS certificate file.\n    - **`key`** (`string`): Path to the private key file.\n\n##### **Returns**\n\nAn object with a `listen` method for starting the server.\n\n#### **`listen` Method**\n\n##### **Parameters**\n\n- **`port`** (`number | undefined`): The port on which to start the server (used for TCP transport only). It is ignored for Unix socket transport.\n- **`callback`** (`Function | undefined`): A callback function that will be executed when the server starts.\n\n##### **Description**\n\nThe `listen` method starts the server based on the provided configuration. It will:\n\n- Bind the server to a TCP/IP port or Unix socket.\n- Enable TLS encryption if TLS certificates are provided.\n- Use the TezX framework to process requests.\n- Log success messages to the console, including the server's transport protocol and address.\n\n##### **Error Handling**\n\n- **`Error: Deno is not found`**: Thrown if the Deno environment is not detected.\n- **Other Errors**: Any issues encountered during server setup will throw a relevant error message (e.g., invalid transport configuration, missing TLS files, etc.).\n\n---\n\n### **Detailed Flow**\n\n1. **Server Configuration**:\n\n   - Based on the provided `options`, the `denoAdapter` function will set up a server that listens either on a TCP/IP port or a Unix socket.\n   - If no `tls` option is provided, the server runs over HTTP (TCP), otherwise, it will run over HTTPS (TCP with TLS certificates).\n\n2. **Request Handling**:\n\n   - The server listens for incoming requests. The `handleRequest` function is called for each request.\n   - The `handleRequest` function processes each request and prepares a response using TezX. It constructs a response that includes headers, status code, and body.\n\n3. **Logging and Debugging**:\n\n   - Upon server startup, a success message is logged to the console, indicating the protocol (HTTP or HTTPS) and the server's address/port or Unix socket path.\n   - This message is color-coded to make it easy to spot in the logs.\n\n4. **Error Handling**:\n   - If the server encounters issues, such as missing configuration or invalid transport type, appropriate error messages are thrown.\n   - The `Deno is not found` error ensures the server can only run in the Deno runtime environment.\n\n---\n\n### **Additional Notes**\n\n- **Security Considerations**:\n\n  - If using TLS, ensure that the certificate (`cert`) and key (`key`) files are secured and not exposed to the public.\n  - The `cert` and `key` files should be stored in a secure directory with limited access permissions.\n\n- **Debugging**:\n\n  - The logging message is colorful and easy to distinguish, providing quick insights into the server‚Äôs state.\n  - For development purposes, the log also shows the address and port of the server.\n\n- **Scalability**:\n\n  - This setup is ideal for small to medium-sized projects, and can be easily scaled by adjusting the server settings or adding additional features.\n\n- **Unix Socket**:\n  - Unix sockets are useful for communication between processes on the same machine. This method is typically faster than TCP for local communication.\n\n---\n\n### **Example: Running a Production-Ready Secure Server**\n\n```typescript\nimport { denoAdapter } from \"tezx/deno\";\nimport { TezX } from \"tezx\";\n\nconst app = new TezX();\n\n// Production TLS options\nconst serverOptions = {\n  transport: \"tcp\",\n  port: 443, // HTTPS\n  tls: {\n    cert: \"/etc/ssl/certs/tezx-cert.pem\", // Path to certificate\n    key: \"/etc/ssl/private/tezx-key.pem\", // Path to private key\n  },\n};\n\n// Initialize Deno adapter\nconst adapter = denoAdapter(app, serverOptions);\n\n// Start the secure server\nadapter.listen(443, () => {\n  console.log(\"Secure TezX server running on HTTPS port 443\");\n});\n```\n\n---\n"
    },
    {
      "id": 8,
      "path": "adapter/deno/deno-configure",
      "name": "Deno Configure",
      "folder": "Adapter/Deno",
      "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```ts\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```ts\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```ts\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
    },
    {
      "id": 9,
      "path": "adapter/node/node",
      "name": "Node",
      "folder": "Adapter/Node",
      "content": "# üìÑ `nodeAdapter` ‚Äì Node.js Adapter for TezX\n\n### Overview\n\nThe `nodeAdapter` function bridges your `TezX` application to the native Node.js HTTP or HTTPS server, allowing you to serve requests via:\n\n- A **regular TCP port**\n- A **Unix domain socket**\n- Optionally, a **TLS-encrypted (HTTPS)** server\n\nIt provides flexibility for development and production environments, including support for WebSockets and streaming responses.\n\n---\n\n## ‚úÖ Function Signature\n\n```ts\nfunction nodeAdapter<T extends Record<string, any> = {}>(\n  TezX: TezX<T>,\n  options?: TezXServerOptions,\n): {\n  listen(port?: number, callback?: (msg: string) => void): void;\n};\n```\n\n---\n\n## üîß Parameters\n\n### 1. `TezX`\n\n- Type: `TezX<T>`\n- Description: Your TezX application instance that handles HTTP and WebSocket requests.\n\n### 2. `options` (optional)\n\n- Type: `TezXServerOptions` (see below)\n- Description: Configuration options for the Node.js HTTP/HTTPS server.\n\n#### Type: `TezXServerOptions`\n\n```ts\ntype UnixSocketOptions = ServerOptions & {\n  unix?: string;\n  enableSSL?: false;\n};\n\ntype SSLOptions = ServerOptions &\n  TlsOptions & {\n    enableSSL: true;\n  };\n\ntype TezXServerOptions = UnixSocketOptions | SSLOptions;\n```\n\n#### Common `ServerOptions` and `TlsOptions` include\n\n- `cert`: path to TLS certificate (required for HTTPS)\n- `key`: path to TLS private key (required for HTTPS)\n- `requestTimeout`, `keepAlive`, `noDelay`: optional server settings\n\n---\n\n## ‚ñ∂Ô∏è `listen()` Method\n\n### Parameters\n\n- `port` _(optional)_: `number` ‚Äì Port to bind the server (ignored if `unix` is specified).\n- `callback` _(optional)_: `(msg: string) => void` ‚Äì Function called when the server starts.\n\n### Returns\n\n- Starts the server and logs a formatted message to the console. Stores the server instance in `GlobalConfig.server`.\n\n---\n\n## üí° Features\n\n| Feature           | Description                                                                |\n| ----------------- | -------------------------------------------------------------------------- |\n| üîÅ Dual Transport | Supports TCP (`port`) or Unix socket (`unix`)                              |\n| üîê TLS Support    | Enables HTTPS with `cert` and `key` options                                |\n| üß† WebSockets     | Automatically upgrades WS requests if supported by the TezX response       |\n| üì¶ Streaming      | Pipes `Readable` streams from `Response.body` to the client                |\n| ‚ö†Ô∏è Error Handling | Throws clear errors for misconfigurations and unsupported environments     |\n| üñ•Ô∏è Color Logs     | Displays a colorful message when the server starts (protocol + URL/socket) |\n\n---\n\n## üß™ Example Usages\n\n### ‚úÖ Basic HTTP Server\n\n```ts\nconst adapter = nodeAdapter(app);\nadapter.listen(3000, (msg) => {\n  console.log(msg);\n});\n```\n\n### üîí HTTPS Server\n\n```ts\nconst adapter = nodeAdapter(app, {\n  enableSSL: true,\n  key: fs.readFileSync(\"certs/key.pem\"),\n  cert: fs.readFileSync(\"certs/cert.pem\"),\n});\nadapter.listen(443, (msg) => {\n  console.log(msg);\n});\n```\n\n### üõ†Ô∏è Unix Socket Server\n\n```ts\nconst adapter = nodeAdapter(app, {\n  unix: \"/tmp/tezx.sock\",\n});\nadapter.listen(() => {\n  console.log(\"Server running on /tmp/tezx.sock\");\n});\n```\n\n---\n\n## üîÅ WebSocket Handling (via TezX)\n\nHandlers supported: `open`, `message`, `close`, `ping`, `pong`, `drain`.\n\n**See websocket documentation**\n\n---\n\n## üìù Notes\n\n- You must use `enableSSL: true` to enable `https`. Without this, it defaults to HTTP.\n- If using Unix sockets, `port` will be ignored.\n- `listen()` uses dynamic `import(\"node:http\")` or `import(\"node:https\")` to load only the necessary module.\n- `TezX.serve()` must return either a `Response` or a compatible object with `.websocket()` and `.ctx`.\n\n---\n\n## üßØ Error Handling\n\n- If `TezX.serve()` does **not** return a valid `Response`, it throws:\n\n```bash\n  Error: Invalid response from TezX.serve\n```\n\n- If `import(\"node:http\")` or `import(\"node:https\")` fails, the error is caught and logged.\n\n---\n\n## ‚úÖ Output Example\n\nWhen the server starts successfully, you'll see:\n\n```bash\nNodeJS TezX Server running at http://localhost:3000/\n```\n\nOr for HTTPS:\n\n```bash\nNodeJS TezX Server running at https://localhost:443/\n```\n\nOr for Unix socket:\n\n```bash\nNodeJS TezX Server running at unix:///tmp/tezx.sock\n```\n\n---\n"
    },
    {
      "id": 10,
      "path": "adapter/node/node-configure",
      "name": "Node Configure",
      "folder": "Adapter/Node",
      "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx;\nnpm install @types/node;\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX } = require(\"tezx\");\nconst { logger } = require(\"tezx/middleware\");\nconst { nodeAdapter, loadEnv } = require(\"tezx/node\");\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"skipLibCheck\": true,\n    \"removeComments\": false,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\",\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/middleware-api/merging-middlewares",
      "name": "Merging Middlewares",
      "folder": "API/Middleware API",
      "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```ts\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n```ts\nconst app = new TezX({ allowDuplicateMw: false });\n```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n```ts\napp.use(\"/test\", (ctx, next) => {\n  logger().info(\"Middleware m1\");\n  return next();\n});\n```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
    },
    {
      "id": 12,
      "path": "api/middleware-api/middleware",
      "name": "Middleware",
      "folder": "API/Middleware API",
      "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```ts\nexport type Middleware<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => Promise<Response | void> | Response | NextCallback;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` or `await next()` (to continue), a `Response`, or a `Promise<Response>`.\n\n#### **Example**\n\n```ts\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  await next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n**Must be use return**\n\n```ts\nexport type CallbackReturn = Promise<Response> | Response;\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => CallbackReturn;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `Response` or `Promise<Response>`.\n\n#### **Example**\n\n```ts\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```ts\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.req.headers.get(\"Authorization\"));\n    await next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```ts\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```ts\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```ts\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```ts\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```ts\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```ts\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```ts\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n    await next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```ts\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  await next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```ts\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```ts\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n```ts\nserver\n  .use(syncOperation) // Fast sync task\n  .use(asyncMiddleware); // Slower async task\n```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n```ts\n// ‚ùå Avoid\napp.use(async (ctx, next) => {\n  await processLargeFile();\n  return next();\n});\n\n// ‚úÖ Prefer\napp.get(\"/process\", (ctx) => processLargeFile());\n```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n```ts\napp.use((ctx, next) => {\n  ctx.cachedData = expensiveOperation();\n  return next();\n});\n\napp.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `Response`.               |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
    },
    {
      "id": 13,
      "path": "api/router/router-merging",
      "name": "Router Merging",
      "folder": "API/Router",
      "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```ts\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```ts\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n```ts\napp.get(\"/test\", (ctx) => {\n  logger().info(\"Original /test handler\");\n  return ctx.text(\"Handler 1\");\n});\n```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n```ts\nconsole.log(app.routes); // Inspect route tree (if exposed)\n```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
    },
    {
      "id": 14,
      "path": "api/router/router-api",
      "name": "Router API",
      "folder": "API/Router",
      "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```bash\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```ts\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```ts\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```ts\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```ts\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```ts\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```ts\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```ts\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
    },
    {
      "id": 15,
      "path": "api/router/route-parameter",
      "name": "Route Parameter",
      "folder": "API/Router",
      "content": "# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```ts\n\"/path/:parameterName\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```ts\n\"/path/:optionalParam?\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```ts\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```ts\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```ts\napp.get(\"/users/id/:id\", handleUser); // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```ts\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```ts\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n```ts\napp.get(\"/api/static\", handleStatic);\napp.get(\"/api/:id\", handleDynamic);\n```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n```ts\nconst id = parseInt(ctx.req.params.id);\nif (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n```\n\n3. **Limit Optional Parameters**\n\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n```ts\n// Matches /api/v1/2023/users or /api/v1/users\napp.get(\"/api/v1/:version?/:resource\", handleApi);\n```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n```ts\napp.get(\"/files/images/:id\", handleImage);\napp.get(\"/files/*path\", handleFile);\n```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```ts\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n| -------- | -------------------- | ---------------------------------- |\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```ts\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method, // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```ts\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods     | Custom Examples  |\n| -------------------- | ---------------- |\n| `GET`, `POST`, `PUT` | `PURGE`, `LOCK`  |\n| `PATCH`, `DELETE`    | `COPY`, `SEARCH` |\n| `HEAD`, `OPTIONS`    | `CUSTOM_API`     |\n\n### **Examples**\n\n#### **Custom Method**\n\n```ts\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```ts\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```ts\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```ts\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"]; // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method               | Path           | Priority | Match Example      |\n| -------------------- | -------------- | -------- | ------------------ |\n| `get()`              | `/cache/clear` | Highest  | `GET /cache/clear` |\n| `addMethod(\"PURGE\")` | `/cache`       | High     | `PURGE /cache`     |\n| `all()`              | `/cache/*`     | Medium   | `POST /cache/123`  |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n```ts\napp.get(\"/api\", specificHandler); // Higher priority\napp.all(\"/*api\", globalMiddleware); // Lower priority\n```\n\n---\n"
    },
    {
      "id": 16,
      "path": "api/context/context-api",
      "name": "Context API",
      "folder": "API/Context",
      "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```ts\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```ts\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```ts\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```ts\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```ts\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```ts\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```ts\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```ts\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```ts\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
    },
    {
      "id": 17,
      "path": "api/context/advanced-context",
      "name": "Advanced Context",
      "folder": "API/Context",
      "content": "# **Advanced Context**\n\n### üîß `ctx.body` ‚Äì Passing Data Between Middlewares and Fallback Response\n\n#### Overview\n\n`ctx.body` is a powerful mechanism used to **pass data between middlewares** or to define a **fallback response** when no explicit `Response` is returned. It simplifies middleware handling and automatically wraps the body into a `Response` if no response is explicitly provided.\n\n---\n\n### üß† Core Concept of `ctx.body`\n\n1. **Middleware-to-Middleware Communication**  \n   `ctx.body` serves as a shared state, passing data between multiple middleware functions. You can set data in one middleware and access it in the next.\n\n2. **Automatic Fallback Response**  \n   If no explicit `Response` is returned from a route handler or middleware, the framework automatically checks `ctx.body`. If `ctx.body` contains data, it is automatically wrapped into a `Response` and returned.\n\n---\n\n### üß™ How It Works\n\n- **Setting `ctx.body`:**  \n  When you set `ctx.body` in any middleware or route handler, the framework will automatically handle the response if nothing else is returned.\n\n- **Return Behavior:**  \n  If no `Response` is explicitly returned, `ctx.body` will be wrapped in an appropriate `Response` object:\n  - If `ctx.body` is a string, it will be treated as `text/plain`.\n  - If `ctx.body` is an object, it will be treated as `application/json`.\n  - If `ctx.body` is `undefined`, it will result in an error.\n\n---\n\n### üìÑ API\n\n#### Setter\n\n```ts\nset body(value: any)\n```\n\n- Stores any value in the context body.\n- Overwrites previous value if set again.\n\n#### Getter\n\n```ts\nget body(): any\n```\n\n- Retrieves the current value of the context body.\n\n---\n\n### ‚öôÔ∏è How It Works Internally\n\n```ts\nif (!response) {\n  if (ctx.body) {\n    return ctx.send(ctx.body); // auto-wraps body into a Response\n  } else {\n    throw new Error(\"No response or body set\");\n  }\n}\n```\n\n---\n\n### üìÑ Example Code for `ctx.body`\n\n#### Basic Example\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  // No need to return a Response here; it will be inferred.\n  return (ctx.body = \"Hello, world!\" as any);\n});\n```\n\nIn this example:\n\n- `ctx.body = \"Hello, world!\"` sets the response body.\n- The framework will automatically return a `Response` with `text/plain` as the content type.\n\n#### Example with JSON Response\n\n```ts\napp.get(\"/status\", (ctx) => {\n  // It will be automatically returned as JSON\n  return (ctx.body = { success: true, version: \"1.0.0\" } as any);\n});\n```\n\nHere:\n\n- `ctx.body` is set to an object. It will be automatically returned as `application/json`.\n\n#### Middleware Example\n\n```ts\napp.use(async (ctx, next) => {\n  // Set data in ctx.body\n  ctx.body = { user: await getUserData(ctx) };\n  return next(); // Pass to next middleware or final handler\n});\n\napp.use(async (ctx) => {\n  // Modify ctx.body in another middleware\n  ctx.body.token = await generateToken(ctx.body.user);\n  return ctx.body as any; // Directly return ctx.body\n});\n```\n\nIn this example:\n\n- The `ctx.body` is shared between two middleware functions. The first sets user data, and the second adds a token before returning the response.\n\n**Response**:\n\n```json\n{ \"user\": 6563, \"token\": 3545 }\n```\n\n#### Handling with `next()`\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.body = { status: \"Processing\" };\n  return await next(); // Move to next middleware and always return keyword use\n});\n\napp.get(\"/complete\", (ctx) => {\n  ctx.body = { status: \"Complete\", result: \"Success\" };\n  return ctx.body as any; // Send final response\n});\n```\n\nHere:\n\n- `ctx.body` is modified by each middleware, and the final response is sent at the end of the chain.\n\n---\n\n### üßØ Best Practices for Using `ctx.body`\n\n1. **Always return `next()` in middleware when you are not finishing the request.**\n\n   - If you don‚Äôt explicitly return a `Response`, use `return next()` to let the next middleware or handler process the request.\n\n2. **Ensure `ctx.body` is properly set if you're relying on it for a fallback response.**\n\n   - If no `Response` is returned and `ctx.body` is empty or undefined, the request will fail.\n\n3. **Use `ctx.body` for response construction but avoid relying on it for complex responses like file downloads or streaming.**\n   - For advanced responses like file streaming or complex headers, it's better to manually handle the response rather than rely on `ctx.body`.\n\n---\n\n### ‚öôÔ∏è Advanced Example with Error Handling\n\n```ts\napp.use(async (ctx, next) => {\n  try {\n    ctx.body = await someAsyncOperation();\n    return await next(); // Pass to next middleware\n  } catch (error) {\n    ctx.status = 500; // Set error status code\n    return (ctx.body = { error: \"Something went wrong\" } as any);\n  }\n});\n\napp.get(\"/data\", (ctx) => {\n  // If an error occurred in previous middleware, it will automatically return the error response\n  return ctx.body as any;\n});\n```\n\nIn this case:\n\n- If an error happens in `someAsyncOperation()`, it sets `ctx.body` to an error message, and the error response is automatically returned.\n\n---\n\n### üß† Summary\n\n| Feature                              | Supported          |\n| ------------------------------------ | ------------------ |\n| Acts as a shared state               | ‚úÖ                 |\n| Automatic fallback response          | ‚úÖ                 |\n| Works with strings, objects, streams | ‚úÖ (if supported)  |\n| Replaces `return Response`           | ‚úÖ in simple cases |\n\n---\n"
    },
    {
      "id": 18,
      "path": "api/context/state",
      "name": "State",
      "folder": "API/Context",
      "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```ts\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```ts\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```ts\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```ts\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```ts\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```ts\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n```ts\nctx.state.set(\"auth:user\", authenticatedUser);\n```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n```ts\nctx.state.delete(\"temporaryData\");\n```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n```ts\ninterface AppState {\n  user?: { id: number; name: string };\n  requestId?: string;\n}\n\nctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.state.set(\"startTime\", Date.now());\n  await next();\n});\n\napp.get(\"/test\", (ctx) => {\n  const elapsed = Date.now() - ctx.state.get(\"startTime\");\n  return ctx.json({ elapsed });\n});\n```\n\n---\n"
    },
    {
      "id": 19,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```ts\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```ts\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```ts\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```ts\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
    },
    {
      "id": 20,
      "path": "api/context/cookies",
      "name": "Cookies",
      "folder": "API/Context",
      "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```ts\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n```ts\nconst session = ctx.cookies.get(\"sessionToken\");\nif (!session) return ctx.status(401).json({ error: \"No session\" });\n```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n```ts\nctx.cookies.set(\"key\", \"value\");\nlogger().info(\"Cookie set: key\");\n```\n\n---\n"
    },
    {
      "id": 21,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```ts\ninterface UrlRef {\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```ts\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```ts\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```ts\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```ts\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```ts\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
    },
    {
      "id": 22,
      "path": "api/request/body-parser",
      "name": "Body Parser",
      "folder": "API/Request",
      "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```ts\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```ts\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```ts\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```ts\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n```ts\nconst stream = file.stream();\nconst transformer = new TransformStream();\n// Process stream\n```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n```ts\nconst form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n```ts\nctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```ts\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```ts\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
    },
    {
      "id": 23,
      "path": "api/response/response",
      "name": "Response",
      "folder": "API/Response",
      "content": "# **Response**\n\n---\n\n### **Type Definitions**\n\n```typescript\nexport type NextCallback = () => Promise<any>;\n\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => Promise<Response> | Response;\n```\n\n- **`NextCallback`**: A function returning a `Promise` for middleware chaining.\n- **`Callback<T>`**: A handler function that can return:\n  - `Promise<Response>`: Asynchronous response or no response.\n  - `Response`: A native HTTP response object.\n\n---\n\n## **Custom Response**\n\nFor fine-grained control, return a native `Response` object directly:\n\n```typescript\napp.get(\"/data\", async (ctx: ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## **Response Methods**\n\n### **`json`**\n\n#### **Description**\n\nSerializes and sends a JSON response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  return ctx.json({ message: \"Success\" }, 200);\n});\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  return ctx.html(\"<h1>Hello</h1>\", 200);\n});\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  return ctx.text(\"Hello, World!\", 200);\n});\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  return ctx.xml(\"<note><msg>Hello</msg></note>\", 200);\n});\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type inference.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (e.g., `string`, `object`).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with inferred `Content-Type`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  return ctx.send(\"Custom Content\", 200);\n});\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Location` header.\n\n#### **Usage**\n\n```typescript\napp.get(\"/redirect\", (ctx: ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nTriggers a file download.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name for the downloaded file.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/download\", async (ctx: ctx) => {\n  return ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n});\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream.\n\n#### **Usage**\n\n```typescript\napp.get(\"/file\", async (ctx: ctx) => {\n  return ctx.sendFile(\"/path/to/image.jpg\");\n});\n```\n\n---\n"
    },
    {
      "id": 24,
      "path": "api/headers-api/request-headers",
      "name": "Request Headers",
      "folder": "API/Headers API",
      "content": "\n# `ctx.req.headers` API\n\n## Overview\n\n`ctx.req.headers` provides a **read-only**, case-insensitive, iterable interface for inspecting HTTP request headers in a structured and consistent way.\n\nThis API is designed to:\n\n* Safely access request headers\n* Normalize case handling\n* Support iteration\n* Enable easy debugging via `.toJSON()`\n\n---\n\n## Interface\n\n```ts\nctx.req.headers: {\n  get(key: string): string | null;\n  has(key: string): boolean;\n  entries(): HeadersIterator<[string, string]>;\n  keys(): HeadersIterator<string>;\n  values(): HeadersIterator<string>;\n  forEach(callbackfn: (value: string, key: string, parent: Headers) => void): void;\n  toJSON(): Record<string, string>;\n}\n```\n\n---\n\n## Methods\n\n### ‚ñ∏ `get(key: string): string | null`\n\nRetrieves the first value for a given header.\n\n* **Params:** `key` ‚Äî Header name (case-insensitive)\n* **Returns:** The first header value, or `null` if not found\n\n```ts\nconst type = ctx.req.headers.get(\"content-type\");\n// \"application/json\"\n```\n\n---\n\n### ‚ñ∏ `has(key: string): boolean`\n\nChecks whether a header exists in the request.\n\n* **Params:** `key` ‚Äî Header name (case-insensitive)\n* **Returns:** `true` if the header is present, `false` otherwise\n\n```ts\nif (ctx.req.headers.has(\"authorization\")) {\n  console.log(\"Auth header found.\");\n}\n```\n\n---\n\n### ‚ñ∏ `entries(): HeadersIterator<[string, string]>`\n\nIterates over `[key, value]` pairs for each header.\n\n* **Returns:** An iterator of header entries\n\n```ts\nfor (const [key, value] of ctx.req.headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n```\n\n---\n\n### ‚ñ∏ `keys(): HeadersIterator<string>`\n\nIterates over all header names.\n\n* **Returns:** An iterator of header names\n\n```ts\nfor (const key of ctx.req.headers.keys()) {\n  console.log(`Header name: ${key}`);\n}\n```\n\n---\n\n### ‚ñ∏ `values(): HeadersIterator<string>`\n\nIterates over all header values.\n\n* **Returns:** An iterator of string values\n\n```ts\nfor (const value of ctx.req.headers.values()) {\n  console.log(`Value: ${value}`);\n}\n```\n\n---\n\n### ‚ñ∏ `forEach(callback: (value, key, parent) => void): void`\n\nRuns a callback for each header.\n\n* **Params:**\n\n  * `callbackfn` ‚Äî Function that receives:\n\n    * `value`: string\n    * `key`: string\n    * `parent`: Headers\n\n```ts\nctx.req.headers.forEach((value, key) => {\n  console.log(`${key}: ${value}`);\n});\n```\n\n---\n\n### ‚ñ∏ `toJSON(): Record<string, string>`\n\nConverts headers to a plain object with values joined (if multiple).\n\n* **Returns:** An object representation of headers.\n\n```ts\nconsole.log(ctx.req.headers.toJSON());\n// { \"accept\": \"text/html,application/json\", \"user-agent\": \"Mozilla/...\" }\n```\n\n---\n\n## Characteristics\n\n| Feature          | Description                    |\n| ---------------- | ------------------------------ |\n| Immutable        | Read-only access               |\n| Case-insensitive | Keys normalized to lowercase   |\n| Iterable         | Supports entries, keys, values |\n| JSON-ready       | `toJSON()` for debugging/logs  |\n\n---\n\n## Example Use Cases\n\n### üîê Authorization Guard\n\n```ts\napp.use((ctx) => {\n  if (!ctx.req.headers.has(\"authorization\")) {\n    return ctx.text(\"Unauthorized\", 401);\n  }\n});\n```\n\n### üìã Logging Incoming Headers\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"Headers:\", ctx.req.headers.toJSON());\n  return next();\n});\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "api/headers-api/response-headers",
      "name": "Response Headers",
      "folder": "API/Headers API",
      "content": "# Response Headers\n\n## Overview\n\n`ctx.headers` is a `Headers` object, which is the standard Web API interface for HTTP headers. It allows manipulation of HTTP response headers with a familiar API similar to what browsers and Node.js provide.\n\n## Key Methods on the Built-in `Headers` Object\n\n### 1. `append(name: string, value: string): void`\n\nAdd a new value to an existing header or create it if missing.\n\n```typescript\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n```\n\n---\n\n### 2. `set(name: string, value: string): void`\n\nSet or overwrite a header value.\n\n```typescript\nheaders.set(\"Content-Type\", \"text/html\");\n```\n\n**NB: `ctx.header` use function**\n\n---\n\n### 3. `get(name: string): string | null`\n\nGet the **first** value of a header (returns `null` if missing).\n\n```typescript\nconst contentType = headers.get(\"content-type\"); // e.g. \"text/html\" or null\n```\n\n---\n\n### 4. `has(name: string): boolean`\n\nCheck if a header exists.\n\n```typescript\nconst hasCacheControl = headers.has(\"cache-control\"); // true or false\n```\n\n---\n\n### 5. `delete(name: string): void`\n\nRemove a header.\n\n```typescript\nheaders.delete(\"x-powered-by\");\n```\n\n---\n\n### 6. Iteration\n\nHeaders are iterable with:\n\n* `headers.entries()` ‚Üí iterator of `[name, value]` pairs\n* `headers.keys()` ‚Üí iterator of header names\n* `headers.values()` ‚Üí iterator of header values\n\nExample:\n\n```typescript\nfor (const [name, value] of headers.entries()) {\n  console.log(`${name}: ${value}`);\n}\n```\n\n---\n\n## Example: Using `ctx.headers` as a `Headers` object\n\n```typescript\n// Example: Context interface with headers as built-in Headers object\ninterface Context {\n  headers: Headers;  // response headers to send back to client\n}\n\n// Initialize context with empty Headers\nconst ctx: Context = {\n  headers: new Headers(),\n};\n\n// --- Setting headers ---\nctx.headers.set(\"Content-Type\", \"application/json\");\nctx.headers.set(\"Cache-Control\", \"no-cache\");\n\n// --- Appending headers ---\nctx.headers.append(\"Vary\", \"Accept-Encoding\");\nctx.headers.append(\"Vary\", \"User-Agent\");\n\n// --- Checking if header exists ---\nif (ctx.headers.has(\"X-Powered-By\")) {\n  console.log(\"X-Powered-By header is set\");\n} else {\n  console.log(\"X-Powered-By header not set, setting now\");\n  ctx.headers.set(\"X-Powered-By\", \"MyServer\");\n}\n\n// --- Reading headers ---\nconst contentType = ctx.headers.get(\"content-type\");\nconsole.log(\"Content-Type:\", contentType); // application/json\n\nconst varyHeader = ctx.headers.get(\"vary\");\nconsole.log(\"Vary:\", varyHeader); // Accept-Encoding, User-Agent\n\n// --- Deleting headers ---\nctx.headers.delete(\"X-Powered-By\");\n\n// --- Iterating headers ---\nconsole.log(\"All headers:\");\nfor (const [key, value] of ctx.headers.entries()) {\n  console.log(`${key}: ${value}`);\n}\n\n// --- Output final headers as plain object ---\nfunction headersToObject(headers: Headers): Record<string, string> {\n  const result: Record<string, string> = {};\n  for (const [key, value] of headers.entries()) {\n    result[key] = value;\n  }\n  return result;\n}\n\nconsole.log(\"Headers as object:\", headersToObject(ctx.headers));\n```\n\n---\n\n### Explanation\n\n* **`ctx.headers`** is a native `Headers` object.\n* You **set** headers with `.set(key, value)` which overwrites existing values.\n* Use `.append(key, value)` to add multiple values for headers like `Vary`.\n* `.get(key)` fetches the first value of the header (comma-separated if multiple).\n* `.has(key)` checks existence.\n* `.delete(key)` removes the header.\n* You can iterate with `.entries()` over `[key, value]` pairs.\n* The `headersToObject()` helper converts the headers into a plain JS object for logging or other uses.\n\n---\n"
    },
    {
      "id": 26,
      "path": "websocket",
      "name": "Websocket",
      "folder": ".",
      "content": "# WebSocket Server\n\nThis document provides detailed information about implementing and using a WebSocket server with the `upgradeWebSocket` middleware from the `tezx/ws` module. The middleware enables WebSocket upgrades for HTTP servers across different JavaScript runtimes (Deno, Node.js, and Bun) with customizable event handlers and configuration options.\n\n## Overview\n\nThe `upgradeWebSocket` middleware facilitates WebSocket connections by upgrading HTTP requests to WebSocket protocol. It supports runtime-specific configurations for Deno, Node.js, and Bun, allowing developers to handle WebSocket events such as `open`, `message`, `close`, and more. The middleware integrates with the `tezx` framework, leveraging its `Context` object for request handling and environment detection for runtime-specific behavior.\n\nThe provided code snippet demonstrates a basic WebSocket server that:\n\n- Upgrades HTTP requests to WebSocket connections.\n- Handles WebSocket events (`open`, `message`, `close`).\n- Serves an `index.html` file for non-WebSocket requests.\n- Supports a simple ping-pong mechanism and message echoing.\n\n---\n\n## Key Components\n\n### WebSocket Event Handlers\n\nThe `WebSocketEvent` type defines the supported WebSocket event handlers, which are invoked during the WebSocket lifecycle:\n\n```typescript\nexport type WebSocketEvent = {\n  open?: WebSocketHandler; // Triggered when the connection is opened\n  message?: WebSocketHandler<string | Buffer | ArrayBuffer>; // Triggered on incoming messages\n  close?: WebSocketHandler<{ code: number; reason: string }>; // Triggered when the connection is closed\n  error?: WebSocketHandler<Error | any>; // Triggered on errors (not supported in Bun)\n  drain?: WebSocketHandler; // Triggered on socket drain (not supported in Deno/Node)\n  ping?: WebSocketHandler<Buffer>; // Triggered on ping frames (not supported in Deno)\n  pong?: WebSocketHandler<Buffer>; // Triggered on pong frames (not supported in Deno)\n};\n```\n\nEach handler is a function that takes a `WebSocket` instance and optional data, returning `void` or `Promise<void>`.\n\n### WebSocket Callback\n\nThe `WebSocketCallback` type defines a function that returns the `WebSocketEvent` handlers based on the request context:\n\n```typescript\nexport type WebSocketCallback = (ctx: Context) => WebSocketEvent;\n```\n\nThis allows dynamic configuration of WebSocket behavior based on the incoming request.\n\n### WebSocket Options\n\nThe `WebSocketOptions` interface provides configuration options for the WebSocket connection, with runtime-specific properties:\n\n```typescript\nexport type WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => CallbackReturn; // Custom error handler\n  protocol: string; // ‚úÖ Deno: Supported subprotocols\n  idleTimeout?: number; // ‚úÖ Deno: Idle timeout in seconds\n  perMessageDeflate?: boolean | PerMessageDeflateOptions; // ‚úÖ Node.js: Compression settings\n  maxPayload?: number; // ‚úÖ Node.js: Maximum message size in bytes\n};\n```\n\n### For **Nodejs**\n\nFor **Node.js**, here's how you can implement WebSocket upgrades using the `ws` library.\n\n<https://www.npmjs.com/package/ws>\n\nFirst, install the `ws` library:\n\n```bash\nnpm install ws\n```\n\n### Per-Message Deflate Options\n\nThe `PerMessageDeflateOptions` interface (**‚úÖ Node.js** only) configures compression for WebSocket messages:\n\n```typescript\ninterface PerMessageDeflateOptions {\n  serverNoContextTakeover?: boolean; // Disable server context takeover\n  clientNoContextTakeover?: boolean; // Disable client context takeover\n  serverMaxWindowBits?: number; // Server window size\n  clientMaxWindowBits?: number; // Client window size\n  zlibDeflateOptions?: ZlibOptions; // Zlib compression options\n  zlibInflateOptions?: ZlibInflateOptions; // Zlib decompression options\n  threshold?: number; // Minimum message size for compression\n  concurrencyLimit?: number; // Limit concurrent zlib operations\n}\n```\n\n### Zlib Options\n\nThe `ZlibOptions` interface (**‚úÖ Node.js** only) configures compression/decompression behavior:\n\n```typescript\ninterface ZlibOptions {\n  flush?: number; // Default flush flag\n  finishFlush?: number; // Flush flag for end()\n  chunkSize?: number; // Compression chunk size\n  windowBits?: number; // Window size (8‚Äì15)\n  level?: number; // Compression level (0‚Äì9)\n  memLevel?: number; // Memory allocation (1‚Äì9)\n  strategy?: number; // Compression strategy\n  dictionary?: NodeJS.ArrayBufferView | ArrayBuffer; // Compression dictionary\n  info?: boolean; // Return buffer and engine info\n}\n```\n\n---\n\n## Middleware: `upgradeWebSocket`\n\nThe `upgradeWebSocket` function is a middleware that handles WebSocket upgrades:\n\n```typescript\nexport function upgradeWebSocket(\n  callback: WebSocketCallback,\n  options: WebSocketOptions = {},\n): Middleware;\n```\n\n### Parameters\n\n- `callback`: A `WebSocketCallback` function that returns the `WebSocketEvent` handlers.\n- `options`: Optional `WebSocketOptions` to configure the WebSocket behavior.\n\n### Behavior\n\n1. Validates WebSocket headers (`upgrade`, `connection`, `sec-websocket-key`).\n2. Detects the runtime environment (Deno, Node.js, Bun) using `EnvironmentDetector`.\n3. Delegates the upgrade process to the appropriate transport (`DenoTransport`, `NodeTransport`, or Bun).\n4. Invokes the `onUpgradeError` handler if the upgrade fails or headers are invalid.\n\n### Returns\n\nA `Middleware` function compatible with the `tezx` framework, which either upgrades the connection or passes control to the next handler.\n\n---\n\n## Example Implementation\n\nBelow is a complete example demonstrating the WebSocket server using the `upgradeWebSocket` middleware, including a client-side HTML file to interact with the server.\n\n### Complete Code Example\n\n#### `src/server.ts`\n\n```typescript\nimport { upgradeWebSocket } from \"tezx/ws\";\n\n// Mock server setup (replace with actual HTTP server for your runtime)\nconst socket: WebSocket[] = [];\n// WebSocket route\napp.get(\n  \"/\",\n  upgradeWebSocket(\n    (ctx: Context) => {\n      return {\n        // make sure it is work with nodejs\n        open: (ws: WebSocket) => {\n          socket.push(ws);\n          console.log(\"WebSocket connected\");\n          ws.send(\"üëã Welcome to TezX WebSocket!\");\n        },\n        message: (ws: WebSocket, msg: string | Buffer | ArrayBuffer) => {\n          if (typeof msg === \"string\" && msg === \"ping\") {\n            ws.send(\"pong üèì\");\n          } else {\n            ws.send(\"Echo: \" + msg);\n          }\n        },\n        close: (ws: WebSocket, data: { code: number; reason: string }) => {\n          console.log(`WebSocket closed: ${data?.reason}`);\n        },\n      };\n    },\n    {\n      maxPayload: 2 * 1024 * 1024, // 2MB\n      perMessageDeflate: {\n        threshold: 1024, // Compress messages > 1KB\n      },\n    },\n  ),\n  (ctx: Context) => {\n    return ctx.sendFile(\"index.html\");\n  },\n);\n```\n\n#### `index.html`\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>TezX WebSocket Demo</title>\n    <style>\n      * {\n        box-sizing: border-box;\n      }\n\n      body {\n        font-family: \"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;\n        background: #f7f9fc;\n        padding: 30px;\n        color: #333;\n      }\n\n      h1 {\n        text-align: center;\n        color: #444;\n        margin-bottom: 30px;\n      }\n\n      .container {\n        max-width: 600px;\n        margin: 0 auto;\n        background: #fff;\n        border-radius: 10px;\n        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.05);\n        padding: 20px;\n      }\n\n      #messages {\n        border: 1px solid #ddd;\n        border-radius: 6px;\n        padding: 12px;\n        height: 250px;\n        overflow-y: auto;\n        background-color: #fafafa;\n        font-size: 14px;\n        margin-bottom: 15px;\n      }\n\n      #input {\n        width: 100%;\n        padding: 10px;\n        border: 1px solid #ccc;\n        border-radius: 6px;\n        font-size: 14px;\n        margin-bottom: 10px;\n      }\n\n      .buttons {\n        display: flex;\n        gap: 10px;\n        justify-content: flex-end;\n      }\n\n      button {\n        padding: 8px 16px;\n        font-size: 14px;\n        border: none;\n        border-radius: 6px;\n        cursor: pointer;\n        transition: all 0.2s ease;\n      }\n\n      button:hover {\n        opacity: 0.9;\n      }\n\n      button:active {\n        transform: scale(0.97);\n      }\n\n      .send-btn {\n        background-color: #4caf50;\n        color: white;\n      }\n\n      .ping-btn {\n        background-color: #2196f3;\n        color: white;\n      }\n\n      .message {\n        margin-bottom: 8px;\n        padding: 6px 10px;\n        border-radius: 4px;\n      }\n\n      .message.client {\n        background: #e8f5e9;\n        color: #2e7d32;\n      }\n\n      .message.server {\n        background: #e3f2fd;\n        color: #1565c0;\n      }\n\n      .message.system {\n        background: #fff3e0;\n        color: #ef6c00;\n        font-style: italic;\n      }\n    </style>\n  </head>\n  <body>\n    <h1>TezX WebSocket Demo</h1>\n    <div class=\"container\">\n      <div id=\"messages\"></div>\n      <input id=\"input\" type=\"text\" placeholder=\"Type a message...\" />\n      <div class=\"buttons\">\n        <button class=\"send-btn\" onclick=\"sendMessage()\">Send</button>\n        <button class=\"ping-btn\" onclick=\"sendPing()\">Ping</button>\n      </div>\n    </div>\n\n    <script>\n      const ws = new WebSocket(`ws://${location.host}`);\n      const messages = document.getElementById(\"messages\");\n      const input = document.getElementById(\"input\");\n\n      ws.onopen = () => {\n        appendMessage(\"Connected to WebSocket server\", \"system\");\n      };\n\n      ws.onmessage = (event) => {\n        appendMessage(`Server: ${event.data}`, \"server\");\n      };\n\n      ws.onclose = () => {\n        appendMessage(\"Disconnected from WebSocket server\", \"system\");\n      };\n\n      ws.onerror = (error) => {\n        appendMessage(`Error: ${error}`, \"system\");\n      };\n\n      function appendMessage(message, type = \"client\") {\n        const div = document.createElement(\"div\");\n        div.textContent = message;\n        div.className = `message ${type}`;\n        messages.appendChild(div);\n        messages.scrollTop = messages.scrollHeight;\n      }\n\n      function sendMessage() {\n        const message = input.value;\n        if (message && ws.readyState === WebSocket.OPEN) {\n          ws.send(message);\n          appendMessage(`Client: ${message}`, \"client\");\n          input.value = \"\";\n        }\n      }\n\n      function sendPing() {\n        if (ws.readyState === WebSocket.OPEN) {\n          ws.send(\"ping\");\n          appendMessage(\"Client: ping\", \"client\");\n        }\n      }\n    </script>\n  </body>\n</html>\n```\n\n## Limitations and Considerations\n\n1. **Runtime-Specific Features**:\n\n   - Some events (`ping`, `pong`, `drain`) are not supported in Deno or Node.js.\n   - `perMessageDeflate` and `maxPayload` are Node.js-only.\n\n2. **Scalability**:\n\n   - Storing WebSocket instances in an array (`socket.push(ws)`) may lead to memory leaks. Use a proper connection management system in production.\n\n3. **Testing**:\n   - Test WebSocket behavior under different runtimes and edge cases (e.g., large payloads, connection drops).\n"
    },
    {
      "id": 27,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```ts\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```ts\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  return ctx.text(\"Custom response overriding static file\");\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "id": 28,
      "path": "middlewares/cors-middleware",
      "name": "CORS Middleware",
      "folder": "Middlewares",
      "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// ‚ùå Avoid in production\ncors({ origin: \"*\" });\n// ‚úÖ Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.req.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
    },
    {
      "id": 29,
      "path": "middlewares/i18nmiddleware",
      "name": "I18nMiddleware",
      "folder": "Middlewares",
      "content": "# üåç `i18n`\n\n> Advanced internationalization (i18n) middleware for `tezx` with dynamic translation loading, fallback language chains, caching, and custom message formatting.\n\n---\n\n## üìÑ Usage\n\n### ‚úÖ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/middleware\";\n\napp.use(\n  i18n({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## üîß API: `i18n(options: I18nOptions): Middleware`\n\n### üß© Interface: `I18nOptions`\n\n| Option                   | Type                                                          | Default                           | Description                                   |\n| ------------------------ | ------------------------------------------------------------- | --------------------------------- | --------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations, expiresAt? }>` | **Required**                      | Function that dynamically loads translations. |\n| `defaultCacheDuration`   | `number`                                                      | `3600000` (1 hr)                  | Time (ms) before cache expires.               |\n| `isCacheValid`           | `(cached, language) => boolean`                               | `expiresAt > Date.now()`          | Custom logic to validate cached translations. |\n| `detectLanguage`         | `(ctx: Context) => string`                                    | Query > Cookie > Header > default | Custom language detection.                    |\n| `defaultLanguage`        | `string`                                                      | `'en'`                            | Fallback language if detection fails.         |\n| `fallbackChain`          | `string[]`                                                    | `[]`                              | Array of fallback languages in priority.      |\n| `translationFunctionKey` | `string`                                                      | `'t'`                             | Key name attached to `ctx` for translating.   |\n| `formatMessage`          | `(message: string, options?: Record<string, any>) => string`  | Basic `{{var}}` replace           | Message interpolation.                        |\n| `cacheTranslations`      | `boolean`                                                     | `true`                            | Enable/disable translation caching.           |\n\n---\n\n## üí¨ Translation Format\n\nYou can structure translations as nested objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## üß† Features Explained\n\n### 1. üåê Language Detection\n\nDefault flow:\n\n- Query Param: `?lang=fr`\n- Cookie: `lang=fr`\n- Header: `Accept-Language: fr`\n- Fallback: `'en'`\n\nYou can override this behavior:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n---\n\n### 2. üîÅ Fallback Chain\n\nSupport fallback chains like:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n---\n\n### 3. üß† Cache with Expiry\n\n```ts\ncacheTranslations: true,\ndefaultCacheDuration: 1000 * 60 * 60 // 1 hour\n```\n\nOr use expiration from backend:\n\n```ts\nloadTranslations: async (lang) => {\n  const result = await fetchFromAPI(lang);\n  return {\n    translations: result.data,\n    expiresAt: Date.now() + 60000, // 1 min\n  };\n};\n```\n\n---\n\n### 4. üß© Message Interpolation\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" });\n// Output: \"Welcome, Alice!\"\n```\n\nYou can customize it:\n\n```ts\nformatMessage: (msg, vars) => {\n  return msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n};\n```\n\n---\n\n### 5. üìö Nested Key Support\n\n```ts\n// JSON\n{\n  \"user\": {\n    \"profile\": {\n      \"greeting\": \"Hello, {{name}}\"\n    }\n  }\n}\n\n// Access\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## üß™ Advanced Example\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return {\n        translations: json.data,\n        expiresAt: json.expiresAt, // Optional\n      };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.req.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) => {\n      return msg.replace(\n        /\\{\\{(.*?)\\}\\}/g,\n        (_, key) => vars?.[key.trim()] ?? \"\",\n      );\n    },\n    cacheTranslations: true,\n    isCacheValid: (cached, lang) => {\n      return cached.expiresAt > Date.now();\n    },\n  }),\n);\n```\n\n---\n\n## üìå What `ctx` contains after middleware\n\n| Property            | Type                                      | Description             |\n| ------------------- | ----------------------------------------- | ----------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function    |\n| `ctx.language`      | `string`                                  | Selected language       |\n| `ctx.languageChain` | `string[]`                                | Language fallback chain |\n\n---\n\n## ‚ùó Error Handling\n\nIf no translations are found for any language in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## üì§ Exported Types\n\nYou can reuse types for strong typing in your app:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/middleware\";\n```\n\n---\n"
    },
    {
      "id": 30,
      "path": "middlewares/lazy-load-modules",
      "name": "Lazy Load Modules",
      "folder": "Middlewares",
      "content": "## `lazyLoadModules` Middleware\n\nThe `lazyLoadModules` middleware enables dynamic, lazy loading of modules in a `tezx` application based on route or query parameters. It supports caching, lifecycle hooks, and module validation to optimize performance and ensure reliability.\n\n### Overview\n\nThe `lazyLoadModules` middleware enables dynamic, lazy loading of modules in a `tezx/middleware` application based on runtime parameters (e.g., query, route, or custom logic). It supports caching, lifecycle hooks, module validation, and an optional `init` function for module-specific initialization. The `init` function is a critical feature, allowing modules to perform asynchronous setup, validate prerequisites, or short-circuit the request lifecycle. This document provides a unified explanation of the `init` function‚Äôs work procedure, its integration with the middleware, and a consolidated example that incorporates the diverse use cases from four demos.\n\n### Key Features\n\n- **Dynamic Module Loading**: Load modules on-demand via configurable loaders.\n- **Caching**: Cache modules with customizable TTL and storage (e.g., `Map`, Redis).\n- **Lifecycle Hooks**: Execute custom logic at stages like load, cache hit, or error.\n- **Module Validation**: Ensure modules meet structural or behavioral criteria.\n- **Initialization via `init`**: Perform asynchronous setup or early responses per module.\n- **Flexible Module Identification**: Support query parameters, route parameters, or custom logic.\n\nImport the middleware and related types:\n\n```typescript\nimport { lazyLoadModules } from \"tezx/middleware\";\n```\n\n### Type Definitions\n\n```typescript\nexport type LazyModuleLoader<T> = () => Promise<T>;\nexport interface CacheItem<T = any> {\n  module: T;\n  expiresAt: number;\n}\ninterface LazyLoadOptions<T> {\n  moduleKey?: (ctx: Context) => string;\n  getModuleLoader: (\n    ctx: Context,\n  ) => Promise<LazyModuleLoader<T> | null> | null | LazyModuleLoader<T>;\n  queryKeyModule?: string;\n  moduleContextKey?: string;\n  enableCache?: boolean;\n  cacheStorage?: {\n    get: (key: string) => CacheItem<T> | undefined;\n    set: (key: string, value: CacheItem<T>) => void;\n    delete: (key: string) => void;\n  };\n  cacheTTL?: number;\n  lifecycleHooks?: {\n    onLoad?: (moduleName: string, ctx: Context) => void;\n    onError?: (moduleName: string, error: Error, ctx: Context) => void;\n    onComplete?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheHit?: (moduleName: string, module: T, ctx: Context) => void;\n    onCacheSet?: (moduleName: string, module: T, ctx: Context) => void;\n  };\n  validateModule?: (module: T) => boolean;\n}\n```\n\n### Middleware Signature\n\n```typescript\nexport const lazyLoadModules = <T = any>(options: LazyLoadOptions<T>): Middleware;\n```\n\n---\n\n## Work Procedure of the `init` Function\n\n### Purpose\n\nThe `init` function is an optional, asynchronous method exported by a module to:\n\n- Perform setup tasks (e.g., initializing resources, fetching configurations).\n- Validate request-specific prerequisites (e.g., API keys, tokens).\n- Modify the `Context` object for downstream use.\n- Return early responses to short-circuit the middleware chain (e.g., errors, redirects).\n\n### Code Context\n\nThe `init` function is invoked in the middleware as follows:\n\n```typescript\nif (module.init && typeof module.init === \"function\") {\n  const initResult = await module.init(ctx);\n  if (initResult) {\n    return initResult;\n  }\n}\n```\n\n### Operational Workflow\n\nThe `init` function is processed within the middleware pipeline as follows:\n\n1. **Module Identification**:\n\n   - The middleware determines the module name using `moduleKey`, `queryKeyModule`, or route parameters.\n   - Example: `ctx.req.query.module` (Demo 1, 3), `ctx.req.params.module` (Demo 2), or `ctx.req.body.moduleName` (Demo 4).\n\n2. **Module Loading**:\n\n   - The `getModuleLoader` function returns a `LazyModuleLoader`, which dynamically imports the module.\n   - The loaded module is validated using `validateModule` (if provided).\n\n3. **init Function Detection**:\n\n   - The middleware checks if the module exports an `init` function (`module.init && typeof module.init === \"function\"`).\n   - If absent, the middleware skips to caching or context attachment.\n\n4. **init Invocation**:\n\n   - The `init` function is called with the `Context` object (`ctx`):\n\n     ```typescript\n     const initResult = await module.init(ctx);\n     ```\n\n   - The `Context` provides access to `req`, `res`, and custom properties, enabling request-specific logic.\n   - Asynchronous operations (e.g., database queries, API calls) are awaited.\n\n5. **Result Processing**:\n\n   - **Truthy Result**: If `initResult` is non-falsy (e.g., `{ error: \"Unauthorized\" }`), the middleware returns it, halting further processing (e.g., no caching, no `next`).\n   - **Falsy Result**: If `initResult` is `null`, `undefined`, or absent, the middleware continues.\n   - The `Context` may be modified (e.g., `ctx.config = {...}`) for use by the module or downstream middleware.\n\n6. **Post-Initialization**:\n\n   - The module is cached (if `enableCache` is true) with the specified `cacheTTL`.\n   - The module is attached to the context (`ctx[moduleContextKey] = module`).\n   - The `onComplete` lifecycle hook is triggered.\n   - The middleware proceeds to `await next()`.\n\n7. **Error Handling**:\n   - Errors thrown by `init` are caught in the middleware‚Äôs `try-catch` block.\n   - The `onError` hook is invoked, and the response status is set to 500 (`ctx.setStatus = 500`).\n   - The error is re-thrown for upstream handling.\n\n### Integration Points\n\n- **Before `init`**: Module loading and validation ensure the module is valid.\n- **During `init`**: The function performs setup, validation, or early responses.\n- **After `init`**: Caching, context attachment, and lifecycle hooks complete the cycle.\n- **Short-Circuiting**: A truthy `initResult` bypasses caching, context attachment, and `next`.\n\n---\n\n#### `LazyLoadOptions<T>`\n\nConfiguration options for the `lazyLoadModules` middleware.\n\n| Property           | Description                                               | Default                                                                      |\n| ------------------ | --------------------------------------------------------- | ---------------------------------------------------------------------------- |\n| `moduleKey`        | Function to extract the module name from the context.     | `(ctx) => ctx.req.params[queryKeyModule] \\|\\| ctx.req.query[queryKeyModule]` |\n| `getModuleLoader`  | Function to retrieve the module loader.                   | Required                                                                     |\n| `queryKeyModule`   | Query parameter name to select the module.                | `\"module\"`                                                                   |\n| `moduleContextKey` | Key to attach the loaded module to the context.           | `\"module\"`                                                                   |\n| `enableCache`      | Enable caching of loaded modules.                         | `true`                                                                       |\n| `cacheStorage`     | Custom cache storage implementation.                      | `Map<string, CacheItem<T>>`                                                  |\n| `cacheTTL`         | Cache Time-To-Live (TTL) in milliseconds.                 | `3600000` (1 hour)                                                           |\n| `lifecycleHooks`   | Lifecycle hooks for custom actions during module loading. | `{}`                                                                         |\n| `validateModule`   | Function to validate the loaded module.                   | `undefined`                                                                  |\n\n---\n\n## Consolidated Example: Unified Production-Ready Application\n\nThis example combines features from all four demos:\n\n- **Query-based loading** (Demo 1).\n- **Route-based loading** (Demo 2).\n- **Async `init` function** (Demo 3).\n- **Custom module key with validation** (Demo 4).\n\nIt demonstrates a production-ready setup with robust error handling, caching, lifecycle hooks, and a complex `init` function.\n\n### File Structure\n\n```bash\nproject/\n‚îú‚îÄ‚îÄ modules/\n‚îÇ   ‚îú‚îÄ‚îÄ dashboard.js\n‚îÇ   ‚îú‚îÄ‚îÄ orders.js\n‚îÇ   ‚îú‚îÄ‚îÄ auth.js\n‚îÇ   ‚îú‚îÄ‚îÄ report.js\n‚îî‚îÄ‚îÄ server.js\n```\n\n### Code\n\n**`server.js`**:\n\n```typescript\nimport { Context } from \"tezx\";\nimport { lazyLoadModules, CacheItem } from \"tezx/middleware\";\n\n// Custom cache storage\nconst customCache = new Map<string, CacheItem>();\nconst cacheStorage = {\n  get: (key: string) => customCache.get(key),\n  set: (key: string, value: CacheItem) => customCache.set(key, value),\n  delete: (key: string) => customCache.delete(key),\n};\n\n// Module loader map\nconst moduleLoaders: Record<string, () => Promise<any>> = {\n  dashboard: () => import(\"./modules/dashboard.js\"),\n  orders: () => import(\"./modules/orders.js\"),\n  auth: () => import(\"./modules/auth.js\"),\n  report: () => import(\"./modules/report.js\"),\n};\n\n// Middleware configuration\nconst lazyLoadMiddleware = lazyLoadModules({\n  moduleKey: (ctx: Context) => {\n    // Prioritize body, then query, then params\n    return (\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module\n    );\n  },\n  getModuleLoader: async (ctx: Context) => {\n    const moduleName =\n      ctx.req.body?.moduleName || ctx.req.query.module || ctx.req.params.module;\n    return moduleLoaders[moduleName] || null;\n  },\n  queryKeyModule: \"module\",\n  moduleContextKey: \"loadedModule\",\n  enableCache: true,\n  cacheTTL: 120000, // 2 minutes\n  cacheStorage,\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) =>\n      console.log(\n        `Loading ${moduleName} for request ID: ${ctx.req.id || \"unknown\"}`,\n      ),\n    onCacheHit: (moduleName, module, ctx) =>\n      console.log(`Cache hit for ${moduleName}`),\n    onCacheSet: (moduleName, module, ctx) =>\n      console.log(`Cached ${moduleName}`),\n    onComplete: (moduleName, module, ctx) =>\n      console.log(`Completed loading ${moduleName}`),\n    onError: (moduleName, error, ctx) =>\n      console.error(`Error in ${moduleName}: ${error.message}`),\n  },\n  validateModule: (module) => {\n    // Require handler function and version property\n    return (\n      typeof module.handler === \"function\" && typeof module.version === \"string\"\n    );\n  },\n});\n\n// Create Tezx app\napp.use(lazyLoadMiddleware);\n\n// Routes\napp.get(\"/api/query\", async (ctx: Context) => {\n  // Query-based (Demo 1, 3)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.get(\"/api/route/:module\", async (ctx: Context) => {\n  // Route-based (Demo 2)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 404;\n  return { error: \"Module not found or invalid\" };\n});\n\napp.post(\"/api/body\", async (ctx: Context) => {\n  // Body-based (Demo 4)\n  const module = ctx.loadedModule;\n  if (module && typeof module.handler === \"function\") {\n    return module.handler(ctx);\n  }\n  ctx.setStatus = 400;\n  return { error: \"Invalid or missing module\" };\n});\n```\n\n**`modules/dashboard.js`** (Demo 1-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Dashboard module\",\n  data: { widgets: [\"chart\", \"table\"] },\n});\n```\n\n**`modules/orders.js`** (Demo 2-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const handler = (ctx) => ({\n  message: \"Orders module\",\n  data: { orderId: ctx.req.query.orderId || 123 },\n});\n```\n\n**`modules/auth.js`** (Demo 3-inspired, with complex `init`):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  const apiKey = ctx.req.headers[\"x-api-key\"];\n  if (!apiKey) {\n    return {\n      status: 401,\n      error: \"API key required\",\n    };\n  }\n  try {\n    // Simulate async config fetch\n    const config = await fetchConfig(apiKey);\n    ctx.authConfig = config; // Attach to context\n    return null;\n  } catch (error) {\n    return {\n      status: 500,\n      error: `Auth initialization failed: ${error.message}`,\n    };\n  }\n};\nexport const handler = (ctx) => ({\n  message: \"Auth module\",\n  data: { token: \"abc123\", config: ctx.authConfig },\n});\n\n// Simulated async function\nasync function fetchConfig(apiKey) {\n  return { apiKey, settings: { scope: \"user\" } };\n}\n```\n\n**`modules/report.js`** (Demo 4-inspired):\n\n```javascript\nexport const version = \"1.0\";\nexport const init = async (ctx) => {\n  return null;\n};\nexport const handler = (ctx) => ({\n  message: \"Report module\",\n  data: { type: ctx.req.body?.reportType || \"sales\" },\n});\n```\n\n### Example Features\n\n- **Unified Module Identification**: Supports query (`/api/query?module=...`), route (`/api/route/:module`), and body (`POST /api/body`) inputs.\n- **Robust `init` Function**: The `auth` module demonstrates a complex `init` with API key validation, async configuration fetch, and context modification.\n- **Custom Cache Storage**: Uses a `Map`-based cache with a 2-minute TTL.\n- **Strict Validation**: Ensures modules have a `handler` function and `version` property.\n- **Comprehensive Lifecycle Hooks**: Logs all stages (load, cache hit, cache set, complete, error).\n- **Error Handling**: Gracefully handles missing modules, validation failures, and `init` errors.\n\n---\n"
    },
    {
      "id": 31,
      "path": "middlewares/detect-bot",
      "name": "Detect Bot",
      "folder": "Middlewares",
      "content": "# DetectBot Middleware\n\nThe `DetectBot` middleware provides a sophisticated and extensible mechanism for identifying and managing bot traffic in web applications. By integrating multiple detection methods‚Äîsuch as User-Agent analysis, IP blacklisting, query parameter checks, rate limiting, and custom logic‚Äîit offers comprehensive protection against unwanted bot activity while allowing fine-grained control over detection and response strategies.\n\n## Key Features\n\n- **User-Agent Analysis**: Identifies bots based on predefined or custom User-Agent patterns.\n- **IP Blacklisting**: Supports integration with external IP reputation services or custom blacklists.\n- **Query Parameter Detection**: Flags requests containing specific query parameters as potential bots.\n- **Rate Limiting**: Enforces request frequency limits to detect aggressive bot behavior.\n- **Custom Detection Logic**: Enables developers to implement application-specific bot identification rules.\n- **Confidence-Based Scoring**: Employs a weighted scoring system for nuanced bot classification.\n- **Configurable Responses**: Allows blocking of bots or execution of custom response logic.\n\n## Installation\n\nInstall the middleware as part of the `tezx` package:\n\n```bash\nnpm install tezx\n```\n\nImport the middleware into your project:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n```\n\n## Configuration Options\n\nThe `detectBot` middleware accepts an optional `DetectBotOptions` object to tailor its functionality. The table below outlines all available options, their types, default values, and descriptions:\n\n| Option                  | Type                                                                        | Default Value                                                                               | Description                                                                                         |\n| ----------------------- | --------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |\n| `botUserAgents`         | `string[]`                                                                  | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]`                                                       | Substrings in User-Agent headers that indicate bot traffic.                                         |\n| `maxRequests`           | `number`                                                                    | `30`                                                                                        | Maximum requests allowed within the rate-limiting window.                                           |\n| `windowMs`              | `number`                                                                    | `60000` (1 minute)                                                                          | Time window (in milliseconds) for rate-limiting calculations.                                       |\n| `isBlacklisted`         | `(ctx: Context, remoteAddress: string) => boolean \\| Promise<boolean>`      | `() => false`                                                                               | Asynchronous function to determine if an IP is blacklisted.                                         |\n| `queryKeyBot`           | `string`                                                                    | `\"bot\"`                                                                                     | Query parameter key signaling bot traffic (e.g., `?bot=true`).                                      |\n| `onBotDetected`         | `\"block\" \\| ((ctx: Context, result: BotDetectionResult) => CallbackReturn)` | `\"block\"`                                                                                   | Action to perform upon bot detection: `\"block\"` or a custom callback.                               |\n| `enableRateLimiting`    | `boolean`                                                                   | `false`                                                                                     | Enables rate-limiting detection.                                                                    |\n| `customBotDetector`     | `(ctx: Context) => boolean \\| Promise<boolean>`                             | `() => false`                                                                               | Custom asynchronous logic to identify bots.                                                         |\n| `customBlockedResponse` | `(ctx: Context, result: BotDetectionResult) => CallbackReturn`              | `(ctx, { reason }) => { ctx.setStatus = 403; return ctx.json({ error: \"Bot detected\" }); }` | Custom response for blocked requests.                                                               |\n| `storage`               | `{ get, set, delete, clearExpired }`                                        | `Map` (in-memory)                                                                           | Custom storage implementation for rate-limiting data (e.g., Redis). Defaults to an in-memory `Map`. |\n| `confidenceThreshold`   | `number` (0-1)                                                              | `0.5`                                                                                       | Minimum confidence score required to classify a request as a bot with multiple indicators.          |\n\n## Usage Examples\n\n### Basic Configuration\n\nApply the middleware with default settings to block detected bots:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n\napp.use(detectBot());\n\napp.get(\"/\", (ctx) => {\n  return ctx.json({ message: \"Hello, human!\" });\n});\n\napp.listen(3000);\n```\n\n- **Behavior**: Automatically blocks requests from User-Agents containing \"bot\", \"spider\", \"crawl\", or \"slurp\" with a `403 Forbidden` response.\n\n### Advanced Configuration\n\nCustomize detection with IP blacklisting, rate limiting, and a tailored response:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\n\n// Simulated IP reputation service\nasync function checkIPReputation(ip: string): Promise<boolean> {\n  const blacklist = [\"192.168.1.100\", \"10.0.0.1\"];\n  return blacklist.includes(ip);\n}\n\napp.use(\n  detectBot({\n    botUserAgents: [\"bot\", \"crawler\", \"spider\"],\n    maxRequests: 10,\n    windowMs: 30000, // 30 seconds\n    isBlacklisted: async (ctx, ip) => await checkIPReputation(ip),\n    enableRateLimiting: true,\n    customBotDetector: async (ctx) => {\n      // Flag requests without a referrer as potential bots\n      return !ctx.req.headers.get(\"referer\");\n    },\n    onBotDetected: (ctx, { reason, indicators }) => {\n      ctx.setStatus = 403;\n      return ctx.json({\n        error: \"Access Denied\",\n        reason,\n        indicators,\n      });\n    },\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.json({ message: \"Welcome, verified user!\" });\n});\n\napp.listen(3000);\n```\n\n- **Behavior**:\n  - Blocks requests with specified bot-like User-Agents.\n  - Rejects requests from blacklisted IPs.\n  - Enforces a limit of 10 requests per IP every 30 seconds.\n  - Identifies requests lacking a referrer as bots.\n  - Returns a detailed JSON error response upon detection.\n\n### Distributed Rate Limiting with Redis\n\nIntegrate Redis for scalable rate limiting across multiple instances:\n\n```typescript\nimport { detectBot } from \"tezx/middleware\";\nimport Redis from \"ioredis\";\n\nconst redis = new Redis();\n\nconst redisStorage = {\n  get: async (key: string) => {\n    const data = await redis.get(key);\n    return data ? JSON.parse(data) : undefined;\n  },\n  set: async (key: string, value: { count: number; resetTime: number }) => {\n    await redis.set(\n      key,\n      JSON.stringify(value),\n      \"PX\",\n      value.resetTime - Date.now(),\n    );\n  },\n  clearExpired: async () => {\n    // Redis automatically handles expiration via PX\n    //  if (now >= entry.resetTime) {\n    //                     .....delete(key);\n    //                 }\n  },\n};\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    maxRequests: 50,\n    windowMs: 60000, // 1 minute\n    storage: redisStorage,\n  }),\n);\n\napp.listen(3000);\n```\n\n- **Behavior**: Utilizes Redis to maintain rate-limiting state across distributed server instances, enforcing 50 requests per minute per IP.\n\n## Detection Mechanism\n\nThe middleware employs a multi-step process to classify requests:\n\n1. **Indicator Collection**: Gathers evidence such as User-Agent matches, blacklisted IPs, query parameters, rate limit breaches, and custom detector results.\n2. **Confidence Scoring**: When multiple indicators are present, calculates a confidence score (`0.3 * number of indicators`, capped at 1).\n3. **Bot Classification**:\n   - A request is flaggedS considered a bot if any single indicator is detected or if the confidence score exceeds the `confidenceThreshold` (default: 0.5).\n\n## Error Handling\n\n- **Blocking**: If `onBotDetected` is set to `\"block\"`, the `customBlockedResponse` function is invoked.\n- **Custom Logic Errors**: Failures in `isBlacklisted` or `customBotDetector` are logged via `GlobalConfig.debugging.warn`, allowing the request to proceed to avoid false positives.\n\n## Best Practices\n\n- **Optimize Rate Limits**: Calibrate `maxRequests` and `windowMs` to align with expected traffic patterns.\n- **Leverage Custom Detection**: Use `customBotDetector` to address domain-specific bot characteristics.\n- **Enable Logging**: Activate debugging in `GlobalConfig` to monitor detection events and refine rules.\n- **Scale Effectively**: Employ external storage (e.g., Redis) for high-traffic or multi-instance deployments.\n\n## Sample Output\n\nFor a request from `Googlebot` with IP `192.168.1.100` and query `?bot=true`:\n\n```json\n{\n  \"error\": \"Access Denied\",\n  \"reason\": \"Multiple Indicators\",\n  \"indicators\": [\"User-Agent\", \"Blacklisted IP\", \"Query Parameter\"]\n}\n```\n\n---\n"
    },
    {
      "id": 32,
      "path": "middlewares/basic-auth",
      "name": "Basic Auth",
      "folder": "Middlewares",
      "content": "# **basicAuth Middleware**\n\n## **Overview**\n\nThe `basicAuth` middleware provides flexible authentication for web applications, supporting **Basic Authentication**, **API Key**, and **Bearer Token** methods. It includes advanced features like **rate limiting**, **IP-based tracking**, and **Role-Based Access Control (RBAC)**, making it suitable for securing APIs and web routes. The middleware integrates seamlessly with the framework‚Äôs `Context` and `Middleware` types, ensuring type safety and runtime compatibility across Node.js, Bun, and Deno.\n\n---\n\n## **Type Definitions**\n\n```typescript\ntype AuthMethod = \"basic\" | \"api-key\" | \"bearer-token\";\n\ntype DynamicBasicAuthOptions = {\n  validateCredentials: (\n    method: AuthMethod,\n    credentials: Record<string, any>,\n    ctx: Context,\n  ) => boolean | Promise<boolean>;\n  getRealm?: (ctx: Context) => string;\n  onUnauthorized?: (ctx: Context, error?: Error) => CallbackReturn;\n  rateLimit?: {\n    storage?: {\n      get: (key: string) => { count: number; resetTime: number } | undefined;\n      set: (key: string, value: { count: number; resetTime: number }) => void;\n      clearExpired: () => void;\n    };\n    maxRequests: number;\n    windowMs: number;\n  };\n  supportedMethods?: AuthMethod[];\n  checkAccess?: (\n    ctx: Context,\n    credentials: Record<string, any>,\n  ) => boolean | Promise<boolean>;\n};\n\nexport const basicAuth: (options: DynamicBasicAuthOptions) => Middleware;\n```\n\n- **`AuthMethod`**: Enum for supported authentication types (`basic`, `api-key`, `bearer-token`).\n- **`DynamicBasicAuthOptions`**: Configuration object for customizing authentication behavior.\n- **`Middleware`**: Framework type for middleware functions, accepting a `Context` and `next` callback.\n\n---\n\n## **Configuration Options**\n\n| Property              | Type                                                                                                  | Description                                                                  | Default                                |\n| --------------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | -------------------------------------- |\n| `validateCredentials` | `(method: AuthMethod, credentials: Record<string, any>, ctx: Context) => boolean \\| Promise<boolean>` | Validates provided credentials. **Required**.                                | N/A                                    |\n| `getRealm`            | `(ctx: Context) => string`                                                                            | Dynamically sets the authentication realm for the `WWW-Authenticate` header. | `() => \"Restricted Area\"`              |\n| `onUnauthorized`      | `(ctx: Context, error?: Error) => CallbackReturn`                                                     | Handles unauthorized access with a custom response.                          | Sets `401` with `WWW-Authenticate`     |\n| `rateLimit`           | `{ storage?, maxRequests: number, windowMs: number }`                                                 | Configures rate limiting by IP.                                              | None (disabled by default)             |\n| `supportedMethods`    | `AuthMethod[]`                                                                                        | List of allowed authentication methods.                                      | `[\"basic\", \"api-key\", \"bearer-token\"]` |\n| `checkAccess`         | `(ctx: Context, credentials: Record<string, any>) => boolean \\| Promise<boolean>`                     | Optional RBAC check for fine-grained access control.                         | None (disabled by default)             |\n\n---\n\n## **Features**\n\n- **Multiple Authentication Methods**: Supports Basic Auth, API Key, and Bearer Token.\n- **Rate Limiting**: Prevents brute-force attacks with IP-based request limits.\n- **Role-Based Access Control**: Optionally enforces access policies post-authentication.\n- **Dynamic Realm**: Customizes the authentication prompt based on request context.\n- **Custom Error Handling**: Allows tailored responses for unauthorized access.\n- **Type-Safe**: Leverages TypeScript for robust integration with the framework.\n\n---\n\n## **Usage Examples**\n\nBelow are complete examples demonstrating all possible use cases of the `basicAuth` middleware.\n\n### **Basic Authentication**\n\nProtect a route using Basic Authentication with a simple username/password check.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"basic\") return false;\n      const { username, password } = credentials;\n      return username === \"admin\" && password === \"secret\";\n    },\n  }),\n);\n\napp.get(\"/protected\", (ctx) => {\n  return ctx.json({ message: \"Welcome, authenticated user!\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -u admin:secret http://localhost:3000/protected\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Welcome, authenticated user!\" }\n```\n\n**Invalid Credentials**:\n\n```bash\ncurl -u admin:wrong http://localhost:3000/protected\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **API Key Authentication**\n\nUse an API key passed via the `x-api-key` header.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    supportedMethods: [\"api-key\"],\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"api-key\") return false;\n      return credentials.apiKey === \"my-api-key-123\";\n    },\n  }),\n);\n\napp.get(\"/api/data\", (ctx) => {\n  return ctx.json({ data: \"Sensitive information\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -H \"x-api-key: my-api-key-123\" http://localhost:3000/api/data\n```\n\n**Response**:\n\n```json\n{ \"data\": \"Sensitive information\" }\n```\n\n**Invalid Key**:\n\n```bash\ncurl -H \"x-api-key: wrong-key\" http://localhost:3000/api/data\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **Bearer Token Authentication**\n\nSecure a route with a Bearer Token.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    supportedMethods: [\"bearer-token\"],\n    validateCredentials: async (method, credentials, ctx) => {\n      if (method !== \"bearer-token\") return false;\n      return credentials.token === \"valid-jwt-token\";\n    },\n  }),\n);\n\napp.get(\"/secure\", (ctx) => {\n  return ctx.json({ message: \"Token verified!\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl -H \"Authorization: Bearer valid-jwt-token\" http://localhost:3000/secure\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Token verified!\" }\n```\n\n**Invalid Token**:\n\n```bash\ncurl -H \"Authorization: Bearer invalid-token\" http://localhost:3000/secure\n```\n\n```json\n{ \"error\": \"Invalid credentials.\" }\n```\n\n---\n\n### **Rate Limiting**\n\nLimit requests by IP to prevent abuse.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return credentials.username === \"user\" && credentials.password === \"pass\";\n    },\n    rateLimit: {\n      maxRequests: 3, // Allow 3 requests\n      windowMs: 60 * 1000, // Per minute\n    },\n  }),\n);\n\napp.get(\"/rate-limited\", (ctx) => {\n  return ctx.json({ message: \"Access granted\" });\n});\n```\n\n**Requests**:\n\n```bash\ncurl -u user:pass http://localhost:3000/rate-limited  # 1st: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 2nd: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 3rd: Success\ncurl -u user:pass http://localhost:3000/rate-limited  # 4th: Blocked\n```\n\n**Blocked Response**:\n\n```json\n{ \"error\": \"Rate limit exceeded. Retry after 60 seconds.\" }\n```\n\n**Headers**:\n\n```bash\nRetry-After: 60\n```\n\n---\n\n### **Role-Based Access Control**\n\nRestrict access based on user roles after authentication.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      if (\n        credentials.username === \"admin\" &&\n        credentials.password === \"admin123\"\n      ) {\n        credentials.role = \"admin\";\n        return true;\n      }\n      if (\n        credentials.username === \"user\" &&\n        credentials.password === \"user123\"\n      ) {\n        credentials.role = \"user\";\n        return true;\n      }\n      return false;\n    },\n    checkAccess: async (ctx, credentials) => {\n      return credentials.role === \"admin\"; // Only admins allowed\n    },\n  }),\n);\n\napp.get(\"/admin-only\", (ctx) => {\n  return ctx.json({ message: \"Admin access granted\" });\n});\n```\n\n**Admin Request**:\n\n```bash\ncurl -u admin:admin123 http://localhost:3000/admin-only\n```\n\n```json\n{ \"message\": \"Admin access granted\" }\n```\n\n**User Request**:\n\n```bash\ncurl -u user:user123 http://localhost:3000/admin-only\n```\n\n```json\n{ \"error\": \"Access denied.\" }\n```\n\n---\n\n### **Custom Unauthorized Handler**\n\nCustomize the response for unauthorized access.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return false; // Simulate failure\n    },\n    onUnauthorized: (ctx, error) => {\n      ctx.status = 401;\n      ctx.body = {\n        status: \"error\",\n        message: `Authentication failed: ${error?.message}`,\n        timestamp: new Date().toISOString(),\n      };\n      return;\n    },\n  }),\n);\n\napp.get(\"/custom-error\", (ctx) => {\n  return ctx.json({ message: \"This won‚Äôt be reached\" });\n});\n```\n\n**Request**:\n\n```bash\ncurl http://localhost:3000/custom-error\n```\n\n**Response**:\n\n```json\n{\n  \"status\": \"error\",\n  \"message\": \"Authentication failed: Invalid credentials.\",\n  \"timestamp\": \"2025-04-15T12:00:00.000Z\"\n}\n```\n\n---\n\n### **Dynamic Realm**\n\nCustomize the `WWW-Authenticate` realm dynamically.\n\n```typescript\nimport { basicAuth } from \"tezx/middleware\";\n\napp.use(\n  basicAuth({\n    validateCredentials: async (method, credentials, ctx) => {\n      return false; // Simulate failure\n    },\n    getRealm: (ctx) => {\n      return ctx.url.pathname === \"/admin\" ? \"Admin Portal\" : \"User Area\";\n    },\n  }),\n);\n\napp.get(\"/admin\", (ctx) => {\n  return ctx.json({ message: \"Admin area\" });\n});\n\napp.get(\"/user\", (ctx) => {\n  return ctx.json({ message: \"User area\" });\n});\n```\n\n**Admin Request**:\n\n```bash\ncurl http://localhost:3000/admin\n```\n\n**Response Headers**:\n\n```bash\nWWW-Authenticate: Basic realm=\"Admin Portal\"\n```\n\n**User Request**:\n\n```bash\ncurl http://localhost:3000/user\n```\n\n**Response Headers**:\n\n```bash\nWWW-Authenticate: Basic realm=\"User Area\"\n```\n\n---\n\n## **Best Practices**\n\n- **Validate Credentials Securely**: Use hashed passwords or token verification libraries (e.g., JWT) in `validateCredentials`.\n- **Enable Rate Limiting**: Always configure `rateLimit` for public APIs to prevent abuse.\n- **Use RBAC Sparingly**: Only implement `checkAccess` for routes requiring fine-grained control to avoid performance overhead.\n- **Log Errors**: Use `GlobalConfig.debugging.error` for monitoring authentication failures in production.\n- **Restrict Supported Methods**: Explicitly set `supportedMethods` to only those required by your application.\n- **Test Unauthorized Cases**: Ensure `onUnauthorized` provides clear feedback for debugging and user experience.\n\n---\n\n## **Error Handling**\n\nThe middleware handles errors gracefully:\n\n- **Missing Auth Header**: Triggers `onUnauthorized` with an \"Unsupported authentication method\" error.\n- **Invalid Credentials**: Calls `onUnauthorized` with an \"Invalid credentials\" error.\n- **Rate Limit Exceeded**: Returns a `Retry-After` header and error message.\n- **RBAC Failure**: Invokes `onUnauthorized` with an \"Access denied\" error.\n- **Unexpected Errors**: Caught and passed to `onUnauthorized` for custom handling.\n\n---\n"
    },
    {
      "id": 33,
      "path": "middlewares/detect-locale",
      "name": "Detect Locale",
      "folder": "Middlewares",
      "content": "# `detectLocale` Middleware\n\n## Overview\n\nThe `detectLocale` middleware is designed to detect and set a user's preferred locale in a web application. It supports multiple detection methods, including query parameters, cookies, HTTP `Accept-Language` headers, and custom logic, making it highly flexible for internationalization (i18n). The middleware attaches the detected locale to the request context, enabling subsequent middleware or route handlers to deliver localized content. It is built with TypeScript for type safety and is compatible with runtimes like Node.js, Bun, and Deno.\n\n---\n\n## Features\n\n- **Multiple Detection Methods**: Supports locale detection via query parameters, cookies, `Accept-Language` headers, and custom detectors.\n- **Configurable Defaults**: Set a fallback locale and customize key names for query parameters, cookies, and context storage.\n- **Type-Safe**: Built with TypeScript for robust type checking and integration with custom context properties.\n- **Flexible Context Storage**: Store the detected locale under a custom key in the context object.\n- **Debugging Support**: Logs detected locales via `debugMode` for easy troubleshooting.\n- **Cross-Runtime Compatibility**: Works seamlessly with Node.js, Bun, and Deno.\n\n---\n\n## Configuration Options\n\nThe middleware is configured via a `DetectLocaleOptions` object, which allows fine-grained control over locale detection behavior.\n\n### `DetectLocaleOptions`\n\n| Property               | Type                                    | Description                                                                | Required | Default Value |\n| ---------------------- | --------------------------------------- | -------------------------------------------------------------------------- | -------- | ------------- |\n| `supportedLocales`     | `string[]`                              | List of allowed locales (e.g., `[\"en\", \"fr\", \"bn\"]`).                      | Yes      | N/A           |\n| `defaultLocale`        | `string`                                | Fallback locale if no match is found.                                      | No       | `\"en\"`        |\n| `queryKeyLocale`       | `string`                                | Query parameter name for locale (e.g., `lang` in `/?lang=fr`).             | No       | `\"lang\"`      |\n| `cookieKeyLocale`      | `string`                                | Cookie name for storing locale preference.                                 | No       | `\"locale\"`    |\n| `localeContextKey`     | `string`                                | Key used to store the detected locale in the context (e.g., `ctx.locale`). | No       | `\"locale\"`    |\n| `customLocaleDetector` | `(ctx: Context) => string \\| undefined` | Custom function to detect locale programmatically.                         | No       | None          |\n\n---\n\n## Middleware Workflow\n\nThe `detectLocale` middleware follows a prioritized detection process:\n\n1. **Query Parameter**:\n\n   - Checks the query parameter specified by `queryKeyLocale` (e.g., `/?lang=fr`).\n   - Validates against `supportedLocales`.\n\n2. **Cookie Value**:\n\n   - Checks the cookie specified by `cookieKeyLocale` (e.g., `locale=fr`).\n   - Validates against `supportedLocales`.\n\n3. **Accept-Language Header**:\n\n   - Parses the `Accept-Language` header (e.g., `en,fr;q=0.9`).\n   - Selects the first supported locale from the header‚Äôs ordered list.\n\n4. **Custom Detector** (if provided):\n\n   - Invokes `customLocaleDetector` to programmatically determine the locale.\n   - Validates the result against `supportedLocales`.\n\n5. **Default Locale**:\n   - Falls back to `defaultLocale` if no valid locale is detected.\n\n**Final Step**:\n\n- Stores the detected locale in `ctx[localeContextKey]`.\n- Calls `next()` to proceed to the next middleware or route handler.\n\n---\n\n## Usage Examples\n\nBelow are complete examples demonstrating all possible use cases for the `detectLocale` middleware.\n\n### Example 1: Query Parameter Detection\n\nDetects the locale from a query parameter (e.g., `/?lang=fr`).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\nimport { Middleware } from \"tezx\"; // Assuming a framework app instance\n\nconst localeMiddleware: Middleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  queryKeyLocale: \"lang\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl http://localhost:3000/welcome?lang=fr\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 2: Cookie-Based Detection\n\nDetects the locale from a cookie (e.g., `locale=en`).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  cookieKeyLocale: \"locale\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example** (with cookie set):\n\n```bash\ncurl --cookie \"locale=en\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Welcome!\" }\n```\n\n---\n\n### Example 3: Accept-Language Header Detection\n\nDetects the locale from the `Accept-Language` header.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl -H \"Accept-Language: fr,en;q=0.9\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 4: Custom Locale Detector\n\nUses a custom detector to determine the locale based on user-specific logic (e.g., database lookup).\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  customLocaleDetector: (ctx) => {\n    // Mock user profile lookup\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example**:\n\n```bash\ncurl -H \"x-user-id: user123\" http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n```\n\n---\n\n### Example 5: Default Locale Fallback\n\nFalls back to the default locale when no other detection method provides a valid locale.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"fr\",\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.locale;\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  return ctx.json({ message: messages[locale] });\n});\n```\n\n**Request Example** (no locale specified):\n\n```bash\ncurl http://localhost:3000/welcome\n```\n\n**Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n---\n\n### Example 6: Combining All Detection Methods\n\nCombines query parameters, cookies, headers, and a custom detector, with a custom context key.\n\n```typescript\nimport { detectLocale } from \"tezx/middleware\";\n\nconst localeMiddleware = detectLocale({\n  supportedLocales: [\"en\", \"fr\", \"bn\"],\n  defaultLocale: \"en\",\n  queryKeyLocale: \"language\",\n  cookieKeyLocale: \"user_locale\",\n  localeContextKey: \"userLocale\",\n  customLocaleDetector: (ctx) => {\n    const userId = ctx.req.headers.get(\"x-user-id\");\n    const userLocales = { user123: \"bn\" };\n    return userLocales[userId] || undefined;\n  },\n});\n\napp.get(\"/welcome\", localeMiddleware, (ctx) => {\n  const locale = ctx.userLocale; // Custom context key\n  const messages = {\n    en: \"Welcome!\",\n    fr: \"Bienvenue !\",\n    bn: \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\",\n  };\n  ctx.body = { message: messages[locale] };\n  return;\n});\n```\n\n**Request Examples**:\n\n1. **Query Parameter**:\n\n   ```bash\n   curl http://localhost:3000/welcome?language=fr\n   ```\n\n   **Response**:\n\n```json\n{ \"message\": \"Bienvenue !\" }\n```\n\n2. **Cookie**:\n\n   ```bash\n   curl --cookie \"user_locale=bn\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n   ```\n\n3. **Accept-Language Header**:\n\n   ```bash\n   curl -H \"Accept-Language: en,fr;q=0.9\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"Welcome!\" }\n   ```\n\n4. **Custom Detector**:\n\n   ```bash\n   curl -H \"x-user-id: user123\" http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"‡¶∏‡ßç‡¶¨‡¶æ‡¶ó‡¶§‡¶Æ!\" }\n   ```\n\n5. **Default Fallback**:\n\n   ```bash\n   curl http://localhost:3000/welcome\n   ```\n\n   **Response**:\n\n   ```json\n   { \"message\": \"Welcome!\" }\n   ```\n\n---\n\n## Best Practices\n\n- **Validate Supported Locales**: Ensure `supportedLocales` includes all locales your application supports to avoid unexpected behavior.\n- **Consistent Naming**: Use clear, consistent names for `queryKeyLocale`, `cookieKeyLocale`, and `localeContextKey` to align with your API conventions.\n- **Custom Detectors**: Use `customLocaleDetector` for advanced logic, such as database-driven locale preferences or geolocation-based detection.\n- **Debugging**: Enable debugging during development to log detected locales for troubleshooting.\n- **Cookie Security**: Set secure and HTTP-only flags on locale cookies to prevent client-side access.\n- **Header Parsing**: Handle complex `Accept-Language` headers carefully, as clients may send malformed values.\n\n---\n\n## Error Handling\n\nThe middleware is designed to be robust and fault-tolerant:\n\n- **Invalid Query Parameter**: Ignores unsupported query parameter values and proceeds to the next detection method.\n- **Invalid Cookie**: Ignores unsupported cookie values and proceeds to the next detection method.\n- **Malformed Accept-Language Header**: Filters out unsupported or invalid locales and proceeds to the next detection method.\n- **Invalid Custom Detector**: Ignores invalid results from `customLocaleDetector` and falls back to `defaultLocale`.\n- **Missing Locale**: Always falls back to `defaultLocale`, ensuring a valid locale is set.\n\n---\n\n## Type Definitions\n\n```typescript\ntype DetectLocaleOptions = {\n  supportedLocales: string[];\n  defaultLocale?: string;\n  queryKeyLocale?: string;\n  cookieKeyLocale?: string;\n  localeContextKey?: string;\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\nexport const detectLocale: (options: DetectLocaleOptions) => Middleware;\n```\n\n---\n"
    },
    {
      "id": 34,
      "path": "middlewares/request-timeout",
      "name": "Request Timeout",
      "folder": "Middlewares",
      "content": "# `requestTimeout` Middleware Documentation\n\nThe `requestTimeout` middleware is designed to enforce fully dynamic request timeouts in a middleware-based application. It allows developers to specify a timeout duration dynamically based on the request context, handle timeout errors, log timeout events, and perform cleanup operations after a timeout occurs.\n\n## Overview\n\nThe middleware integrates with a routing system that uses a `Context` object to manage request and response data. The middleware is highly customizable through the `TimeoutOptions` configuration, enabling developers to tailor timeout behavior to specific use cases.\n\n## API Reference\n\n### `TimeoutOptions`\n\nThe `TimeoutOptions` type defines the configuration options for the `requestTimeout` middleware.\n\n| Property          | Type                                             | Description                                                                                                                         |\n| ----------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------- |\n| `getTimeout`      | `(ctx: Context) => number`                       | **Required.** Function to dynamically determine the timeout duration (in milliseconds) based on the request context.                |\n| `onTimeout`       | `(ctx: Context, error: Error) => CallbackReturn` | **Optional.** Custom function to handle timeout errors. Defaults to setting a 504 Gateway Timeout status and a JSON error response. |\n| `logTimeoutEvent` | `(ctx: Context, error: Error) => void`           | **Optional.** Logging function for timeout events. Defaults to logging a warning with request details via `debugging.warn`.         |\n| `cleanup`         | `(ctx: Context) => void`                         | **Optional.** Custom function to clean up resources after a timeout. Defaults to an empty function.                                 |\n\n### `requestTimeout`\n\nThe `requestTimeout` function creates a middleware that enforces dynamic timeouts.\n\n**Signature:**\n\n```typescript\nrequestTimeout(options: TimeoutOptions): Middleware\n```\n\n**Parameters:**\n\n- `options`: An object conforming to the `TimeoutOptions` type.\n\n**Returns:**\n\n- A `Middleware` function that can be used in a middleware pipeline.\n\n## Usage\n\nThe middleware is typically used in a middleware-based framework (e.g., Express-like routers). Below are several examples demonstrating how to use the `requestTimeout` middleware in different scenarios.\n\n### Example 1: Basic Timeout with Default Behavior\n\nThis example sets a fixed 5-second timeout for all requests.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => 5000, // 5 seconds\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- All requests will timeout after 5 seconds.\n- The default `onTimeout` sets a 504 status and returns `{ error: \"Request timed out.\" }`.\n- Timeout events are logged using the default `logTimeoutEvent`.\n- No custom cleanup is performed.\n\n### Example 2: Dynamic Timeout Based on Request Path\n\nThis example sets different timeout durations based on the request path.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => {\n    if (ctx.path.startsWith(\"/api/slow\")) {\n      return 10000; // 10 seconds for slow endpoints\n    }\n    return 3000; // 3 seconds for others\n  },\n  onTimeout: (ctx, error) => {\n    ctx.setStatus = 504;\n    ctx.body = {\n      error: `Request to ${ctx.path} timed out after ${getTimeout(ctx)}ms.`,\n    };\n  },\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- Requests to `/api/slow/*` have a 10-second timeout, while others have a 3-second timeout.\n- The custom `onTimeout` provides a detailed error message including the request path and timeout duration.\n\n### Example 3: Custom Logging and Cleanup\n\nThis example demonstrates custom logging and cleanup for timeout events.\n\n```typescript\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => 5000, // 5 seconds\n  logTimeoutEvent: (ctx, error) => {\n    logger.error(\n      `Timeout occurred: ${ctx.method} ${ctx.path} - ${error.message}`,\n    );\n  },\n  cleanup: (ctx) => {\n    // Release database connections or other resources\n    db.releaseConnection(ctx.requestId);\n  },\n});\n\napp.use(timeoutMiddleware);\n```\n\nIn this case:\n\n- Timeout events are logged using a custom `Logger` utility.\n- The `cleanup` function releases database connections associated with the request.\n\n### Example 4: Combining with Other Middleware\n\nThis example shows how to combine `requestTimeout` with other middleware in a pipeline.\n\n```typescript\nimport { requestTimeout } from \"tezx/middleware\";\nimport { authenticate } from \"./auth-middleware\";\n\nconst timeoutMiddleware = requestTimeout({\n  getTimeout: (ctx) => {\n    // Longer timeout for authenticated users\n    return ctx.user ? 10000 : 5000; // 10s for authenticated, 5s otherwise\n  },\n});\n\napp.use(authenticate); // Authenticate user first\napp.use(timeoutMiddleware); // Apply timeout\n```\n\n```ts\napp.get(\"/\", async (ctx) => {\n  await new Promise((resolve) => setTimeout(resolve, 6000)); // 6 seconds\n  return await ctx.json({});\n});\n```\n\nIn this case:\n\n- The `authenticate` middleware populates `ctx.user` if the request is authenticated.\n- The timeout is dynamically set based on the authentication status.\n\n## Error Handling\n\nThe middleware handles errors as follows:\n\n- **Timeout Errors**: If the request exceeds the timeout duration, the `onTimeout` function is called, and the error is not propagated further.\n- **Other Errors**: Non-timeout errors (e.g., errors thrown by `next()`) are re-thrown to be handled by downstream middleware or error handlers.\n- **Cleanup**: The `cleanup` function is always called in the `finally` block, ensuring resources are released even if an error occurs.\n\n## Best Practices\n\n1. **Dynamic Timeout Logic**:\n\n   - Use `getTimeout` to adjust timeouts based on request characteristics (e.g., path, method, user role).\n   - Avoid overly short timeouts that may interrupt legitimate requests.\n\n2. **Error Handling**:\n\n   - Customize `onTimeout` to provide meaningful error responses to clients.\n   - Ensure `onTimeout` sets an appropriate HTTP status code (e.g., 504 Gateway Timeout).\n\n3. **Logging**:\n\n   - Use `logTimeoutEvent` to record timeout events for monitoring and debugging.\n   - Include relevant context (e.g., `ctx.method`, `ctx.path`) in logs.\n\n4. **Resource Cleanup**:\n\n   - Implement `cleanup` to release resources like database connections, file handles, or timers.\n   - Ensure `cleanup` is idempotent to handle multiple calls safely.\n\n5. **Testing**:\n   - Test timeout behavior under various conditions (e.g., slow network, heavy load).\n   - Verify that `cleanup` is called in all scenarios (success, timeout, error).\n\n## Limitations\n\n- The middleware relies on `setTimeout`, which may not be precise for very short durations due to JavaScript's event loop.\n- It assumes the `Context` object has properties like `method`, `path`, `setStatus`, and `body`. Ensure your framework's `Context` is compatible.\n- The middleware does not handle concurrent requests explicitly; ensure your application handles concurrency appropriately.\n"
    },
    {
      "id": 35,
      "path": "middlewares/cache-control",
      "name": "Cache Control",
      "folder": "Middlewares",
      "content": "\n# `cacheControl` Middleware\n\n`tezx/middleware`\n\n### üì¶ Import\n\n```ts\nimport { cacheControl } from 'tezx/middleware';\n```\n\n---\n\n## üß† Description\n\n`cacheControl` is an HTTP caching middleware that dynamically applies headers like `Cache-Control`, `Expires`, `Vary`, and `ETag` based on request conditions. It supports custom rules, smart revalidation, and automatic header management for production-ready caching.\n\n---\n\n## üîß Usage\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 60,\n    scope: \"public\",\n    enableETag: true,\n    vary: [\"Accept-Encoding\"],\n  },\n  rules: [\n    {\n      condition: (ctx) => ctx.pathname.startsWith(\"/api/\"),\n      maxAge: 10,\n      scope: \"private\",\n      enableETag: true,\n    },\n  ],\n  logEvent: (event, ctx, error) => {\n    console.log(`[CACHE EVENT] ${event}`, ctx.pathname, error?.message);\n  },\n}));\n```\n\n---\n\n## ‚öôÔ∏è `DynamicCacheOptions`\n\n### Properties\n\n| Property          | Type                                      | Description                                                           |\n| ----------------- | ----------------------------------------- | --------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings`                           | Default cache behavior if no rule matches.                            |\n| `rules`           | `CacheRule[]` (optional)                  | List of custom rules that match specific conditions.                  |\n| `useWeakETag`     | `boolean` (optional)                      | Whether to use weak ETags (e.g., `W/\"etag\"`). Default: `false`.       |\n| `logEvent`        | `(event, ctx, error?) => void` (optional) | Logging callback for cache events like \"cached\", \"no-cache\", \"error\". |\n\n---\n\n## üßæ `CacheRule`\n\n```ts\ntype CacheRule = {\n  condition: (ctx: Context) => boolean;\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\nDefines a rule based on custom logic (`condition`) to dynamically apply different caching behavior.\n\n---\n\n## üßæ `CacheSettings`\n\n```ts\ntype CacheSettings = {\n  maxAge: number;\n  scope: \"public\" | \"private\";\n  enableETag: boolean;\n  vary?: string[];\n};\n```\n\nDefines standard cache parameters applied by default or when a rule is matched.\n\n---\n\n## üì• Example: Static + Dynamic Cache\n\n```ts\napp.use(cacheControl({\n  defaultSettings: {\n    maxAge: 300,\n    scope: \"public\",\n    enableETag: true,\n  },\n  rules: [\n    {\n      condition: (ctx) => ctx.pathname.startsWith(\"/assets/\"),\n      maxAge: 86400,\n      scope: \"public\",\n      enableETag: false,\n    },\n    {\n      condition: (ctx) => ctx.pathname === \"/profile\",\n      maxAge: 30,\n      scope: \"private\",\n      enableETag: true,\n    }\n  ]\n}));\n```\n\n---\n\n## üß™ ETag Generation\n\n* ETag is generated using `md5` hash of the response body.\n* If `useWeakETag: true`, it‚Äôs returned as `W/\"etag\"`, which is less strict and more cache-friendly.\n* Automatically responds with `304 Not Modified` if client-sent `If-None-Match` matches.\n\n---\n\n## üì§ Headers Set\n\n* `Cache-Control`\n* `Expires`\n* `ETag` *(optional)*\n* `Vary` *(optional)*\n\n---\n\n## üîê Compatibility\n\n* Works for `GET` and `HEAD` requests only.\n* Skips caching logic for other HTTP methods.\n* Safe to use across dynamic and static responses.\n\n---\n"
    },
    {
      "id": 36,
      "path": "middlewares/logger",
      "name": "Logger",
      "folder": "Middlewares",
      "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```bash\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
    },
    {
      "id": 37,
      "path": "middlewares/powered-by",
      "name": "Powered By",
      "folder": "Middlewares",
      "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
    },
    {
      "id": 38,
      "path": "middlewares/request-id",
      "name": "Request ID",
      "folder": "Middlewares",
      "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
    },
    {
      "id": 39,
      "path": "middlewares/secure-headers",
      "name": "Secure Headers",
      "folder": "Middlewares",
      "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
    },
    {
      "id": 40,
      "path": "middlewares/xss-protection",
      "name": "XSS Protection",
      "folder": "Middlewares",
      "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```ts\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```ts\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```ts\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
    },
    {
      "id": 41,
      "path": "middlewares/sanitize-headers",
      "name": "Sanitize Headers",
      "folder": "Middlewares",
      "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```ts\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```ts\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```ts\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```ts\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n```ts\n// Recommended security-focused setup\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    normalizeKeys: true,\n  }),\n);\n```\n\n2. **Information Hiding**:\n\n```ts\n// Hide server technology information\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
    },
    {
      "id": 42,
      "path": "middlewares/rate-limiter",
      "name": "Rate Limiter",
      "folder": "Middlewares",
      "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n**Note: It works with `app.use` api**\n\n## Installation\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```ts\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```ts\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```ts\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```ts\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({ error: `Try again in ${retryAfter} seconds` });\n  };\n  ```\n\n```ts\n\n  /**\n   * üîÑ Custom cache storage implementation (e.g., using `Map`, `Redis`, etc.).\n   * By default, it uses a `Map<string, { count: number; resetTime: number }>`.\n   */\n  storage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    clearExpired: () => void;\n  };\n\n```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```ts\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```ts\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      });\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n```ts\n// Planned future usage\napp.use(\n  rateLimiter({\n    maxRequests: 1000,\n    windowMs: 3600000,\n    storage: \"redis\",\n    redisClient: redis.createClient(),\n  }),\n);\n```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```ts\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```ts\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```ts\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
    },
    {
      "id": 43,
      "path": "middlewares/pagination",
      "name": "Pagination",
      "folder": "Middlewares",
      "content": "# PaginationHandler Middleware\n\nThe `paginationHandler` middleware provides a robust and flexible solution for implementing pagination in web applications. It automates the handling of pagination parameters, integrates with dynamic data sources, and enriches responses with comprehensive metadata, enabling developers to efficiently manage paginated data retrieval and presentation.\n\n## Key Features\n\n- **Parameter Parsing**: Automatically extracts and sanitizes pagination parameters from query strings.\n- **Dynamic Data Fetching**: Supports integration with custom data sources for flexible data retrieval.\n- **Pagination Metadata**: Provides detailed information such as total items, total pages, and navigation links.\n- **Configurable Options**: Allows customization of defaults, limits, and response structure.\n- **Error Handling**: Ensures safe parsing and bounds checking for pagination inputs.\n\n## Import the middleware into your project\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n```\n\n## Configuration Options\n\nThe `paginationHandler` middleware accepts an optional `PaginationOptions` object to customize its behavior. The table below details all available options, their types, default values, and descriptions:\n\n| Option          | Type                                                                                                             | Default Value | Description                                                                                  |\n| --------------- | ---------------------------------------------------------------------------------------------------------------- | ------------- | -------------------------------------------------------------------------------------------- |\n| `defaultPage`   | `number`                                                                                                         | `1`           | Default page number when not specified in the query.                                         |\n| `defaultLimit`  | `number`                                                                                                         | `10`          | Default number of items per page when not specified.                                         |\n| `maxLimit`      | `number`                                                                                                         | `100`         | Maximum allowed items per page to prevent excessive resource usage.                          |\n| `queryKeyPage`  | `string`                                                                                                         | `\"page\"`      | Query parameter name for the page number (e.g., `?page=2`).                                  |\n| `queryKeyLimit` | `string`                                                                                                         | `\"limit\"`     | Query parameter name for items per page (e.g., `?limit=20`).                                 |\n| `countKey`      | `string`                                                                                                         | `\"total\"`     | Key in the response object containing the total item count.                                  |\n| `dataKey`       | `string`                                                                                                         | `\"data\"`      | Key in the response object containing the paginated data array.                              |\n| `getDataSource` | `(ctx: Context, pagination: { page: number; limit: number; offset: number }) => Promise<{ [key: string]: any }>` | `undefined`   | Function to dynamically fetch paginated data and total count based on pagination parameters. |\n\n## Usage Examples\n\n### Basic Configuration\n\nApply the middleware to attach pagination context without a data source:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\napp.use(paginationHandler());\n\napp.get(\"/users\", (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  return ctx.json({\n    message: `Page ${page}, Limit ${limit}, Offset ${offset}`,\n  });\n});\n```\n\n- **Behavior**: Parses `page` and `limit` from the query string (e.g., `?page=2&limit=20`), sets defaults if omitted, and attaches pagination details to `ctx.pagination`.\n- **Sample Request**: `GET /users?page=2&limit=20`\n- **Response**:\n\n  ```json\n  {\n    \"message\": \"Page 2, Limit 20, Offset 20\"\n  }\n  ```\n\n### Advanced Configuration with Data Source\n\nIntegrate with a dynamic data source for full pagination functionality:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\n// Simulated database query (e.g., using Sequelize or similar ORM)\nasync function fetchProducts(\n  ctx: Context,\n  { page, limit, offset }: { page: number; limit: number; offset: number },\n) {\n  const products = await Product.findAll({\n    offset,\n    limit,\n  });\n  const total = await Product.count();\n  return { items: products, totalCount: total };\n}\n\napp.get(\n  \"/products\",\n  paginationHandler({\n    defaultPage: 1,\n    defaultLimit: 5,\n    maxLimit: 50,\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalCount\",\n    dataKey: \"items\",\n    getDataSource: fetchProducts,\n  }),\n  (ctx) => {\n    return ctx.json(ctx.body);\n  },\n);\n```\n\n- **Behavior**:\n  - Parses `p` and `size` from the query (e.g., `?p=2&size=10`).\n  - Limits `size` to 50 if exceeded.\n  - Fetches data using the provided `getDataSource` function.\n  - Returns a structured response with items, total count, and pagination metadata.\n- **Sample Request**: `GET /products?p=2&size=10`\n- **Response** (assuming 25 total products):\n\n  ```json\n  {\n    \"items\": [\n      /* array of 10 products */\n    ],\n    \"totalCount\": 25,\n    \"pagination\": {\n      \"page\": 2,\n      \"limit\": 10,\n      \"totalItems\": 25,\n      \"totalPages\": 3,\n      \"hasNextPage\": true,\n      \"hasPrevPage\": true,\n      \"nextPage\": 3,\n      \"prevPage\": 1\n    }\n  }\n  ```\n\n### Custom Response Structure\n\nCustomize the response keys for compatibility with existing APIs:\n\n```typescript\nimport { paginationHandler } from \"tezx/middleware\";\n\nasync function fetchUsers(ctx: Context, { page, limit, offset }) {\n  const users = await User.findAll({ offset, limit });\n  const total = await User.count();\n  return { records: users, count: total };\n}\n\napp.get(\n  \"/users\",\n  paginationHandler({\n    countKey: \"count\",\n    dataKey: \"records\",\n    getDataSource: fetchUsers,\n  }),\n);\n```\n\n- **Behavior**: Uses `records` and `count` as keys instead of defaults.\n- **Sample Request**: `GET /users?page=1&limit=5`\n- **Response** (assuming 12 total users):\n\n  ```json\n  {\n    \"records\": [\n      /* array of 5 users */\n    ],\n    \"count\": 12,\n    \"pagination\": {\n      \"page\": 1,\n      \"limit\": 5,\n      \"totalItems\": 12,\n      \"totalPages\": 3,\n      \"hasNextPage\": true,\n      \"hasPrevPage\": false,\n      \"nextPage\": 2,\n      \"prevPage\": null\n    }\n  }\n  ```\n\n## Pagination Mechanism\n\n1. **Parameter Extraction**: Reads `queryKeyPage` and `queryKeyLimit` from the request query string.\n2. **Sanitization**: Ensures `page` is at least 1 and `limit` is between 1 and `maxLimit`.\n3. **Offset Calculation**: Computes `offset = (page - 1) * limit` for data retrieval.\n4. **Data Fetching**: Invokes `getDataSource` (if provided) with pagination details.\n5. **Metadata Generation**: Calculates total pages, navigation flags, and page links based on the total count.\n\n## Error Handling\n\n- **Invalid Inputs**: Non-numeric or negative `page` and `limit` values are coerced to defaults or bounds (e.g., `page < 1` becomes 1, `limit > maxLimit` becomes `maxLimit`).\n- **Missing Data Source**: If `getDataSource` is omitted, the middleware attaches pagination details to `ctx.pagination` and proceeds to the next handler.\n\n## Best Practices\n\n- **Set Reasonable Limits**: Configure `maxLimit` to balance performance and usability.\n- **Customize Keys**: Align `countKey` and `dataKey` with your API‚Äôs existing structure.\n- **Optimize Data Queries**: Ensure `getDataSource` leverages database-level pagination (e.g., `OFFSET` and `LIMIT` in SQL).\n- **Handle Edge Cases**: Test with empty datasets or extreme page numbers to verify behavior.\n\n## Sample Output\n\nFor a request to `/products?p=3&size=5` with 13 total items:\n\n```json\n{\n  \"items\": [\n    /* 3 products (offset 10-12) */\n  ],\n  \"totalCount\": 13,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 5,\n    \"totalItems\": 13,\n    \"totalPages\": 3,\n    \"hasNextPage\": false,\n    \"hasPrevPage\": true,\n    \"nextPage\": null,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n"
    },
    {
      "id": 44,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```ts\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```ts\n// For deno environment\nimport { loadEnv } from \"tezx/deno\";\n// For bun environment\nimport { loadEnv } from \"tezx/bun\";\n// For node environment\nimport { loadEnv } from \"tezx/node\";\n\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```ts\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.req.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```ts\nconst app = new Tezx<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```ts\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Tezx({\n  env,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```ts\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Tezx<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```ts\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
    },
    {
      "id": 45,
      "path": "examples/basic",
      "name": "Basic",
      "folder": "Examples",
      "content": ""
    },
    {
      "id": 46,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
    },
    {
      "id": 47,
      "path": "examples/basic-auth-client",
      "name": "Basic Auth Client",
      "folder": "Examples",
      "content": "### **1. Using cURL**\n\nYou can pass Basic Auth credentials using the `-u` flag in `cURL`. For example:\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\nAlternatively, you can manually set the `Authorization` header:\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\n**Explanation:**\n\n- The `-u` flag automatically encodes the `username:password` string in Base64.\n- The manual method uses `base64` to encode the credentials and sets the `Authorization` header explicitly.\n\n---\n\n### **2. Using Postman**\n\n1. Open Postman and create a new request.\n2. Go to the **Authorization** tab.\n3. Select **Basic Auth** from the dropdown menu.\n4. Enter the `username` and `password` in the respective fields.\n5. Click **Send**.\n\nPostman will automatically encode the credentials and add the `Authorization` header for you.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\nYou can pass Basic Auth credentials in JavaScript using the `fetch` API:\n\n```javascript\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n**Explanation:**\n\n- The `btoa` function encodes the `username:password` string in Base64.\n- The encoded string is added to the `Authorization` header.\n\n---\n\n### **4. Using Axios**\n\nIf you're using **Axios**, you can pass Basic Auth credentials like this:\n\n```javascript\nconst axios = require(\"axios\");\n\nconst username = \"admin\";\nconst password = \"password123\";\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username,\n      password,\n    },\n  })\n  .then((response) => console.log(response.data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n**Explanation:**\n\n- The `auth` option automatically encodes the credentials and adds the `Authorization` header.\n\n---\n"
    },
    {
      "id": 48,
      "path": "examples/sse-implement",
      "name": "SSE Implement",
      "folder": "Examples",
      "content": "\n# üì° `app.sse(path, handler)`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## ‚úÖ Syntax\n\n```ts\napp.sse(path: string, handler: (ctx: Context) => Promise<Response> | Response)\n```\n\n---\n\n## üß† Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n---\n\n## üì• Parameters\n\n| Name      | Type       | Description                                     |\n| --------- | ---------- | ----------------------------------------------- |\n| `path`    | `string`   | The route path (e.g. `/events`)                 |\n| `handler` | `Function` | An async or sync function that returns a stream |\n\n---\n\n## üì§ Returns\n\n* The route is registered to send `ReadableStream` data in SSE-compliant format (`data: ...\\n\\n`).\n* The handler must return a response with appropriate headers.\n\n---\n\n## üì¶ Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## üìã Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.sse(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## üß™ Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"üî¥ Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n\n## üö® Notes\n\n* Only supports `GET` method (per SSE spec).\n* Requires `ReadableStream` and `TextEncoder`, which are supported in Node.js 18+, Bun, and modern runtimes.\n* Don't forget to clear intervals/timers on disconnect via `ctx.rawRequest?.signal`.\n\n---\n\n## ‚úÖ Ideal Use Cases\n\n* Live notifications\n* Real-time clock or status updates\n* Live logs / debugging streams\n* Chat message delivery (broadcast style)\n\n---\n\n## üß© Coming Soon Ideas (optional for docs)\n\n> You can optionally add features like:\n\n* `ctx.pushSSE(data)` helper\n* Broadcasting across multiple connections\n* Named event support (`event: custom\\n`)\n\n---\n\n## üìò Summary\n\n`app.sse()` is the easiest way to build **real-time push updates** over HTTP with zero frontend dependencies.\n\n---\n"
    }
  ]
}