{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": [
        {
          "originalPath": "tsfsd.md",
          "id": 1,
          "name": "Tsfsd",
          "type": "file",
          "path": "release-note/tsfsd",
          "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
        }
      ]
    },
    {
      "originalPath": "2. Need to know.md",
      "id": 2,
      "name": "Need To Know",
      "type": "file",
      "path": "need-to-know",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typescript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```typescript\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```typescript\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get('/uploads/*folder/:test', (ctx) => {\n    console.log(ctx.req.params)\n    return ctx.json({\n        success: true,\n        message: \"File uploaded successfully\"\n    });\n})\n\n```\n\n### **Syntax**\n\n```typescript\n\"/path/*wildcardParam\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```typescript\nimport { TezX } from \"tezx\";\nimport {loadEnv,} from \"tezx/helper\";\nimport {logger,} from \"tezx/middleware\";\nimport {nodeAdapter} from \"tezx/adapter\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger())\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```typescript\nimport {bunAdapter} from \"tezx/adapter\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```typescript\nimport {denoAdapter} from \"tezx/adapter\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```typescript\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n## üìú License\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```typescript\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n```typescript\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n```\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```typescript\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```typescript\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```typescript\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```typescript\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```typescript\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n## **Usage Example with Routes**\n\n```typescript\nimport {  Router, TezX } from \"tezx\";\nimport {logger} from \"tezx/middleware\";\nimport {loadEnv} from \"tezx/helper\";\nimport {denoAdapter} from \"tezx/adapter\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n     ```typescript\n     const app = new TezX({ overwriteMethod: false });\n     ```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n     ```typescript\n     const app = new TezX({ basePath: \"/v1\" });\n     ```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n     ```typescript\n     const logger = (msg: string) =>\n       console.log(`[${new Date().toISOString()}] ${msg}`);\n     ```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n     ```typescript\n     const port = app.config.env.PORT || \"3000\";\n     ```\n\n---\n"
        },
        {
          "originalPath": "6. Node.md",
          "id": 5,
          "name": "Node",
          "type": "file",
          "path": "getting-started/node",
          "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX,  } = require(\"tezx\");\nconst {logger} = require('tezx/middleware');\nconst {loadEnv} = require('tezx/helper');\nimport{nodeAdapter} from \"tezx/adapter\";\n\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger())\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n## üìú **License**\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
        },
        {
          "originalPath": "7. Bun.md",
          "id": 6,
          "name": "Bun",
          "type": "file",
          "path": "getting-started/bun",
          "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```typescript\nimport { TezX } from \"tezx\";\nimport {logger} from \"tezx/middleware\";\nimport {loadEnv} from \"tezx/helper\";\nimport{bunAdapter} from \"tezx/adapter\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
        },
        {
          "originalPath": "8. Deno.md",
          "id": 7,
          "name": "Deno",
          "type": "file",
          "path": "getting-started/deno",
          "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```typescript\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```typescript\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```typescript\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
        }
      ]
    },
    {
      "originalPath": "5. API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Middleware API",
          "name": "Middleware API",
          "path": "api/0-middleware-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Merging Middlewares.md",
              "id": 8,
              "name": "Merging Middlewares",
              "type": "file",
              "path": "api/middleware-api/merging-middlewares",
              "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```typescript\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```typescript\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```typescript\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n   ```typescript\n   const app = new TezX({ allowDuplicateMw: false });\n   ```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n     ```typescript\n     app.use(\"/test\", (ctx, next) => {\n       logger().info(\"Middleware m1\");\n       return next();\n     });\n     ```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 9,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware-api/middleware",
              "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```typescript\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` (to continue), a `TezResponse`, or a `Promise<TezResponse>`.\n\n#### **Example**\n\n```typescript\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n```typescript\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n#### **Example**\n\n```typescript\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```typescript\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```typescript\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```typescript\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```typescript\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```typescript\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```typescript\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```typescript\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```typescript\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```typescript\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```typescript\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  return next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```typescript\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```typescript\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n   ```typescript\n   server\n     .use(syncOperation) // Fast sync task\n     .use(asyncMiddleware); // Slower async task\n   ```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n   ```typescript\n   // ‚ùå Avoid\n   app.use(async (ctx, next) => {\n     await processLargeFile();\n     return next();\n   });\n\n   // ‚úÖ Prefer\n   app.get(\"/process\", (ctx) => processLargeFile());\n   ```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n   ```typescript\n   app.use((ctx, next) => {\n     ctx.cachedData = expensiveOperation();\n     return next();\n   });\n\n   app.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n   ```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `TezResponse`.            |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "1. Router",
          "name": "Router",
          "path": "api/1-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Router Merging.md",
              "id": 10,
              "name": "Router Merging",
              "type": "file",
              "path": "api/router/router-merging",
              "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```typescript\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```typescript\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```typescript\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```typescript\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n     ```typescript\n     const app = new TezX({ overwriteMethod: false });\n     ```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n     ```typescript\n     app.get(\"/test\", (ctx) => {\n       logger().info(\"Original /test handler\");\n       return ctx.text(\"Handler 1\");\n     });\n     ```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n     ```typescript\n     console.log(app.routes); // Inspect route tree (if exposed)\n     ```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
            },
            {
              "originalPath": "2. Router API.md",
              "id": 11,
              "name": "Router API",
              "type": "file",
              "path": "api/router/router-api",
              "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```mermaid\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```typescript\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```typescript\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```typescript\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```typescript\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```typescript\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```typescript\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```typescript\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```typescript\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```typescript\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```typescript\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```typescript\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```typescript\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
            },
            {
              "originalPath": "3. Route Parameter.md",
              "id": 12,
              "name": "Route Parameter",
              "type": "file",
              "path": "api/router/route-parameter",
              "content": "\n# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```typescript\n\"/path/:parameterName\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```typescript\n\"/path/:optionalParam?\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get('/uploads/*folder/:test', (ctx) => {\n    console.log(ctx.req.params)\n    return ctx.json({\n        success: true,\n        message: \"File uploaded successfully\"\n    });\n})\n\n```\n\n### **Syntax**\n\n```typescript\n\"/path/*wildcardParam\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```typescript\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll);      // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```typescript\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```typescript\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```typescript\napp.get(\"/users/:id\", handleUser);    // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```typescript\napp.get(\"/users/id/:id\", handleUser);      // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```typescript\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```typescript\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```typescript\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n     ```typescript\n     app.get(\"/api/static\", handleStatic);\n     app.get(\"/api/:id\", handleDynamic);\n     ```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n     ```typescript\n     const id = parseInt(ctx.req.params.id);\n     if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n     ```\n\n3. **Limit Optional Parameters**\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n     ```typescript\n     // Matches /api/v1/2023/users or /api/v1/users\n     app.get(\"/api/v1/:version?/:resource\", handleApi);\n     ```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n     ```typescript\n     app.get(\"/files/images/:id\", handleImage);\n     app.get(\"/files/*path\", handleFile);\n     ```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```typescript\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n|----------|----------------------|------------------------------------|\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```typescript\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```typescript\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method,                  // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```typescript\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```typescript\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods    | Custom Examples     |\n|---------------------|---------------------|\n| `GET`, `POST`, `PUT`| `PURGE`, `LOCK`     |\n| `PATCH`, `DELETE`   | `COPY`, `SEARCH`    |\n| `HEAD`, `OPTIONS`   | `CUSTOM_API`        |\n\n### **Examples**\n\n#### **Custom Method**\n\n```typescript\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group,   // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```typescript\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```typescript\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```typescript\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"];      // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method              | Path          | Priority | Match Example      |\n|---------------------|---------------|----------|-------------------|\n| `get()`             | `/cache/clear`| Highest  | `GET /cache/clear`|\n| `addMethod(\"PURGE\")`| `/cache`      | High     | `PURGE /cache`    |\n| `all()`             | `/cache/*`    | Medium   | `POST /cache/123` |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n   ```typescript\n   app.get(\"/api\", specificHandler);    // Higher priority\n   app.all(\"/*api\", globalMiddleware);   // Lower priority\n   ```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Context API.md",
              "id": 13,
              "name": "Context API",
              "type": "file",
              "path": "api/context/context-api",
              "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```typescript\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```typescript\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```typescript\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```typescript\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```typescript\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```typescript\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```typescript\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```typescript\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```typescript\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```typescript\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```typescript\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```typescript\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```typescript\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```typescript\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```typescript\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```typescript\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```typescript\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```typescript\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
            },
            {
              "originalPath": "2. State.md",
              "id": 14,
              "name": "State",
              "type": "file",
              "path": "api/context/state",
              "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```typescript\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```typescript\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```typescript\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```typescript\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```typescript\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n   ```typescript\n   ctx.state.set(\"auth:user\", authenticatedUser);\n   ```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n   ```typescript\n   ctx.state.delete(\"temporaryData\");\n   ```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n   ```typescript\n   interface AppState {\n     user?: { id: number; name: string };\n     requestId?: string;\n   }\n\n   ctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n   ```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n   ```typescript\n   app.use(async (ctx, next) => {\n     ctx.state.set(\"startTime\", Date.now());\n     await next();\n   });\n\n   app.get(\"/test\", (ctx) => {\n     const elapsed = Date.now() - ctx.state.get(\"startTime\");\n     return ctx.json({ elapsed });\n   });\n   ```\n\n---\n"
            },
            {
              "originalPath": "3. Context Propagation.md",
              "id": 15,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```typescript\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```typescript\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```typescript\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```typescript\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```typescript\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```typescript\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```typescript\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
            },
            {
              "originalPath": "4. Cookies.md",
              "id": 16,
              "name": "Cookies",
              "type": "file",
              "path": "api/context/cookies",
              "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```typescript\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```typescript\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```typescript\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n     ```typescript\n     const session = ctx.cookies.get(\"sessionToken\");\n     if (!session) return ctx.status(401).json({ error: \"No session\" });\n     ```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n     ```typescript\n     ctx.cookies.set(\"key\", \"value\");\n     logger().info(\"Cookie set: key\");\n     ```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Request",
          "name": "Request",
          "path": "api/3-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 17,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```typescript\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```typescript\ninterface UrlRef {\n  hash?: string; // e.g., \"#section\"\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n  console.log(url.hash); // \"details\"\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```typescript\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```typescript\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```typescript\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```typescript\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```typescript\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```typescript\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```typescript\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```typescript\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```typescript\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```typescript\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
            },
            {
              "originalPath": "2. Body Parser.md",
              "id": 18,
              "name": "Body Parser",
              "type": "file",
              "path": "api/request/body-parser",
              "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```typescript\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```typescript\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```typescript\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```typescript\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```typescript\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```typescript\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```typescript\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n   ```typescript\n   const stream = file.stream();\n   const transformer = new TransformStream();\n   // Process stream\n   ```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n   ```typescript\n   const form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n   ```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n   ```typescript\n   ctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n   ```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```typescript\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```typescript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```typescript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```typescript\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Response",
          "name": "Response",
          "path": "api/4-response",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Response.md",
              "id": 19,
              "name": "Response",
              "type": "file",
              "path": "api/response/response",
              "content": "# **Response**\n\n---\n\n### **Custom Response Alternative**\n\nFor manual control, use the native `Response` object:\n\n```typescript\napp.get(\"/data\", async (ctx) => {\n  return new Response(\"Hello World\", { status: 200 });\n});\n```\n\n---\n\n## **Methods**\n\n### **`json`**\n\n#### **Description**\n\nSends a JSON-formatted response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì The data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.json({ message: \"Success\" }, 200);\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.html(\"<h1>Welcome</h1>\", 200);\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.text(\"Hello, World!\", 200);\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.xml(\"<note><to>User</to><message>Hello</message></note>\", 200);\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type detection if not specified.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (string, object, etc.).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with inferred or specified content type.\n\n#### **Usage**\n\n```typescript\nreturn ctx.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with redirect headers (`Location`).\n\n#### **Usage**\n\n```typescript\nreturn ctx.redirect(\"https://example.com\");\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nInitiates a file download with a specified filename.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name presented to the client for download.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file directly to the client.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Absolute or relative path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream and appropriate headers.\n\n#### **Usage**\n\n```typescript\nreturn ctx.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n```\n\n---\n\n## **Notes**\n\n- **Cross-Runtime Support**: Compatible with Node.js, Bun, and Deno.\n- **Content-Type Handling**: Automatically sets appropriate `Content-Type` headers unless overridden.\n- **File Methods**: `download` and `sendFile` validate file existence before serving.\n- **Context Integration**: Methods are available directly on the `ctx` object for convenience.\n\n---\n\n## **Example Usage**\n\n```typescript\napp.get(\"/json\", (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\napp.get(\"/redirect\", (ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n\napp.get(\"/file\", async (ctx) => {\n  return ctx.sendFile(\"./assets/sample.pdf\");\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Status Codes**: Explicitly specify status codes for clarity (e.g., `201` for created resources).\n- **Headers**: Use custom headers for additional metadata (e.g., caching or rate-limiting info).\n- **Async Handling**: Ensure `await` is used with `download` and `sendFile` to handle file I/O properly.\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "5. Headers API.md",
      "id": 20,
      "name": "Headers API",
      "type": "file",
      "path": "headers-api",
      "content": "**Request and response headers are different.**\n\n---\n\n## **Core Methods**\n\n### **1. `add(headers: [string, string][] | Record<string, string>)`**\n\n**Purpose:** Add multiple headers without overwriting existing ones  \n**Behavior:**\n\n- Appends new headers while preserving existing ones\n- Merges values for duplicate headers\n\n```ts\n// Array of tuples example\nheaders.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"max-age=3600\"],\n]);\n\n// Object example\nheaders.add({\n  \"X-Custom-Header\": \"Value1\",\n  \"Accept-Encoding\": \"gzip\",\n});\n```\n\n---\n\n### **2. `set(key: string, value: string | string[])`**\n\n**Purpose:** Create or overwrite a header  \n**Behavior:**\n\n- Replaces all existing values for this header\n- Accepts single value or array of values\n\n```ts\n// Single value\nheaders.set(\"Authorization\", \"Bearer abc123\");\n\n// Multiple values\nheaders.set(\"Accept-Language\", [\"en-US\", \"fr-FR\"]);\n```\n\n---\n\n### **3. `get(key: string): string | undefined`**\n\n**Purpose:** Retrieve first value of a header\n\n```ts\nconst contentType = ctx.req.headers.get(\"content-type\");\n// \"application/json\" (case-insensitive)\n```\n\n---\n\n### **4. `getAll(key: string): string[]`**\n\n**Purpose:** Retrieve all values of a header\n\n```ts\nconst languages = ctx.req.headers.getAll(\"accept-language\");\n// [\"en-US\", \"fr-FR\"]\n```\n\n---\n\n### **5. `has(key: string): boolean`**\n\n**Purpose:** Check header existence\n\n```ts\nif (ctx.req.headers.has(\"x-auth-token\")) {\n  // Handle authentication\n}\n```\n\n---\n\n### **6. `delete(key: string): boolean`**\n\n**Purpose:** Remove a header  \n**Returns:** `true` if header existed, `false` otherwise\n\n```ts\nconst existed = ctx.req.headers.delete(\"expires\");\n```\n\n---\n\n### **7. `append(key: string, value: string)`**\n\n**Purpose:** Add value to existing header or create new\n\n```ts\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## **Iteration Methods**\n\n### **8. `entries(): Iterable<[string, string[]]>`**\n\n**Purpose:** Get [key, values] iterator\n\n```ts\nfor (const [header, values] of headers.entries()) {\n  console.log(`${header}: ${values.join(\", \")}`);\n}\n```\n\n### **9. `keys(): Iterable<string>`**\n\n**Purpose:** Get header names iterator\n\n```ts\nfor (const headerName of headers.keys()) {\n  console.log(\"Header present:\", headerName);\n}\n```\n\n### **10. `values(): Iterable<string[]>`**\n\n**Purpose:** Get header values iterator\n\n```ts\nfor (const values of headers.values()) {\n  console.log(\"Values:\", values);\n}\n```\n\n---\n\n## **Utility Methods**\n\n### **11. `forEach(callback: (values: string[], key: string) => void)`**\n\n**Purpose:** Iterate through headers\n\n```ts\nheaders.forEach((values, key) => {\n  console.log(`Header ${key} has ${values.length} values`);\n});\n```\n\n### **12. `toObject(): Record<string, string | string[]>`**\n\n**Purpose:** Convert to plain JS object\n\n```ts\nconst headerObj = headers.toObject();\n/* Returns:\n{\n  \"content-type\": \"application/json\",\n  \"accept-language\": [\"en-US\", \"fr-FR\"]\n}\n*/\n```\n\n---\n\n## **Usage Patterns**\n\n### **Request Header Modification**\n\n```ts\n// Middleware to add security headers\napp.use(async (ctx) => {\n  //ctx.header('Content-Security-Policy',\"default-src 'self'\");\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"X-Powered-By\");\n  await ctx.next();\n});\n```\n\n### **Response Header Handling**\n\n```ts\n// API versioning example\napp.get(\"/data\", (ctx) => {\n  ctx.headers.set(\"X-API-Version\", \"2.1\").append(\"Vary\", \"Accept-Encoding\");\n  return ctx.json({ data: \"...\" });\n});\n```\n\n---\n\n## **Header Operations Cheat Sheet**\n\n| Method       | Description            | Mutable | Returns               |\n| ------------ | ---------------------- | ------- | --------------------- |\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`                |\n| `set()`      | Replace header values  | ‚úÖ      | `void`                |\n| `get()`      | Get first header value | ‚ùå      | `string or undefined` |\n| `getAll()`   | Get all header values  | ‚ùå      | `string[]`            |\n| `has()`      | Check existence        | ‚ùå      | `boolean`             |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`             |\n| `append()`   | Add header value       | ‚úÖ      | `void`                |\n| `toObject()` | Serialize headers      | ‚ùå      | `Record`              |\n\n---\n"
    },
    {
      "originalPath": "9. Static File.md",
      "id": 21,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```typescript\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```typescript\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```typescript\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```typescript\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```typescript\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  ctx.body = \"Custom response overriding static file\";\n  return ctx;\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "originalPath": "97. Middlewares",
      "name": "Middlewares",
      "path": "middlewares",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. CORS Middleware.md",
          "id": 22,
          "name": "CORS Middleware",
          "type": "file",
          "path": "middlewares/cors-middleware",
          "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```typescript\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```typescript\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```typescript\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```typescript\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```typescript\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```typescript\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```typescript\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```typescript\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n   ```typescript\n   // ‚ùå Avoid in production\n   cors({ origin: \"*\" });\n   // ‚úÖ Secure setup\n   cors({ origin: process.env.ALLOWED_ORIGINS });\n   ```\n\n2. **Limit Exposed Headers**\n\n   ```typescript\n   cors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n   ```\n\n3. **Use Credentials Judiciously**\n\n   ```typescript\n   cors({ credentials: true }); // Enable only when required\n   ```\n\n4. **Pair with Rate Limiting**\n\n   ```typescript\n   app.use(rateLimiter());\n   app.use(cors());\n   ```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```typescript\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```typescript\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```mermaid\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```typescript\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```typescript\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```typescript\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```typescript\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```typescript\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n   ```typescript\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n   ```\n\n2. **Escape Characters**\n\n   ```typescript\n   const domain = \"special.domain.com\";\n   const escaped = domain.replace(/\\./g, \"\\\\.\");\n   new RegExp(`^https://${escaped}$`);\n   ```\n\n3. **Use Allow Lists**\n\n   ```typescript\n   const allowed = loadFromDB();\n   cors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n   ```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```typescript\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```typescript\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
        },
        {
          "originalPath": "2. Logger.md",
          "id": 23,
          "name": "Logger",
          "type": "file",
          "path": "middlewares/logger",
          "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
        },
        {
          "originalPath": "3. Powered By.md",
          "id": 24,
          "name": "Powered By",
          "type": "file",
          "path": "middlewares/powered-by",
          "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
        },
        {
          "originalPath": "4. Request ID.md",
          "id": 25,
          "name": "Request ID",
          "type": "file",
          "path": "middlewares/request-id",
          "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
        },
        {
          "originalPath": "5. Secure Headers.md",
          "id": 26,
          "name": "Secure Headers",
          "type": "file",
          "path": "middlewares/secure-headers",
          "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```typescript\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
        },
        {
          "originalPath": "6. XSS protection.md",
          "id": 27,
          "name": "XSS Protection",
          "type": "file",
          "path": "middlewares/xss-protection",
          "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```typescript\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```typescript\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```typescript\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```typescript\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```typescript\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
        },
        {
          "originalPath": "7. Sanitize Headers.md",
          "id": 28,
          "name": "Sanitize Headers",
          "type": "file",
          "path": "middlewares/sanitize-headers",
          "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```typescript\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```typescript\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```typescript\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```typescript\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```typescript\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```typescript\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n   ```typescript\n   // Recommended security-focused setup\n   app.use(\n     sanitizeHeaders({\n       whitelist: [\"accept\", \"content-type\", \"authorization\"],\n       normalizeKeys: true,\n     }),\n   );\n   ```\n\n2. **Information Hiding**:\n\n   ```typescript\n   // Hide server technology information\n   app.use(\n     sanitizeHeaders({\n       blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n     }),\n   );\n   ```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n    ```typescript\n    whitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n    ```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
        },
        {
          "originalPath": "8. Rate Limiter.md",
          "id": 29,
          "name": "Rate Limiter",
          "type": "file",
          "path": "middlewares/rate-limiter",
          "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n## Installation\n\n```typescript\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```typescript\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```typescript\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```typescript\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```typescript\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    ctx.body = { error: `Try again in ${retryAfter} seconds` };\n  };\n  ```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```typescript\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```typescript\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```typescript\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      ctx.body = {\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      };\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```typescript\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n   ```typescript\n   // Planned future usage\n   app.use(\n     rateLimiter({\n       maxRequests: 1000,\n       windowMs: 3600000,\n       storage: \"redis\",\n       redisClient: redis.createClient(),\n     }),\n   );\n   ```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```typescript\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```typescript\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```typescript\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
        }
      ]
    },
    {
      "originalPath": "98. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Load Environment.md",
          "id": 30,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```typescript\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```typescript\nimport { loadEnv } from \"tezx/helper\";\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```typescript\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```typescript\nconst app = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```typescript\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```typescript\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```typescript\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Basic.md",
          "id": 31,
          "name": "Basic",
          "type": "file",
          "path": "examples/basic",
          "content": ""
        },
        {
          "originalPath": "1. Uploader.md",
          "id": 32,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "release-note/tsfsd",
      "name": "Tsfsd",
      "folder": "Release Note",
      "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
    },
    {
      "id": 2,
      "path": "need-to-know",
      "name": "Need To Know",
      "folder": ".",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typescript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```typescript\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```typescript\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get('/uploads/*folder/:test', (ctx) => {\n    console.log(ctx.req.params)\n    return ctx.json({\n        success: true,\n        message: \"File uploaded successfully\"\n    });\n})\n\n```\n\n### **Syntax**\n\n```typescript\n\"/path/*wildcardParam\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```typescript\nimport { TezX } from \"tezx\";\nimport {loadEnv,} from \"tezx/helper\";\nimport {logger,} from \"tezx/middleware\";\nimport {nodeAdapter} from \"tezx/adapter\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger())\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```typescript\nimport {bunAdapter} from \"tezx/adapter\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```typescript\nimport {denoAdapter} from \"tezx/adapter\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```typescript\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n## üìú License\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```typescript\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n```typescript\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n```\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```typescript\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```typescript\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```typescript\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```typescript\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```typescript\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n## **Usage Example with Routes**\n\n```typescript\nimport {  Router, TezX } from \"tezx\";\nimport {logger} from \"tezx/middleware\";\nimport {loadEnv} from \"tezx/helper\";\nimport {denoAdapter} from \"tezx/adapter\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n     ```typescript\n     const app = new TezX({ overwriteMethod: false });\n     ```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n     ```typescript\n     const app = new TezX({ basePath: \"/v1\" });\n     ```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n     ```typescript\n     const logger = (msg: string) =>\n       console.log(`[${new Date().toISOString()}] ${msg}`);\n     ```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n     ```typescript\n     const port = app.config.env.PORT || \"3000\";\n     ```\n\n---\n"
    },
    {
      "id": 5,
      "path": "getting-started/node",
      "name": "Node",
      "folder": "Getting Started",
      "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX,  } = require(\"tezx\");\nconst {logger} = require('tezx/middleware');\nconst {loadEnv} = require('tezx/helper');\nimport{nodeAdapter} from \"tezx/adapter\";\n\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger())\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true,\n  },\n  \"include\": [\n    \"src\"\n  ],\n  \"exclude\": [\n    \"node_modules\",\n    \"dist\",\n    \"tests\"\n  ]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n## üìú **License**\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
    },
    {
      "id": 6,
      "path": "getting-started/bun",
      "name": "Bun",
      "folder": "Getting Started",
      "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```typescript\nimport { TezX } from \"tezx\";\nimport {logger} from \"tezx/middleware\";\nimport {loadEnv} from \"tezx/helper\";\nimport{bunAdapter} from \"tezx/adapter\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
    },
    {
      "id": 7,
      "path": "getting-started/deno",
      "name": "Deno",
      "folder": "Getting Started",
      "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```typescript\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```typescript\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```typescript\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```typescript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
    },
    {
      "id": 8,
      "path": "api/middleware-api/merging-middlewares",
      "name": "Merging Middlewares",
      "folder": "API/Middleware API",
      "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```typescript\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```typescript\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```typescript\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n   ```typescript\n   const app = new TezX({ allowDuplicateMw: false });\n   ```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n     ```typescript\n     app.use(\"/test\", (ctx, next) => {\n       logger().info(\"Middleware m1\");\n       return next();\n     });\n     ```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
    },
    {
      "id": 9,
      "path": "api/middleware-api/middleware",
      "name": "Middleware",
      "folder": "API/Middleware API",
      "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```typescript\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` (to continue), a `TezResponse`, or a `Promise<TezResponse>`.\n\n#### **Example**\n\n```typescript\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n```typescript\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n#### **Example**\n\n```typescript\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```typescript\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```typescript\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```typescript\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```typescript\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```typescript\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```typescript\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```typescript\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```typescript\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```typescript\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```typescript\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  return next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```typescript\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```typescript\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n   ```typescript\n   server\n     .use(syncOperation) // Fast sync task\n     .use(asyncMiddleware); // Slower async task\n   ```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n   ```typescript\n   // ‚ùå Avoid\n   app.use(async (ctx, next) => {\n     await processLargeFile();\n     return next();\n   });\n\n   // ‚úÖ Prefer\n   app.get(\"/process\", (ctx) => processLargeFile());\n   ```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n   ```typescript\n   app.use((ctx, next) => {\n     ctx.cachedData = expensiveOperation();\n     return next();\n   });\n\n   app.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n   ```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `TezResponse`.            |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
    },
    {
      "id": 10,
      "path": "api/router/router-merging",
      "name": "Router Merging",
      "folder": "API/Router",
      "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```typescript\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```typescript\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```typescript\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```typescript\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n     ```typescript\n     const app = new TezX({ overwriteMethod: false });\n     ```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n     ```typescript\n     app.get(\"/test\", (ctx) => {\n       logger().info(\"Original /test handler\");\n       return ctx.text(\"Handler 1\");\n     });\n     ```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n     ```typescript\n     console.log(app.routes); // Inspect route tree (if exposed)\n     ```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/router/router-api",
      "name": "Router API",
      "folder": "API/Router",
      "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```mermaid\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```typescript\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```typescript\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```typescript\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```typescript\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```typescript\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```typescript\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```typescript\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```typescript\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```typescript\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```typescript\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```typescript\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```typescript\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
    },
    {
      "id": 12,
      "path": "api/router/route-parameter",
      "name": "Route Parameter",
      "folder": "API/Router",
      "content": "\n# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```typescript\n\"/path/:parameterName\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```typescript\n\"/path/:optionalParam?\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get('/uploads/*folder/:test', (ctx) => {\n    console.log(ctx.req.params)\n    return ctx.json({\n        success: true,\n        message: \"File uploaded successfully\"\n    });\n})\n\n```\n\n### **Syntax**\n\n```typescript\n\"/path/*wildcardParam\"\n```\n\n### **Examples**\n\n```typescript\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```typescript\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll);      // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```typescript\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```typescript\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```typescript\napp.get(\"/users/:id\", handleUser);    // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```typescript\napp.get(\"/users/id/:id\", handleUser);      // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```typescript\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```typescript\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```typescript\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n     ```typescript\n     app.get(\"/api/static\", handleStatic);\n     app.get(\"/api/:id\", handleDynamic);\n     ```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n     ```typescript\n     const id = parseInt(ctx.req.params.id);\n     if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n     ```\n\n3. **Limit Optional Parameters**\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n     ```typescript\n     // Matches /api/v1/2023/users or /api/v1/users\n     app.get(\"/api/v1/:version?/:resource\", handleApi);\n     ```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n     ```typescript\n     app.get(\"/files/images/:id\", handleImage);\n     app.get(\"/files/*path\", handleFile);\n     ```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```typescript\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n|----------|----------------------|------------------------------------|\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```typescript\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```typescript\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method,                  // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```typescript\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```typescript\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods    | Custom Examples     |\n|---------------------|---------------------|\n| `GET`, `POST`, `PUT`| `PURGE`, `LOCK`     |\n| `PATCH`, `DELETE`   | `COPY`, `SEARCH`    |\n| `HEAD`, `OPTIONS`   | `CUSTOM_API`        |\n\n### **Examples**\n\n#### **Custom Method**\n\n```typescript\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group,   // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```typescript\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```typescript\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```typescript\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"];      // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method              | Path          | Priority | Match Example      |\n|---------------------|---------------|----------|-------------------|\n| `get()`             | `/cache/clear`| Highest  | `GET /cache/clear`|\n| `addMethod(\"PURGE\")`| `/cache`      | High     | `PURGE /cache`    |\n| `all()`             | `/cache/*`    | Medium   | `POST /cache/123` |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n   ```typescript\n   app.get(\"/api\", specificHandler);    // Higher priority\n   app.all(\"/*api\", globalMiddleware);   // Lower priority\n   ```\n\n---\n"
    },
    {
      "id": 13,
      "path": "api/context/context-api",
      "name": "Context API",
      "folder": "API/Context",
      "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```typescript\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```typescript\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```typescript\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```typescript\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```typescript\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```typescript\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```typescript\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```typescript\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```typescript\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```typescript\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```typescript\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```typescript\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```typescript\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```typescript\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```typescript\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```typescript\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```typescript\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```typescript\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
    },
    {
      "id": 14,
      "path": "api/context/state",
      "name": "State",
      "folder": "API/Context",
      "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```typescript\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```typescript\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```typescript\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```typescript\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```typescript\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```typescript\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```typescript\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n   ```typescript\n   ctx.state.set(\"auth:user\", authenticatedUser);\n   ```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n   ```typescript\n   ctx.state.delete(\"temporaryData\");\n   ```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n   ```typescript\n   interface AppState {\n     user?: { id: number; name: string };\n     requestId?: string;\n   }\n\n   ctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n   ```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n   ```typescript\n   app.use(async (ctx, next) => {\n     ctx.state.set(\"startTime\", Date.now());\n     await next();\n   });\n\n   app.get(\"/test\", (ctx) => {\n     const elapsed = Date.now() - ctx.state.get(\"startTime\");\n     return ctx.json({ elapsed });\n   });\n   ```\n\n---\n"
    },
    {
      "id": 15,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```typescript\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```typescript\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```typescript\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```typescript\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```typescript\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```typescript\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```typescript\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```typescript\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
    },
    {
      "id": 16,
      "path": "api/context/cookies",
      "name": "Cookies",
      "folder": "API/Context",
      "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```typescript\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```typescript\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```typescript\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n     ```typescript\n     const session = ctx.cookies.get(\"sessionToken\");\n     if (!session) return ctx.status(401).json({ error: \"No session\" });\n     ```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n     ```typescript\n     ctx.cookies.set(\"key\", \"value\");\n     logger().info(\"Cookie set: key\");\n     ```\n\n---\n"
    },
    {
      "id": 17,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```typescript\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```typescript\ninterface UrlRef {\n  hash?: string; // e.g., \"#section\"\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```typescript\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n  console.log(url.hash); // \"details\"\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```typescript\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```typescript\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```typescript\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```typescript\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```typescript\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```typescript\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```typescript\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```typescript\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```typescript\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```typescript\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
    },
    {
      "id": 18,
      "path": "api/request/body-parser",
      "name": "Body Parser",
      "folder": "API/Request",
      "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```typescript\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```typescript\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```typescript\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```typescript\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```typescript\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```typescript\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```typescript\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n   ```typescript\n   const stream = file.stream();\n   const transformer = new TransformStream();\n   // Process stream\n   ```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n   ```typescript\n   const form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n   ```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n   ```typescript\n   ctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n   ```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```typescript\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```typescript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```typescript\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```typescript\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
    },
    {
      "id": 19,
      "path": "api/response/response",
      "name": "Response",
      "folder": "API/Response",
      "content": "# **Response**\n\n---\n\n### **Custom Response Alternative**\n\nFor manual control, use the native `Response` object:\n\n```typescript\napp.get(\"/data\", async (ctx) => {\n  return new Response(\"Hello World\", { status: 200 });\n});\n```\n\n---\n\n## **Methods**\n\n### **`json`**\n\n#### **Description**\n\nSends a JSON-formatted response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì The data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.json({ message: \"Success\" }, 200);\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.html(\"<h1>Welcome</h1>\", 200);\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.text(\"Hello, World!\", 200);\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.xml(\"<note><to>User</to><message>Hello</message></note>\", 200);\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type detection if not specified.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (string, object, etc.).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with inferred or specified content type.\n\n#### **Usage**\n\n```typescript\nreturn ctx.send(\"Custom Content\", 200, { \"X-Custom-Header\": \"value\" });\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` object with redirect headers (`Location`).\n\n#### **Usage**\n\n```typescript\nreturn ctx.redirect(\"https://example.com\");\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nInitiates a file download with a specified filename.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name presented to the client for download.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\nreturn ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file directly to the client.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Absolute or relative path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream and appropriate headers.\n\n#### **Usage**\n\n```typescript\nreturn ctx.sendFile(\"/path/to/image.jpg\", \"picture.jpg\");\n```\n\n---\n\n## **Notes**\n\n- **Cross-Runtime Support**: Compatible with Node.js, Bun, and Deno.\n- **Content-Type Handling**: Automatically sets appropriate `Content-Type` headers unless overridden.\n- **File Methods**: `download` and `sendFile` validate file existence before serving.\n- **Context Integration**: Methods are available directly on the `ctx` object for convenience.\n\n---\n\n## **Example Usage**\n\n```typescript\napp.get(\"/json\", (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\napp.get(\"/redirect\", (ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n\napp.get(\"/file\", async (ctx) => {\n  return ctx.sendFile(\"./assets/sample.pdf\");\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Status Codes**: Explicitly specify status codes for clarity (e.g., `201` for created resources).\n- **Headers**: Use custom headers for additional metadata (e.g., caching or rate-limiting info).\n- **Async Handling**: Ensure `await` is used with `download` and `sendFile` to handle file I/O properly.\n\n---\n"
    },
    {
      "id": 20,
      "path": "headers-api",
      "name": "Headers API",
      "folder": ".",
      "content": "**Request and response headers are different.**\n\n---\n\n## **Core Methods**\n\n### **1. `add(headers: [string, string][] | Record<string, string>)`**\n\n**Purpose:** Add multiple headers without overwriting existing ones  \n**Behavior:**\n\n- Appends new headers while preserving existing ones\n- Merges values for duplicate headers\n\n```ts\n// Array of tuples example\nheaders.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"max-age=3600\"],\n]);\n\n// Object example\nheaders.add({\n  \"X-Custom-Header\": \"Value1\",\n  \"Accept-Encoding\": \"gzip\",\n});\n```\n\n---\n\n### **2. `set(key: string, value: string | string[])`**\n\n**Purpose:** Create or overwrite a header  \n**Behavior:**\n\n- Replaces all existing values for this header\n- Accepts single value or array of values\n\n```ts\n// Single value\nheaders.set(\"Authorization\", \"Bearer abc123\");\n\n// Multiple values\nheaders.set(\"Accept-Language\", [\"en-US\", \"fr-FR\"]);\n```\n\n---\n\n### **3. `get(key: string): string | undefined`**\n\n**Purpose:** Retrieve first value of a header\n\n```ts\nconst contentType = ctx.req.headers.get(\"content-type\");\n// \"application/json\" (case-insensitive)\n```\n\n---\n\n### **4. `getAll(key: string): string[]`**\n\n**Purpose:** Retrieve all values of a header\n\n```ts\nconst languages = ctx.req.headers.getAll(\"accept-language\");\n// [\"en-US\", \"fr-FR\"]\n```\n\n---\n\n### **5. `has(key: string): boolean`**\n\n**Purpose:** Check header existence\n\n```ts\nif (ctx.req.headers.has(\"x-auth-token\")) {\n  // Handle authentication\n}\n```\n\n---\n\n### **6. `delete(key: string): boolean`**\n\n**Purpose:** Remove a header  \n**Returns:** `true` if header existed, `false` otherwise\n\n```ts\nconst existed = ctx.req.headers.delete(\"expires\");\n```\n\n---\n\n### **7. `append(key: string, value: string)`**\n\n**Purpose:** Add value to existing header or create new\n\n```ts\nheaders.append(\"Vary\", \"User-Agent\");\nheaders.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## **Iteration Methods**\n\n### **8. `entries(): Iterable<[string, string[]]>`**\n\n**Purpose:** Get [key, values] iterator\n\n```ts\nfor (const [header, values] of headers.entries()) {\n  console.log(`${header}: ${values.join(\", \")}`);\n}\n```\n\n### **9. `keys(): Iterable<string>`**\n\n**Purpose:** Get header names iterator\n\n```ts\nfor (const headerName of headers.keys()) {\n  console.log(\"Header present:\", headerName);\n}\n```\n\n### **10. `values(): Iterable<string[]>`**\n\n**Purpose:** Get header values iterator\n\n```ts\nfor (const values of headers.values()) {\n  console.log(\"Values:\", values);\n}\n```\n\n---\n\n## **Utility Methods**\n\n### **11. `forEach(callback: (values: string[], key: string) => void)`**\n\n**Purpose:** Iterate through headers\n\n```ts\nheaders.forEach((values, key) => {\n  console.log(`Header ${key} has ${values.length} values`);\n});\n```\n\n### **12. `toObject(): Record<string, string | string[]>`**\n\n**Purpose:** Convert to plain JS object\n\n```ts\nconst headerObj = headers.toObject();\n/* Returns:\n{\n  \"content-type\": \"application/json\",\n  \"accept-language\": [\"en-US\", \"fr-FR\"]\n}\n*/\n```\n\n---\n\n## **Usage Patterns**\n\n### **Request Header Modification**\n\n```ts\n// Middleware to add security headers\napp.use(async (ctx) => {\n  //ctx.header('Content-Security-Policy',\"default-src 'self'\");\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"X-Powered-By\");\n  await ctx.next();\n});\n```\n\n### **Response Header Handling**\n\n```ts\n// API versioning example\napp.get(\"/data\", (ctx) => {\n  ctx.headers.set(\"X-API-Version\", \"2.1\").append(\"Vary\", \"Accept-Encoding\");\n  return ctx.json({ data: \"...\" });\n});\n```\n\n---\n\n## **Header Operations Cheat Sheet**\n\n| Method       | Description            | Mutable | Returns               |\n| ------------ | ---------------------- | ------- | --------------------- |\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`                |\n| `set()`      | Replace header values  | ‚úÖ      | `void`                |\n| `get()`      | Get first header value | ‚ùå      | `string or undefined` |\n| `getAll()`   | Get all header values  | ‚ùå      | `string[]`            |\n| `has()`      | Check existence        | ‚ùå      | `boolean`             |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`             |\n| `append()`   | Add header value       | ‚úÖ      | `void`                |\n| `toObject()` | Serialize headers      | ‚ùå      | `Record`              |\n\n---\n"
    },
    {
      "id": 21,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```typescript\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```typescript\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```typescript\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```typescript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```typescript\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```typescript\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  ctx.body = \"Custom response overriding static file\";\n  return ctx;\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "id": 22,
      "path": "middlewares/cors-middleware",
      "name": "CORS Middleware",
      "folder": "Middlewares",
      "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```typescript\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```typescript\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```typescript\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```typescript\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```typescript\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```typescript\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```typescript\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```typescript\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```typescript\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n   ```typescript\n   // ‚ùå Avoid in production\n   cors({ origin: \"*\" });\n   // ‚úÖ Secure setup\n   cors({ origin: process.env.ALLOWED_ORIGINS });\n   ```\n\n2. **Limit Exposed Headers**\n\n   ```typescript\n   cors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n   ```\n\n3. **Use Credentials Judiciously**\n\n   ```typescript\n   cors({ credentials: true }); // Enable only when required\n   ```\n\n4. **Pair with Rate Limiting**\n\n   ```typescript\n   app.use(rateLimiter());\n   app.use(cors());\n   ```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```typescript\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```typescript\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```mermaid\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```typescript\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```typescript\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```typescript\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```typescript\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```typescript\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n   ```typescript\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n   ```\n\n2. **Escape Characters**\n\n   ```typescript\n   const domain = \"special.domain.com\";\n   const escaped = domain.replace(/\\./g, \"\\\\.\");\n   new RegExp(`^https://${escaped}$`);\n   ```\n\n3. **Use Allow Lists**\n\n   ```typescript\n   const allowed = loadFromDB();\n   cors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n   ```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```typescript\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```typescript\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
    },
    {
      "id": 23,
      "path": "middlewares/logger",
      "name": "Logger",
      "folder": "Middlewares",
      "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
    },
    {
      "id": 24,
      "path": "middlewares/powered-by",
      "name": "Powered By",
      "folder": "Middlewares",
      "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
    },
    {
      "id": 25,
      "path": "middlewares/request-id",
      "name": "Request ID",
      "folder": "Middlewares",
      "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
    },
    {
      "id": 26,
      "path": "middlewares/secure-headers",
      "name": "Secure Headers",
      "folder": "Middlewares",
      "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```typescript\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
    },
    {
      "id": 27,
      "path": "middlewares/xss-protection",
      "name": "XSS Protection",
      "folder": "Middlewares",
      "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```typescript\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```typescript\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```typescript\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```typescript\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```typescript\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
    },
    {
      "id": 28,
      "path": "middlewares/sanitize-headers",
      "name": "Sanitize Headers",
      "folder": "Middlewares",
      "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```typescript\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```typescript\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```typescript\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```typescript\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```typescript\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```typescript\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n   ```typescript\n   // Recommended security-focused setup\n   app.use(\n     sanitizeHeaders({\n       whitelist: [\"accept\", \"content-type\", \"authorization\"],\n       normalizeKeys: true,\n     }),\n   );\n   ```\n\n2. **Information Hiding**:\n\n   ```typescript\n   // Hide server technology information\n   app.use(\n     sanitizeHeaders({\n       blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n     }),\n   );\n   ```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n    ```typescript\n    whitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n    ```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
    },
    {
      "id": 29,
      "path": "middlewares/rate-limiter",
      "name": "Rate Limiter",
      "folder": "Middlewares",
      "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n## Installation\n\n```typescript\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```typescript\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```typescript\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```typescript\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```typescript\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```typescript\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    ctx.body = { error: `Try again in ${retryAfter} seconds` };\n  };\n  ```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```typescript\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```typescript\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```typescript\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      ctx.body = {\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      };\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```typescript\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n   ```typescript\n   // Planned future usage\n   app.use(\n     rateLimiter({\n       maxRequests: 1000,\n       windowMs: 3600000,\n       storage: \"redis\",\n       redisClient: redis.createClient(),\n     }),\n   );\n   ```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```typescript\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```typescript\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```typescript\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
    },
    {
      "id": 30,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```typescript\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```typescript\nimport { loadEnv } from \"tezx/helper\";\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```typescript\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```typescript\nconst app = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```typescript\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```typescript\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```typescript\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
    },
    {
      "id": 31,
      "path": "examples/basic",
      "name": "Basic",
      "folder": "Examples",
      "content": ""
    },
    {
      "id": 32,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
    }
  ]
}