{
  "structure": [
    {
      "originalPath": "1. Release Note",
      "name": "Release Note",
      "path": "release-note",
      "type": "folder",
      "children": [
        {
          "originalPath": "tsfsd.md",
          "id": 1,
          "name": "Tsfsd",
          "type": "file",
          "path": "release-note/tsfsd",
          "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
        }
      ]
    },
    {
      "originalPath": "2. Need to know.md",
      "id": 2,
      "name": "Need To Know",
      "type": "file",
      "path": "need-to-know",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typecript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```ts\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```ts\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\nimport { nodeAdapter } from \"tezx/adapter\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { bunAdapter } from \"tezx/adapter\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { denoAdapter } from \"tezx/adapter\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n## üìú License\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n```ts\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n```\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```ts\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```ts\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```ts\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n## **Usage Example with Routes**\n\n```ts\nimport { Router, TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { loadEnv } from \"tezx/helper\";\nimport { denoAdapter } from \"tezx/adapter\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n```ts\nconst logger = (msg: string) =>\n  console.log(`[${new Date().toISOString()}] ${msg}`);\n```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n```ts\nconst port = app.config.env.PORT || \"3000\";\n```\n\n---\n"
        },
        {
          "originalPath": "6. Node.md",
          "id": 5,
          "name": "Node",
          "type": "file",
          "path": "getting-started/node",
          "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX } = require(\"tezx\");\nconst { logger } = require(\"tezx/middleware\");\nconst { loadEnv } = require(\"tezx/helper\");\nimport { nodeAdapter } from \"tezx/adapter\";\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n## üìú **License**\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
        },
        {
          "originalPath": "7. Bun.md",
          "id": 6,
          "name": "Bun",
          "type": "file",
          "path": "getting-started/bun",
          "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { loadEnv } from \"tezx/helper\";\nimport { bunAdapter } from \"tezx/adapter\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
        },
        {
          "originalPath": "8. Deno.md",
          "id": 7,
          "name": "Deno",
          "type": "file",
          "path": "getting-started/deno",
          "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```ts\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```ts\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```ts\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
        }
      ]
    },
    {
      "originalPath": "5. API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Middleware API",
          "name": "Middleware API",
          "path": "api/0-middleware-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Merging Middlewares.md",
              "id": 8,
              "name": "Merging Middlewares",
              "type": "file",
              "path": "api/middleware-api/merging-middlewares",
              "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```ts\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n```ts\nconst app = new TezX({ allowDuplicateMw: false });\n```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n```ts\napp.use(\"/test\", (ctx, next) => {\n  logger().info(\"Middleware m1\");\n  return next();\n});\n```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 9,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware-api/middleware",
              "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```ts\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` (to continue), a `TezResponse`, or a `Promise<TezResponse>`.\n\n#### **Example**\n\n```ts\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n```ts\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n#### **Example**\n\n```ts\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```ts\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```ts\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```ts\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```ts\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```ts\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```ts\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```ts\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```ts\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```ts\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  return next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```ts\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```ts\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n```ts\nserver\n  .use(syncOperation) // Fast sync task\n  .use(asyncMiddleware); // Slower async task\n```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n```ts\n// ‚ùå Avoid\napp.use(async (ctx, next) => {\n  await processLargeFile();\n  return next();\n});\n\n// ‚úÖ Prefer\napp.get(\"/process\", (ctx) => processLargeFile());\n```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n```ts\napp.use((ctx, next) => {\n  ctx.cachedData = expensiveOperation();\n  return next();\n});\n\napp.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `TezResponse`.            |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "1. Router",
          "name": "Router",
          "path": "api/1-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Router Merging.md",
              "id": 10,
              "name": "Router Merging",
              "type": "file",
              "path": "api/router/router-merging",
              "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```ts\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```ts\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n```ts\napp.get(\"/test\", (ctx) => {\n  logger().info(\"Original /test handler\");\n  return ctx.text(\"Handler 1\");\n});\n```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n```ts\nconsole.log(app.routes); // Inspect route tree (if exposed)\n```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
            },
            {
              "originalPath": "2. Router API.md",
              "id": 11,
              "name": "Router API",
              "type": "file",
              "path": "api/router/router-api",
              "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```bash\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```ts\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```ts\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```ts\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```ts\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```ts\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```ts\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```ts\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
            },
            {
              "originalPath": "3. Route Parameter.md",
              "id": 12,
              "name": "Route Parameter",
              "type": "file",
              "path": "api/router/route-parameter",
              "content": "# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```ts\n\"/path/:parameterName\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```ts\n\"/path/:optionalParam?\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```ts\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```ts\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```ts\napp.get(\"/users/id/:id\", handleUser); // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```ts\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```ts\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n```ts\napp.get(\"/api/static\", handleStatic);\napp.get(\"/api/:id\", handleDynamic);\n```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n```ts\nconst id = parseInt(ctx.req.params.id);\nif (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n```\n\n3. **Limit Optional Parameters**\n\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n```ts\n// Matches /api/v1/2023/users or /api/v1/users\napp.get(\"/api/v1/:version?/:resource\", handleApi);\n```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n```ts\napp.get(\"/files/images/:id\", handleImage);\napp.get(\"/files/*path\", handleFile);\n```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```ts\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n| -------- | -------------------- | ---------------------------------- |\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```ts\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method, // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```ts\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods     | Custom Examples  |\n| -------------------- | ---------------- |\n| `GET`, `POST`, `PUT` | `PURGE`, `LOCK`  |\n| `PATCH`, `DELETE`    | `COPY`, `SEARCH` |\n| `HEAD`, `OPTIONS`    | `CUSTOM_API`     |\n\n### **Examples**\n\n#### **Custom Method**\n\n```ts\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```ts\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```ts\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```ts\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"]; // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method               | Path           | Priority | Match Example      |\n| -------------------- | -------------- | -------- | ------------------ |\n| `get()`              | `/cache/clear` | Highest  | `GET /cache/clear` |\n| `addMethod(\"PURGE\")` | `/cache`       | High     | `PURGE /cache`     |\n| `all()`              | `/cache/*`     | Medium   | `POST /cache/123`  |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n```ts\napp.get(\"/api\", specificHandler); // Higher priority\napp.all(\"/*api\", globalMiddleware); // Lower priority\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Context API.md",
              "id": 13,
              "name": "Context API",
              "type": "file",
              "path": "api/context/context-api",
              "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```ts\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```ts\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```ts\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```ts\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```ts\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```ts\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```ts\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```ts\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```ts\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
            },
            {
              "originalPath": "2. State.md",
              "id": 14,
              "name": "State",
              "type": "file",
              "path": "api/context/state",
              "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```ts\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```ts\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```ts\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```ts\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```ts\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```ts\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n```ts\nctx.state.set(\"auth:user\", authenticatedUser);\n```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n```ts\nctx.state.delete(\"temporaryData\");\n```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n```ts\ninterface AppState {\n  user?: { id: number; name: string };\n  requestId?: string;\n}\n\nctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.state.set(\"startTime\", Date.now());\n  await next();\n});\n\napp.get(\"/test\", (ctx) => {\n  const elapsed = Date.now() - ctx.state.get(\"startTime\");\n  return ctx.json({ elapsed });\n});\n```\n\n---\n"
            },
            {
              "originalPath": "3. Context Propagation.md",
              "id": 15,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```ts\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```ts\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```ts\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```ts\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
            },
            {
              "originalPath": "4. Cookies.md",
              "id": 16,
              "name": "Cookies",
              "type": "file",
              "path": "api/context/cookies",
              "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```ts\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n```ts\nconst session = ctx.cookies.get(\"sessionToken\");\nif (!session) return ctx.status(401).json({ error: \"No session\" });\n```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n```ts\nctx.cookies.set(\"key\", \"value\");\nlogger().info(\"Cookie set: key\");\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Request",
          "name": "Request",
          "path": "api/3-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 17,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```ts\ninterface UrlRef {\n  hash?: string; // e.g., \"#section\"\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n  console.log(url.hash); // \"details\"\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```ts\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```ts\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```ts\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```ts\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```ts\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
            },
            {
              "originalPath": "2. Body Parser.md",
              "id": 18,
              "name": "Body Parser",
              "type": "file",
              "path": "api/request/body-parser",
              "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```ts\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```ts\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```ts\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```ts\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n```ts\nconst stream = file.stream();\nconst transformer = new TransformStream();\n// Process stream\n```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n```ts\nconst form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n```ts\nctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```ts\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```ts\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Response",
          "name": "Response",
          "path": "api/4-response",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Response.md",
              "id": 19,
              "name": "Response",
              "type": "file",
              "path": "api/response/response",
              "content": "# **Response**\n\n---\n\n## **Overview**\n\nThe `Response` methods are part of a web framework's context (`ctx`) object, enabling developers to send HTTP responses in various formats. The `Callback` type supports flexible return values, including `string`, `Record<string, any>`, `Response`, and now supports setting `ctx.body` to any value, which is automatically converted to a `Response`. This documentation details each method, the new `ctx.body` feature, their parameters, return types, and usage examples.\n\n### **Type Definitions**\n\n```typescript\nexport type NextCallback = () => Promise<any>;\n\nexport type ctx<T extends Record<string, any> = {}> = Context<T> &\n  T & {\n    body?: any; // New property to hold response body\n  };\n\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => Promise<Response | void> | Response | string | Record<string, any> | void;\n```\n\n- **`NextCallback`**: A function returning a `Promise` for middleware chaining.\n- **`ctx<T>`**: The context object, extensible with custom properties via `T`, now including an optional `body` property of type `any`.\n- **`Callback<T>`**: A handler function that can return:\n  - `Promise<Response | void>`: Asynchronous response or no response.\n  - `Response`: A native HTTP response object.\n  - `string`: Plain text response.\n  - `Record<string, any>`: JSON-serializable object.\n  - `void`: No response (e.g., for middleware). If `ctx.body` is set, it is automatically wrapped as a `Response`.\n\n---\n\n## **Custom Response**\n\nFor fine-grained control, return a native `Response` object directly:\n\n```typescript\napp.get(\"/data\", async (ctx: ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## **üîß Using `ctx.body`**\n\n### **üìñ Description**\n\n`ctx.body` allows you to assign a response value inside a handler without explicitly returning a `Response`.  \nIf a handler does **not** return a value, the framework automatically constructs a `Response` using `ctx.body`, with intelligent content type and status inference.\n\n---\n\n### **üß† Priority Logic:**\n\n1. If the handler **returns** a value, it takes precedence.\n2. If the handler returns `undefined`, then `ctx.body` (if set) will be used to generate the response.\n\n---\n\n### **‚öôÔ∏è Behavior**\n\n- **üß© Type Inference:**\n\n  - `string` ‚Üí `Content-Type: text/plain`\n  - `object` (e.g. `{}`) ‚Üí `Content-Type: application/json`\n  - Other types ‚Üí Converts to string using `.toString()` (fallback to `text/plain`)\n\n- **‚úÖ Default Status**: `200 OK` (can be overridden using `ctx.status`)\n\n- **üì¨ Custom Headers**: Set via `ctx.set(\"Header-Name\", \"value\")` or `ctx.header()` method if defined.\n\n---\n\n### **üìå Usage Examples**\n\n```ts\n// Respond with plain text\napp.get(\"/text\", (ctx) => {\n  ctx.body = \"Hello from ctx.body!\";\n  // Responds with text/plain and status 200\n});\n\n// Respond with JSON\napp.get(\"/json\", (ctx) => {\n  ctx.body = { message: \"Hello\", status: \"ok\" };\n  // Responds with application/json and status 200\n});\n\n// Example with custom status and headers\napp.get(\"/custom\", (ctx) => {\n  ctx.status = 201;\n  ctx.set(\"X-Custom-Header\", \"Tezx\");\n  ctx.body = { created: true };\n});\n```\n\n---\n\n## **Response Methods**\n\n### **`json`**\n\n#### **Description**\n\nSerializes and sends a JSON response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  return ctx.json({ message: \"Success\" }, 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  ctx.body = { message: \"Success\" };\n});\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  return ctx.html(\"<h1>Hello</h1>\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  ctx.header(\"content-type\", \"text/html\");\n  ctx.body = \"<h1>Hello</h1>\"; // Served as text/plain unless ctx.html() is used\n});\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  return ctx.text(\"Hello, World!\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  ctx.body = \"Hello, World!\";\n});\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  return ctx.xml(\"<note><msg>Hello</msg></note>\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  ctx.body = \"<note><msg>Hello</msg></note>\"; // Served as text/plain unless ctx.xml() is used\n});\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type inference.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (e.g., `string`, `object`).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with inferred `Content-Type`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  return ctx.send(\"Custom Content\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  ctx.body = \"Custom Content\";\n});\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Location` header.\n\n#### **Usage**\n\n```typescript\napp.get(\"/redirect\", (ctx: ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nTriggers a file download.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name for the downloaded file.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/download\", async (ctx: ctx) => {\n  return ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n});\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream.\n\n#### **Usage**\n\n```typescript\napp.get(\"/file\", async (ctx: ctx) => {\n  return ctx.sendFile(\"/path/to/image.jpg\");\n});\n```\n\n---\n\n## **Key Features**\n\n- **Flexible Returns**: The `Callback` supports:\n  - `string`: Sent as `text/plain`.\n  - `Record<string, any>`: Sent as `application/json`.\n  - `Response`: Custom response.\n  - `Promise`: Async handling.\n  - `void`: No explicit return; uses `ctx.body` if set.\n- **`ctx.body`**: Automatically wrapped as a `Response` with inferred content-type if no explicit return is provided.\n- **Type Safety**: Extend `ctx<T>` for custom properties (e.g., `ctx<{ userId: string }>`).\n- **Cross-Runtime**: Compatible with Node.js, Bun, and Deno.\n\n---\n\n## **Examples**\n\n### **Using `ctx.body` with String**\n\n```typescript\napp.get(\"/greet\", (ctx: ctx) => {\n  ctx.body = \"Hello, World!\";\n});\n```\n\n### **Using `ctx.body` with Object**\n\n```typescript\napp.get(\"/user\", (ctx: ctx) => {\n  ctx.body = { id: 1, name: \"Alice\" };\n});\n```\n\n### **Direct Returns**\n\n```typescript\napp.get(\"/direct\", (ctx: ctx) => {\n  return \"Direct Hello\"; // text/plain\n});\n\napp.get(\"/direct-obj\", (ctx: ctx) => {\n  return { data: \"Direct Object\" }; // application/json\n});\n```\n\n### **Mixed Usage**\n\n```typescript\napp.get(\"/mixed\", (ctx: ctx) => {\n  if (someCondition) {\n    return ctx.json({ error: \"Not found\" }, 404);\n  }\n  ctx.body = \"All good\";\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Use `ctx.body`**: For simple responses without explicit formatting.\n- **Explicit Methods**: Use `ctx.json()`, `ctx.html()`, etc., for specific content-types.\n- **Status Codes**: Set explicitly when needed (e.g., `ctx.status = 201` with `ctx.body`).\n- **Async Safety**: `await` file methods like `download` and `sendFile`.\n- **Type Extensions**: Use `ctx<T>` for type-safe custom properties.\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "5. Headers API",
          "name": "Headers API",
          "path": "api/5-headers-api",
          "type": "folder",
          "children": [
            {
              "originalPath": "1.Request Headers.md",
              "id": 20,
              "name": "Request Headers",
              "type": "file",
              "path": "api/headers-api/request-headers",
              "content": "\n# Request Headers (`ctx.req.headers`)\n\n## Overview\n\nThe `ctx.req.headers` property provides a read-only interface for accessing HTTP request headers sent by the client. Exposed as a getter, it returns an object with methods to query and iterate over header data, ensuring immutability and predictable behavior. This API is designed for inspecting request metadata such as content types, authentication tokens, and client preferences.\n\n### Key Features\n\n- **Read-Only Access**: Provides methods to retrieve and inspect headers without modification.\n- **Case-Insensitive Keys**: Normalizes header names to lowercase for consistent handling.\n- **Multi-Value Support**: Handles headers with multiple values (e.g., `Accept`).\n- **Iterator Support**: Offers flexible iteration over keys, values, and entries.\n\n### Context\n\n- **Location**: Available as `ctx.req.headers` within a `Context` object.\n- **Purpose**: Represents headers received in the HTTP request from the client.\n\n---\n\n## Implementation Context\n\nThe `ctx.req.headers` is implemented as a getter that returns an object with the following methods, backed by an internal `#headers` store (assumed to be a `Map`-like structure):\n\n```typescript\nget: function get(key: string): string | undefined {\n  return requestHeaders.get(key.toLowerCase());\n}\ngetAll: function getAll(key: string) {\n  return requestHeaders.get(key.toLowerCase()) || [];\n},\nhas: function has(key: string): boolean {\n  return requestHeaders.has(key.toLowerCase());\n}\nentries: function entries(): IterableIterator<[string, string[]]> {\n  return requestHeaders.entries();\n}\nkeys: function keys(): IterableIterator<string> {\n  return requestHeaders.keys();\n}\nvalues: function values(): IterableIterator<string[]> {\n  return requestHeaders.values();\n}\nforEach: function forEach(callback: (value: string[], key: string) => void): void {\n  return requestHeaders.forEach(callback);\n}\ntoObject: function toObject(): Record<string, string | string[]> {\n  return requestHeaders.toObject();\n}\n```\n\n---\n\n## Core Methods\n\n### 1. `get(key: string): string | undefined`\n\n#### Description\n\nRetrieves the first value of a specified request header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `string`: First value if the header exists.\n- `undefined`: If the header is not present.\n\n#### Example\n\n```typescript\nconst contentType = ctx.req.headers.get(\"content-type\");\n// Returns \"application/json\" or undefined\n```\n\n---\n\n### 2. `getAll(key: string): string[]`\n\n#### Description\n\nRetrieves all values for a specified request header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `string[]`: Array of all values; empty array if header is not present.\n\n#### Example\n\n```typescript\nconst accepts = ctx.req.headers.getAll(\"accept\");\n// Returns [\"application/json\", \"text/html\"] or []\n```\n\n---\n\n### 3. `has(key: string): boolean`\n\n#### Description\n\nChecks if a header exists in the request headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `boolean`: `true` if the header exists, `false` otherwise.\n\n#### Example\n\n```typescript\nif (ctx.req.headers.has(\"authorization\")) {\n  console.log(\"Authorization header present\");\n}\n```\n\n---\n\n## Iteration Methods\n\n### 4. `entries(): IterableIterator<[string, string[]]>`\n\n#### Description\n\nReturns an iterator of request header entries as `[key, values]` pairs.\n\n#### Returns\n\n- `IterableIterator<[string, string[]]>`: Iterator of header name and value arrays.\n\n#### Example\n\n```typescript\nfor (const [key, values] of ctx.req.headers.entries()) {\n  console.log(`${key}: ${values.join(\", \")}`);\n}\n// Output: \"accept: application/json, text/html\"\n```\n\n---\n\n### 5. `keys(): IterableIterator<string>`\n\n#### Description\n\nReturns an iterator of request header names.\n\n#### Returns\n\n- `IterableIterator<string>`: Iterator of header keys.\n\n#### Example\n\n```typescript\nfor (const key of ctx.req.headers.keys()) {\n  console.log(`Header: ${key}`);\n}\n// Output: \"content-type\", \"accept\", etc.\n```\n\n---\n\n### 6. `values(): IterableIterator<string[]>`\n\n#### Description\n\nReturns an iterator of request header value arrays.\n\n#### Returns\n\n- `IterableIterator<string[]>`: Iterator of header values.\n\n#### Example\n\n```typescript\nfor (const values of ctx.req.headers.values()) {\n  console.log(`Values: ${values.join(\", \")}`);\n}\n// Output: \"application/json\", \"en-US, es-ES\", etc.\n```\n\n---\n\n## Utility Methods\n\n### 7. `forEach(callback: (values: string[], key: string) => void): void`\n\n#### Description\n\nIterates over all request headers, invoking a callback for each.\n\n#### Parameters\n\n- `callback`: Function receiving `values` (array) and `key` (string).\n\n#### Example\n\n```typescript\nctx.req.headers.forEach((values, key) => {\n  console.log(`${key}: ${values.length} value(s)`);\n});\n// Output: \"accept: 2 value(s)\"\n```\n\n---\n\n### 8. `toObject(): Record<string, string | string[]>`\n\n#### Description\n\nConverts request headers to a plain JavaScript object.\n\n#### Returns\n\n- `Record<string, string | string[]>`: Headers as key-value pairs; single values as strings, multiple as arrays.\n\n#### Example\n\n```typescript\nconst headersObj = ctx.req.headers.toObject();\n// Returns: { \"content-type\": \"application/json\", \"accept\": [\"application/json\", \"text/html\"] }\n```\n\n---\n\n## Usage Patterns\n\n### Authentication Validation\n\n```typescript\napp.use(async (ctx, next) => {\n  if (!ctx.req.headers.has(\"authorization\")) {\n    return ctx.json({ error: \"Missing Authorization header\" }, 401);\n  }\n  await next();\n});\n```\n\n### Content Negotiation\n\n```typescript\napp.get(\"/data\", (ctx) => {\n  const accepts = ctx.req.headers.getAll(\"accept\");\n  if (accepts.includes(\"application/json\")) {\n    return ctx.json({ data: \"JSON response\" });\n  }\n  return ctx.text(\"Text response\");\n});\n```\n\n### Header Logging\n\n```typescript\napp.use(async (ctx, next) => {\n  const headers = ctx.req.headers.toObject();\n  console.log(\"Incoming Headers:\", headers);\n  await next();\n});\n```\n\n---\n\n## Request Header Operations Cheat Sheet\n\n| Method       | Description            | Mutable | Returns                        |\n|--------------|------------------------|---------|--------------------------------|\n| `get()`      | Get first value        | ‚ùå      | `string \\| undefined`          |\n| `getAll()`   | Get all values         | ‚ùå      | `string[]`                     |\n| `has()`      | Check existence        | ‚ùå      | `boolean`                      |\n| `entries()`  | Iterate [key, values]  | ‚ùå      | `IterableIterator<[string, string[]]>` |\n| `keys()`     | Iterate header names   | ‚ùå      | `IterableIterator<string>`     |\n| `values()`   | Iterate values         | ‚ùå      | `IterableIterator<string[]>`   |\n| `forEach()`  | Iterate with callback  | ‚ùå      | `void`                         |\n| `toObject()` | Convert to object      | ‚ùå      | `Record<string, string \\| string[]>` |\n\n---\n\n## Best Practices\n\n- **Inspection**: Use `get()` for single-value headers (e.g., `Content-Type`) and `getAll()` for multi-value headers (e.g., `Accept`).\n- **Validation**: Check header presence with `has()` before processing critical data.\n- **Debugging**: Use `toObject()` for a comprehensive snapshot of request headers.\n- **Performance**: Prefer `get()` over `getAll()` when only the first value is needed.\n- **Consistency**: Account for case-insensitivity when querying headers.\n\n---\n"
            },
            {
              "originalPath": "1.Response Headers.md",
              "id": 21,
              "name": "Response Headers",
              "type": "file",
              "path": "api/headers-api/response-headers",
              "content": "\n# Response Headers (`ctx.headers`)\n\n## Overview\n\nThe `ctx.headers` object provides a powerful interface for managing HTTP response headers in a web application. It allows developers to set, modify, and inspect headers that will be sent back to the client, enabling fine-grained control over response metadata such as caching, security policies, and content negotiation. This API is designed for mutability, supporting both single and multi-value headers.\n\n### Key Features\n\n- **Case-Insensitive Keys**: Header names are normalized for consistent handling.\n- **Multi-Value Support**: Accommodates headers with multiple values (e.g., `Vary`).\n- **Chaining**: Many methods return the headers object for fluent usage.\n- **Type-Safe Operations**: Ensures predictable behavior for setting and retrieving values.\n\n### Context\n\n- **Location**: Available as `ctx.headers` within a `Context` object.\n- **Purpose**: Represents headers to be sent in the HTTP response to the client.\n\n---\n\n## Core Methods\n\n### 1. `add(headers: [string, string][] | Record<string, string>)`\n\n#### Description\n\nAdds multiple headers to the response without overwriting existing ones.\n\n#### Parameters\n\n- `headers`: Either an array of `[key, value]` tuples or a key-value object.\n\n#### Behavior\n\n- Appends new headers while preserving existing ones.\n- Merges values for duplicate headers into an array.\n\n#### Example\n\n```typescript\nctx.headers.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"no-cache\"],\n]);\n\n// Using object syntax\nctx.headers.add({\n  \"X-Response-Time\": \"50ms\",\n  \"Server\": \"CustomServer\",\n});\n```\n\n---\n\n### 2. `set(key: string, value: string | string[])`\n\n#### Description\n\nSets or overwrites a response header with a single value or array of values.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n- `value`: Single string or array of strings.\n\n#### Behavior\n\n- Replaces all existing values for the specified header.\n\n#### Example\n\n```typescript\n// Single value\nctx.headers.set(\"Content-Type\", \"text/html\");\n\n// Multiple values\nctx.headers.set(\"Link\", [\n  \"</styles.css>; rel=preload\",\n  \"</script.js>; rel=preload\",\n]);\n```\n\n---\n\n### 3. `get(key: string): string | undefined`\n\n#### Description\n\nRetrieves the first value of a specified response header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `string`: First value if the header exists.\n- `undefined`: If the header is not present.\n\n#### Example\n\n```typescript\nconst cacheControl = ctx.headers.get(\"cache-control\");\n// Returns \"no-cache\" or undefined\n```\n\n---\n\n### 4. `getAll(key: string): string[]`\n\n#### Description\n\nRetrieves all values for a specified response header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `string[]`: Array of all values; empty array if header is not present.\n\n#### Example\n\n```typescript\nconst links = ctx.headers.getAll(\"link\");\n// Returns [\"</styles.css>; rel=preload\", \"</script.js>; rel=preload\"] or []\n```\n\n---\n\n### 5. `has(key: string): boolean`\n\n#### Description\n\nChecks if a header exists in the response headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `boolean`: `true` if the header exists, `false` otherwise.\n\n#### Example\n\n```typescript\nif (ctx.headers.has(\"x-ratelimit-limit\")) {\n  console.log(\"Rate limit header set\");\n}\n```\n\n---\n\n### 6. `delete(key: string): boolean`\n\n#### Description\n\nRemoves a header from the response headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `boolean`: `true` if the header was removed, `false` if it didn‚Äôt exist.\n\n#### Example\n\n```typescript\nconst removed = ctx.headers.delete(\"x-powered-by\");\n// Returns true if header was present\n```\n\n---\n\n### 7. `append(key: string, value: string)`\n\n#### Description\n\nAppends a value to an existing response header or creates a new one if it doesn‚Äôt exist.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n- `value`: Value to append.\n\n#### Behavior\n\n- Adds the value to the list of existing values for the header.\n\n#### Example\n\n```typescript\nctx.headers.append(\"Vary\", \"User-Agent\");\nctx.headers.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## Iteration Methods\n\n### 8. `entries(): Iterable<[string, string[]]>`\n\n#### Description\n\nReturns an iterator of response header entries as `[key, values]` pairs.\n\n#### Returns\n\n- `Iterable<[string, string[]]>`: Iterator of header name and value arrays.\n\n#### Example\n\n```typescript\nfor (const [key, values] of ctx.headers.entries()) {\n  console.log(`${key}: ${values.join(\", \")}`);\n}\n// Output: \"vary: User-Agent, Accept-Encoding\"\n```\n\n---\n\n### 9. `keys(): Iterable<string>`\n\n#### Description\n\nReturns an iterator of response header names.\n\n#### Returns\n\n- `Iterable<string>`: Iterator of header keys.\n\n#### Example\n\n```typescript\nfor (const key of ctx.headers.keys()) {\n  console.log(`Header: ${key}`);\n}\n// Output: \"content-type\", \"vary\", etc.\n```\n\n---\n\n### 10. `values(): Iterable<string[]>`\n\n#### Description\n\nReturns an iterator of response header value arrays.\n\n#### Returns\n\n- `Iterable<string[]>`: Iterator of header values.\n\n#### Example\n\n```typescript\nfor (const values of ctx.headers.values()) {\n  console.log(`Values: ${values.join(\", \")}`);\n}\n// Output: \"application/json\", \"User-Agent, Accept-Encoding\", etc.\n```\n\n---\n\n## Utility Methods\n\n### 11. `forEach(callback: (values: string[], key: string) => void)`\n\n#### Description\n\nIterates over all response headers, invoking a callback for each.\n\n#### Parameters\n\n- `callback`: Function receiving `values` (array) and `key` (string).\n\n#### Example\n\n```typescript\nctx.headers.forEach((values, key) => {\n  console.log(`${key}: ${values.length} value(s)`);\n});\n// Output: \"vary: 2 value(s)\"\n```\n\n---\n\n### 12. `to```typescript\n\ntoObject(): Record<string, string | string[]>\n\n```\n\n#### Description\nConverts response headers to a plain JavaScript object.\n\n#### Returns\n- `Record<string, string | string[]>`: Headers as key-value pairs; single values as strings, multiple as arrays.\n\n#### Example\n```typescript\nconst headersObj = ctx.headers.toObject();\n// Returns: { \"content-type\": \"application/json\", \"vary\": [\"User-Agent\", \"Accept-Encoding\"] }\n```\n\n---\n\n## Usage Patterns\n\n### Security Headers\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"Server\");\n  await next();\n});\n```\n\n### Rate Limiting Headers\n\n```typescript\napp.get(\"/rate-limited\", (ctx) => {\n  ctx.headers\n    .set(\"X-RateLimit-Limit\", \"100\")\n    .set(\"X-RateLimit-Remaining\", \"95\")\n    .set(\"X-RateLimit-Reset\", \"1698765432\");\n  return ctx.json({ message: \"OK\" });\n});\n```\n\n### Caching Control\n\n```typescript\napp.get(\"/static\", (ctx) => {\n  ctx.headers.set(\"Cache-Control\", \"public, max-age=3600\");\n  return ctx.sendFile(\"static/file.txt\");\n});\n```\n\n---\n\n## Response Header Operations Cheat Sheet\n\n| Method       | Description            | Mutable | Returns               |\n|--------------|------------------------|---------|-----------------------|\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`                |\n| `set()`      | Replace header values  | ‚úÖ      | `void`                |\n| `get()`      | Get first value        | ‚ùå      | `string \\| undefined` |\n| `getAll()`   | Get all values         | ‚ùå      | `string[]`            |\n| `has()`      | Check existence        | ‚ùå      | `boolean`             |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`             |\n| `append()`   | Append value           | ‚úÖ      | `void`                |\n| `entries()`  | Iterate [key, values]  | ‚ùå      | `Iterable<[string, string[]]>` |\n| `keys()`     | Iterate header names   | ‚ùå      | `Iterable<string>`    |\n| `values()`   | Iterate values         | ‚ùå      | `Iterable<string[]>`  |\n| `forEach()`  | Iterate with callback  | ‚ùå      | `void`                |\n| `toObject()` | Convert to object      | ‚ùå      | `Record<string, string \\| string[]>` |\n\n---\n\n## Best Practices\n\n- **Security**: Set headers like `X-Content-Type-Options` and `Content-Security-Policy` early in the middleware chain.\n- **Caching**: Use `Cache-Control` and `ETag` for efficient client-side caching.\n- **Consistency**: Use `set()` for single-value headers and `append()` for multi-value headers like `Vary`.\n- **Debugging**: Leverage `toObject()` for logging or inspecting response headers.\n- **Standards**: Follow HTTP header conventions (e.g., `X-` prefix for custom headers).\n\n---\n\n## Notes\n\n- **Mutability**: Methods like `set`, `add`, `append`, and `delete` modify the response headers in place.\n- **Case Handling**: Header keys are case-insensitive per HTTP standards.\n- **Framework Integration**: Assumes `ctx.headers` is part of a broader `Context` object tied to the response lifecycle.\n\n---\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "9. Static File.md",
      "id": 22,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```ts\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```ts\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  return ctx.text(\"Custom response overriding static file\");\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "originalPath": "97. Middlewares",
      "name": "Middlewares",
      "path": "middlewares",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. CORS Middleware.md",
          "id": 23,
          "name": "CORS Middleware",
          "type": "file",
          "path": "middlewares/cors-middleware",
          "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// ‚ùå Avoid in production\ncors({ origin: \"*\" });\n// ‚úÖ Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
        },
        {
          "originalPath": "10. i18nMiddleware.md",
          "id": 24,
          "name": "I18nMiddleware",
          "type": "file",
          "path": "middlewares/i18nmiddleware",
          "content": "# üåç `i18nMiddleware`\n\n> Advanced internationalization (i18n) middleware for `tezx` with dynamic translation loading, fallback language chains, caching, and custom message formatting.\n\n---\n\n## üìÑ Usage\n\n### ‚úÖ Basic Usage\n\n```ts\nimport { i18nMiddleware } from \"tezx/middleware\";\n\napp.use(\n  i18nMiddleware({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## üîß API: `i18nMiddleware(options: I18nOptions): Middleware`\n\n### üß© Interface: `I18nOptions`\n\n| Option                   | Type                                                          | Default                           | Description                                   |\n| ------------------------ | ------------------------------------------------------------- | --------------------------------- | --------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations, expiresAt? }>` | **Required**                      | Function that dynamically loads translations. |\n| `defaultCacheDuration`   | `number`                                                      | `3600000` (1 hr)                  | Time (ms) before cache expires.               |\n| `isCacheValid`           | `(cached, language) => boolean`                               | `expiresAt > Date.now()`          | Custom logic to validate cached translations. |\n| `detectLanguage`         | `(ctx: Context) => string`                                    | Query > Cookie > Header > default | Custom language detection.                    |\n| `defaultLanguage`        | `string`                                                      | `'en'`                            | Fallback language if detection fails.         |\n| `fallbackChain`          | `string[]`                                                    | `[]`                              | Array of fallback languages in priority.      |\n| `translationFunctionKey` | `string`                                                      | `'t'`                             | Key name attached to `ctx` for translating.   |\n| `formatMessage`          | `(message: string, options?: Record<string, any>) => string`  | Basic `{{var}}` replace           | Message interpolation.                        |\n| `cacheTranslations`      | `boolean`                                                     | `true`                            | Enable/disable translation caching.           |\n\n---\n\n## üí¨ Translation Format\n\nYou can structure translations as nested objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## üß† Features Explained\n\n### 1. üåê Language Detection\n\nDefault flow:\n\n- Query Param: `?lang=fr`\n- Cookie: `lang=fr`\n- Header: `Accept-Language: fr`\n- Fallback: `'en'`\n\nYou can override this behavior:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n---\n\n### 2. üîÅ Fallback Chain\n\nSupport fallback chains like:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n---\n\n### 3. üß† Cache with Expiry\n\n```ts\ncacheTranslations: true,\ndefaultCacheDuration: 1000 * 60 * 60 // 1 hour\n```\n\nOr use expiration from backend:\n\n```ts\nloadTranslations: async (lang) => {\n  const result = await fetchFromAPI(lang);\n  return {\n    translations: result.data,\n    expiresAt: Date.now() + 60000, // 1 min\n  };\n};\n```\n\n---\n\n### 4. üß© Message Interpolation\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" });\n// Output: \"Welcome, Alice!\"\n```\n\nYou can customize it:\n\n```ts\nformatMessage: (msg, vars) => {\n  return msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n};\n```\n\n---\n\n### 5. üìö Nested Key Support\n\n```ts\n// JSON\n{\n  \"user\": {\n    \"profile\": {\n      \"greeting\": \"Hello, {{name}}\"\n    }\n  }\n}\n\n// Access\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## üß™ Advanced Example\n\n```ts\napp.use(\n  i18nMiddleware({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return {\n        translations: json.data,\n        expiresAt: json.expiresAt, // Optional\n      };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) => {\n      return msg.replace(\n        /\\{\\{(.*?)\\}\\}/g,\n        (_, key) => vars?.[key.trim()] ?? \"\",\n      );\n    },\n    cacheTranslations: true,\n    isCacheValid: (cached, lang) => {\n      return cached.expiresAt > Date.now();\n    },\n  }),\n);\n```\n\n---\n\n## üìå What `ctx` contains after middleware\n\n| Property            | Type                                      | Description             |\n| ------------------- | ----------------------------------------- | ----------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function    |\n| `ctx.language`      | `string`                                  | Selected language       |\n| `ctx.languageChain` | `string[]`                                | Language fallback chain |\n\n---\n\n## ‚ùó Error Handling\n\nIf no translations are found for any language in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## üì§ Exported Types\n\nYou can reuse types for strong typing in your app:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/middleware\";\n```\n\n---\n"
        },
        {
          "originalPath": "11. Lazy Load Modules.md",
          "id": 25,
          "name": "Lazy Load Modules",
          "type": "file",
          "path": "middlewares/lazy-load-modules",
          "content": "# **Lazy Module Loader Middleware**\n\n## **Overview**\n\nThe **Lazy Module Loader Middleware** is designed for dynamic, on-demand loading of modules in web applications. It helps optimize application startup time by only loading the modules when required. This middleware supports caching, lifecycle hooks, and dependency injection to enhance flexibility and performance in large-scale applications.\n\nThe middleware is ideal for applications with varying user requirements, such as role-based module loading, where different users need access to different sets of modules.\n\n---\n\n## **Key Features**\n\n- **Dynamic Module Loading:** Modules are loaded based on request parameters, user roles, or custom conditions.\n- **Caching Support:** Automatically cache modules to reduce load time for frequently used modules.\n- **Lifecycle Hooks:** Track events during the module loading process (e.g., before load, after load, on cache hit, on error).\n- **Dependency Injection:** Inject dependencies into modules upon loading (e.g., external services, configurations).\n- **Validation:** Ensure modules meet specific requirements (e.g., must implement certain methods before use).\n- **Error Handling:** Built-in error handling for failed module loading.\n\n---\n\n## **Usage**\n\n### **Basic Setup**\n\nBelow is the basic setup for using the **Lazy Module Loader Middleware** within a web application.\n\n1. Import the necessary modules:\n\n```ts\nimport { Context, Middleware } from \"tezx\"; // Adjust based on your framework\nimport { lazyLoadModules } from \"tezx/middleware\"; // Adjust path as needed\n```\n\n2. Initialize the middleware with default settings:\n\n```ts\nconst lazyModuleMiddleware: Middleware = lazyLoadModules({\n  // Define the method for determining which module to load based on request.\n  moduleKey: (ctx: Context) => ctx.req.query.module || ctx.req.params.module,\n\n  // Specify how to load the module dynamically.\n  getModuleLoader: (ctx: Context) => {\n    const moduleName = ctx.req.query.module || ctx.req.params.module;\n    if (moduleName) {\n      return () => import(`./modules/${moduleName}.js`);\n    }\n    return null;\n  },\n\n  // Cache configuration: Use an in-memory cache by default.\n  enableCache: true,\n  cacheTTL: 3600000, // Cache Time-to-Live (TTL) in milliseconds (1 hour)\n\n  // Inject dependencies into the module.\n  // it work with int function.\n  dependencies: {\n    logger: console,\n    config: { env: process.env.NODE_ENV },\n  },\n\n  // Provide lifecycle hooks to track module loading events.\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) => {\n      console.log(`Loading module: ${moduleName}`);\n    },\n    onCacheHit: (moduleName, module, ctx) => {\n      console.log(`Cache hit for module: ${moduleName}`);\n    },\n    onComplete: (moduleName, module, ctx) => {\n      console.log(`Module loaded successfully: ${moduleName}`);\n    },\n    onError: (moduleName, error, ctx) => {\n      console.error(`Error loading module: ${moduleName}`, error);\n    },\n  },\n\n  // Module validation: Ensure the module meets required criteria before use.\n  validateModule: (module) =>\n    typeof module.init === \"function\" && typeof module.execute === \"function\",\n});\n\n// Register the middleware with the application.\napp.use(lazyModuleMiddleware);\n```\n\n### **Accessing the Loaded Module**\n\nOnce the middleware has loaded the module, it attaches it to the context. You can access it in route handlers like so:\n\n```ts\napp.get(\"/execute\", async (ctx: Context) => {\n  const module = ctx.loadedModule;\n  if (module && module.execute) {\n    module.execute();\n    return ctx.json({ message: \"Module action executed successfully.\" });\n  } else {\n    return ctx.json({\n      error: \"Module is either not loaded or missing the 'execute' function.\",\n    });\n  }\n});\n```\n\n---\n\n## **Configuration Options**\n\nThe middleware is highly configurable, allowing you to define how modules are loaded, cached, and validated. Below are the available configuration options:\n\n### **1. moduleKey** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function to determine which module to load based on the incoming request. It should return a string representing the module name or key.\n\nExample:\n\n```ts\nmoduleKey: (ctx: Context) => ctx.req.query.module || ctx.req.params.module;\n```\n\n### **2. getModuleLoader** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function that returns a Promise which dynamically imports the module based on the context (e.g., URL parameters, user roles).\n\nExample:\n\n```ts\ngetModuleLoader: (ctx: Context) => {\n  const moduleName = ctx.req.query.module || ctx.req.params.module;\n  if (moduleName) {\n    return () => import(`./modules/${moduleName}.js`);\n  }\n  return null;\n};\n```\n\n### **3. enableCache** (Boolean)\n\n- **Type:** `Boolean`\n- **Default:** `true`\n- **Description:** Enable or disable caching of modules. By default, modules are cached in memory.\n\nExample:\n\n```ts\nenableCache: true;\n```\n\n### **4. cacheTTL** (Number)\n\n- **Type:** `Number`\n- **Default:** `3600000` (1 hour)\n- **Description:** Time-to-Live (TTL) in milliseconds for cached modules. After this time, the module will be reloaded.\n\nExample:\n\n```ts\ncacheTTL: 3600000;\n```\n\n### **5. dependencies** (Object)\n\n- **Type:** `Object`\n- **Description:** Inject dependencies into the loaded modules (e.g., services, configurations). This is useful when the module requires external dependencies for initialization.\n- **Work:** It always work with module `int function`.\n  Example:\n\n```ts\ndependencies: {\n  logger: console,\n  config: { env: process.env.NODE_ENV }\n}\n\n// dashboard.js\nexport function init(dependencies, ctx) {\n    // ctx. ....................\n    // operation\n    console.log(dependencies, 534)\n}\n// with response\nexport function init(dependencies, ctx) {\n    return ctx.json({ x: 345 })\n}\n```\n\n### **6. lifecycleHooks** (Object)\n\n- **Type:** `Object`\n- **Description:** A set of hooks that are called during different stages of the module loading process. These hooks provide insight into the module loading, caching, and error handling flow.\n\n#### Available hooks\n\n- **onLoad(moduleName, ctx):** Triggered when the module is being loaded.\n- **onCacheHit(moduleName, module, ctx):** Triggered when a module is found in the cache.\n- **onCacheSet(moduleName, module, ctx):** Triggered after a module is added to the cache.\n- **onComplete(moduleName, module, ctx):** Triggered when the module has been successfully loaded.\n- **onError(moduleName, error, ctx):** Triggered when an error occurs during module loading.\n\nExample:\n\n```ts\nlifecycleHooks: {\n  onLoad: (moduleName, ctx) => console.log(`Loading module: ${moduleName}`),\n  onCacheHit: (moduleName, module, ctx) => console.log(`Cache hit for: ${moduleName}`),\n  onComplete: (moduleName, module, ctx) => console.log(`Module loaded: ${moduleName}`),\n  onError: (moduleName, error, ctx) => console.error(`Error loading module: ${moduleName}`, error)\n}\n```\n\n### **7. validateModule** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function that validates the loaded module before it is used. This function should return `true` if the module is valid or `false` otherwise.\n\nExample:\n\n```ts\nvalidateModule: (module) =>\n  typeof module.init === \"function\" && typeof module.execute === \"function\";\n```\n\n---\n\n## **Advanced Features**\n\n### **Custom Cache Storage**\n\nIf you want to replace the default in-memory cache with a custom storage backend (e.g., Redis), you can implement a custom cache interface that adheres to the `Map` API.\n\nExample of using a Redis client (or any custom storage):\n\n```ts\nclass RedisCache {\n  async get(key: string): Promise<any> {\n    return redisClient.get(key); // Replace with Redis or other storage logic\n  }\n  async set(key: string, value: any): Promise<void> {\n    return redisClient.set(key, JSON.stringify(value)); // Adjust according to your storage solution\n  }\n  async delete(key: string): Promise<void> {\n    return redisClient.del(key); // Adjust according to your storage solution\n  }\n}\n```\n\nYou can then pass this cache object as the `cacheStorage` option in the middleware configuration.\n\n---\n\n## **Error Handling**\n\nThe middleware provides built-in error handling that logs errors when module loading fails. You can customize the error handling by defining your own error handler inside the `lifecycleHooks.onError` callback.\n\nExample:\n\n```ts\nlifecycleHooks: {\n  onError: (moduleName, error, ctx) => {\n    console.error(`Failed to load module: ${moduleName}`, error);\n    ctx.setStatus = 500;\n  };\n}\n```\n\n---\n\n## **Best Practices**\n\n- **Module Validation:** Always validate modules before using them to ensure they have the necessary methods and properties.\n- **Caching Strategy:** Use caching with a reasonable TTL to optimize performance while preventing stale data from being served.\n- **Error Handling:** Implement robust error handling to capture and respond to failures gracefully.\n\n---\n\n## **Conclusion**\n\nThe **Lazy Module Loader Middleware** is an essential tool for applications that need to load modules dynamically based on various conditions. It provides advanced features like caching, lifecycle hooks, and dependency injection, which help optimize performance and maintain flexibility. By customizing this middleware according to your application‚Äôs needs, you can efficiently manage dynamic module loading with reduced overhead.\n\n```ts\napp.use(\n  lazyLoadModules<WidgetModule>({\n    getModuleLoader: (ctx) => () =>\n      import(`./widgets/${ctx.req.params.widget}`),\n    validateModule: (module) =>\n      typeof module.render === \"function\" && typeof module.init === \"function\",\n    cacheTTL: 86400000, // 24 hours\n    dependencies: { logger, config },\n    lifecycleHooks: {\n      onLoad: (name) => console.log(`Loading ${name}`),\n      onError: (name, err) => metrics.trackError(err),\n      onCacheHit: (name) => console.log(`Cache hit for ${name}`),\n    },\n  }),\n);\n```\n"
        },
        {
          "originalPath": "2. Logger.md",
          "id": 26,
          "name": "Logger",
          "type": "file",
          "path": "middlewares/logger",
          "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```bash\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
        },
        {
          "originalPath": "3. Powered By.md",
          "id": 27,
          "name": "Powered By",
          "type": "file",
          "path": "middlewares/powered-by",
          "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
        },
        {
          "originalPath": "4. Request ID.md",
          "id": 28,
          "name": "Request ID",
          "type": "file",
          "path": "middlewares/request-id",
          "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
        },
        {
          "originalPath": "5. Secure Headers.md",
          "id": 29,
          "name": "Secure Headers",
          "type": "file",
          "path": "middlewares/secure-headers",
          "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
        },
        {
          "originalPath": "6. XSS protection.md",
          "id": 30,
          "name": "XSS Protection",
          "type": "file",
          "path": "middlewares/xss-protection",
          "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```ts\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```ts\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```ts\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
        },
        {
          "originalPath": "7. Sanitize Headers.md",
          "id": 31,
          "name": "Sanitize Headers",
          "type": "file",
          "path": "middlewares/sanitize-headers",
          "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```ts\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```ts\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```ts\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```ts\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n```ts\n// Recommended security-focused setup\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    normalizeKeys: true,\n  }),\n);\n```\n\n2. **Information Hiding**:\n\n```ts\n// Hide server technology information\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
        },
        {
          "originalPath": "8. Rate Limiter.md",
          "id": 32,
          "name": "Rate Limiter",
          "type": "file",
          "path": "middlewares/rate-limiter",
          "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n**Note: It works with `app.use` api**\n\n## Installation\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```ts\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```ts\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```ts\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```ts\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({ error: `Try again in ${retryAfter} seconds` });\n  };\n  ```\n\n```ts\n/**\n     * üîÑ Custom cache storage implementation (e.g., using `Map`, `Redis`, etc.).\n     * By default, it uses a `Map<string, { count: number; resetTime: number }>`.\n     */\n  cacheStorage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    delete: (key: string) => void;\n    entries: () => IterableIterator<[string, { count: number; resetTime: number }]>;\n  };\n\n```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```ts\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```ts\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      });\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n```ts\n// Planned future usage\napp.use(\n  rateLimiter({\n    maxRequests: 1000,\n    windowMs: 3600000,\n    storage: \"redis\",\n    redisClient: redis.createClient(),\n  }),\n);\n```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```ts\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```ts\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```ts\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
        },
        {
          "originalPath": "9. Pagination.md",
          "id": 33,
          "name": "Pagination",
          "type": "file",
          "path": "middlewares/pagination",
          "content": "# Pagination Middleware\n\n## Overview\n\nThe `paginationHandler` is an advanced middleware designed to streamline pagination in web applications. It automates query parameter parsing, supports dynamic data fetching, and provides comprehensive pagination metadata, making it ideal for APIs requiring paginated responses.\n\n### Features\n\n- **Automatic Parameter Handling**: Parses `page` and `limit` from query strings with sanitization.\n- **Dynamic Data Integration**: Fetches paginated data via a configurable `getDataSource`.\n- **Rich Metadata**: Includes total items, total pages, next/previous page indicators, and more.\n- **Flexible Workflow**: Integrates with subsequent middleware via `next()` when `getDataSource` is used.\n- **Error Handling**: Ensures robust input validation and fallback behavior.\n\n### Dependencies\n\n```typescript\nimport { Context } from \"tezx\";\nimport { Middleware } from \"tezx\";\n```\n\n- **`Context`**: Base context type for request handling, providing access to `req`, `body`, etc.\n- **`Middleware`**: Type for middleware functions that process requests and optionally call `next()`.\n\n---\n\n## Types\n\n### `PaginationOptions`\n\nConfiguration options for customizing pagination behavior.\n\n```typescript\nexport type PaginationOptions = {\n  /**\n   * üî¢ Default page number when not specified\n   * @default 1\n   * @example 1 // Start from first page\n   */\n  defaultPage?: number;\n\n  /**\n   * üìè Default items per page\n   * @default 10\n   * @example 25 // Show 25 items by default\n   */\n  defaultLimit?: number;\n\n  /**\n   * ‚ö†Ô∏è Maximum allowed items per page\n   * @default 100\n   * @example 50 // Never return more than 50 items\n   */\n  maxLimit?: number;\n\n  /**\n   * üîç Query parameter name for page number\n   * @default \"page\"\n   * @example \"p\" // Use ?p=2 instead of ?page=2\n   */\n  queryKeyPage?: string;\n\n  /**\n   * üîç Query parameter name for items limit\n   * @default \"limit\"\n   * @example \"size\" // Use ?size=20\n   */\n  queryKeyLimit?: string;\n\n  /**\n   * üìä Key to read total count from response\n   * @default \"total\"\n   * @example \"totalCount\" // Read from response.totalCount\n   */\n  countKey?: string;\n\n  /**\n   * üì¶ Key containing the data array in response\n   * @default \"data\"\n   * @example \"items\" // Process response.items array\n   */\n  dataKey?: string;\n\n  /**\n   * üõ†Ô∏è Function to fetch data dynamically\n   * @param ctx - Request context\n   * @param pagination - Pagination details (page, limit, offset)\n   * @returns Promise resolving to an object with data and total count\n   * @example\n   * getDataSource: async (ctx, { page, limit }) => {\n   *   return db.find().skip((page-1)*limit).limit(limit);\n   * }\n   */\n  getDataSource?: <T extends Record<string, any> = {}>(\n    ctx: Context<T>,\n    pagination: { page: number; limit: number; offset: number },\n  ) => Promise<{ [key: string]: any }>;\n};\n```\n\n### `PaginationBodyType`\n\nStructure of the response body when `getDataSource` is used.\n\n```typescript\nexport type PaginationBodyType = {\n  [x: string]: any;\n  pagination: {\n    page: number;\n    limit: number;\n    totalItems: any;\n    totalPages: number;\n    hasNextPage: boolean;\n    hasPrevPage: boolean;\n    nextPage: number | null;\n    prevPage: number | null;\n  };\n};\n```\n\n---\n\n## Function\n\n### `paginationHandler`\n\nCreates a middleware function for handling pagination.\n\n#### Signature\n\n```typescript\nexport const paginationHandler = (options: PaginationOptions = {}): Middleware;\n```\n\n#### Parameters\n\n- **`options: PaginationOptions`** (Optional) ‚Äì Configuration object for pagination settings. Defaults to an empty object.\n\n#### Returns\n\n- **`Middleware`**: A function that processes pagination and either sets `ctx.body` or proceeds to `next()`.\n\n#### Description\n\nHandles pagination by:\n\n1. Parsing and sanitizing `page` and `limit` query parameters.\n2. Attaching pagination metadata to `ctx.pagination`.\n3. Optionally fetching data via `getDataSource`, constructing a `PaginationBodyType` response, and setting `ctx.body`.\n4. Supporting middleware chaining with `next()` when applicable.\n\n---\n\n## Examples\n\n### 1. Basic Usage\n\nAttaching pagination context without a data source.\n\n```typescript\napp.get(\"/users\", paginationHandler(), async (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  const users = await db.users.find().skip(offset).limit(limit);\n  const total = await db.users.countDocuments();\n  return ctx.json({ data: users, total });\n});\n```\n\n**Request**: `GET /users?page=2&limit=20`  \n**Effect**: Sets `ctx.pagination` with `page: 2`, `limit: 20`, `offset: 20`.  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 20 users */\n  ],\n  \"total\": 100\n}\n```\n\n---\n\n### 2. With Dynamic Data Source\n\nFetching data directly within the middleware.\n\n```typescript\napp.get(\n  \"/products\",\n  paginationHandler({\n    getDataSource: async (ctx, { page, limit, offset }) => {\n      const result = await Product.findAndCountAll({\n        offset,\n        limit,\n      });\n      return {\n        data: result.rows,\n        total: result.count,\n      };\n    },\n  }),\n  async (ctx) => {\n    return ctx.json(ctx.body); // Pass through the pre-set body\n  },\n);\n```\n\n**Request**: `GET /products?page=3&limit=10`  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 10 products */\n  ],\n  \"total\": 50,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 10,\n    \"totalItems\": 50,\n    \"totalPages\": 5,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 4,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n\n### 3. Custom Query Parameters and Keys\n\nUsing custom query names and response keys.\n\n```typescript\napp.get(\n  \"/articles\",\n  paginationHandler({\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalArticles\",\n    dataKey: \"articles\",\n    getDataSource: async (ctx, { offset, limit }) => {\n      const articles = await Article.find().skip(offset).limit(limit);\n      return {\n        articles,\n        totalArticles: await Article.countDocuments(),\n      };\n    },\n  }),\n);\n```\n\n**Request**: `GET /articles?p=1&size=5`  \n**Response**:\n\n```json\n{\n  \"articles\": [\n    /* 5 articles */\n  ],\n  \"totalArticles\": 25,\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 5,\n    \"totalItems\": 25,\n    \"totalPages\": 5,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": false,\n    \"nextPage\": 2,\n    \"prevPage\": null\n  }\n}\n```\n\n---\n\n### 4. Middleware Chaining\n\nCombining with additional middleware.\n\n```typescript\napp.get(\n  \"/orders\",\n  paginationHandler({\n    getDataSource: async (ctx, { offset, limit }) => {\n      const orders = await Order.find().skip(offset).limit(limit);\n      return {\n        data: orders,\n        total: await Order.countDocuments(),\n      };\n    },\n  }),\n  async (ctx) => {\n    const body = ctx.body as PaginationBodyType;\n    return ctx.json({\n      ...body,\n      timestamp: new Date().toISOString(),\n    });\n  },\n);\n```\n\n**Request**: `GET /orders?page=2&limit=10`  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 10 orders */\n  ],\n  \"total\": 30,\n  \"pagination\": {\n    \"page\": 2,\n    \"limit\": 10,\n    \"totalItems\": 30,\n    \"totalPages\": 3,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 3,\n    \"prevPage\": 1\n  },\n  \"timestamp\": \"2025-04-07T12:00:00.000Z\"\n}\n```\n\n---\n\n### 5. Input Sanitization\n\nHandling invalid inputs with limits.\n\n```typescript\napp.get(\n  \"/posts\",\n  paginationHandler({\n    maxLimit: 50,\n    getDataSource: async (ctx, { offset, limit }) => {\n      const posts = await Post.find().skip(offset).limit(limit);\n      return {\n        data: posts,\n        total: await Post.countDocuments(),\n      };\n    },\n  }),\n);\n```\n\n**Request**: `GET /posts?page=-1&limit=100`  \n**Effect**:\n\n- `page` sanitized to `1`.\n- `limit` capped at `50`.  \n  **Response**: Contains first 50 posts with metadata.\n\n---\n\n## Best Practices\n\n- **Data Source**: Use `getDataSource` for self-contained logic; omit it to delegate to subsequent middleware.\n- **Custom Keys**: Align `countKey` and `dataKey` with your API‚Äôs response structure.\n- **Limits**: Set `maxLimit` to prevent excessive resource usage.\n- **Chaining**: Use `next()` to integrate with additional middleware for response customization.\n- **Type Safety**: Extend `Context<T>` with custom properties (e.g., `ctx.user`) for type-safe access.\n\n---\n\n## Notes\n\n- **Response Format**: When `getDataSource` is used, `ctx.body` is set to a `PaginationBodyType` object.\n- **Middleware Flow**: Without `getDataSource`, only `ctx.pagination` is set, requiring `next()` for further processing.\n- **Compatibility**: Works with Node.js, Bun, and Deno runtimes.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "98. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Load Environment.md",
          "id": 34,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```ts\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```ts\nimport { loadEnv } from \"tezx/helper\";\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```ts\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```ts\nconst app = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```ts\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```ts\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```ts\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Basic.md",
          "id": 35,
          "name": "Basic",
          "type": "file",
          "path": "examples/basic",
          "content": ""
        },
        {
          "originalPath": "1. Uploader.md",
          "id": 36,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
        },
        {
          "originalPath": "3. Lazy Load Modules.md",
          "id": 37,
          "name": "Lazy Load Modules",
          "type": "file",
          "path": "examples/lazy-load-modules",
          "content": "### Enhanced Example: Role-Based Dynamic Module Loading with Caching and Lifecycle Hooks\n\nIn this example, we will use **Lazy Module Loader** middleware to load different modules based on the user's role. For instance, an admin might have access to the admin dashboard, while a user might access a user dashboard. We will also implement caching for performance optimization, validation to ensure modules are valid, and lifecycle hooks to track the loading process.\n\n---\n\n#### Middleware Configuration: Role-Based Module Loading with Caching\n\n```ts\nimport { Context, Middleware } from \"tezx\";\nimport { lazyLoadModules } from \"tezx/middleware\"; // Assuming lazyLoadModules is correctly imported\n\n// Define the middleware with advanced configurations\nconst roleBasedModuleLoader: Middleware = lazyLoadModules({\n  // Key function to determine the module to load based on user role\n  moduleKey: (ctx) => {\n    const role = ctx.user?.role; // Get user role from the context\n    if (role === \"admin\") {\n      return \"adminDashboardModule\"; // Admin's module\n    } else if (role === \"user\") {\n      return \"userDashboardModule\"; // User's module\n    }\n    return \"guestDashboardModule\"; // Default module for guests\n  },\n\n  // Function to dynamically load the appropriate module based on role\n  getModuleLoader: (ctx) => {\n    const moduleName = ctx.req.query.module || ctx.req.params.module; // Fallback to query/params\n    if (!moduleName) {\n      throw new Error(\"Module name is required.\");\n    }\n\n    // Dynamically import the correct module\n    return () => import(`./modules/${moduleName}.js`);\n  },\n\n  // Custom query parameter for module selection\n  queryKeyModule: \"module\", // Optional: Used when you pass `module` in the URL query params\n\n  // Store the module in the context under the 'module' key\n  moduleContextKey: \"module\", // The key under which the loaded module will be stored\n\n  // Enable caching for the modules to improve performance\n  enableCache: true,\n\n  // Custom in-memory cache storage (could be replaced with Redis in production)\n  cacheStorage: new Map<string, CacheItem<any>>(),\n\n  // Set TTL for cached modules (1 hour)\n  cacheTTL: 3600000, // 1 hour in milliseconds\n\n  // Injecting dependencies (e.g., services or configuration)\n  dependencies: {\n    loggingService: ctx.loggingService,\n    configService: ctx.configService,\n  },\n\n  // Lifecycle hooks to manage module loading and actions\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) => {\n      console.log(\n        `Loading module: ${moduleName} for user role: ${ctx.user?.role}`,\n      );\n    },\n    onCacheHit: (moduleName, module, ctx) => {\n      console.log(`Cache hit for module: ${moduleName}`);\n    },\n    onCacheSet: (moduleName, module, ctx) => {\n      console.log(`Module ${moduleName} cached successfully.`);\n    },\n    onComplete: (moduleName, module, ctx) => {\n      console.log(`Module ${moduleName} loaded successfully.`);\n    },\n    onError: (moduleName, error, ctx) => {\n      console.error(`Error loading module ${moduleName}:`, error);\n      ctx.body = { error: `Failed to load module: ${moduleName}` };\n      ctx.setStatus(500);\n    },\n  },\n\n  // Validate the loaded module before usage\n  validateModule: (module) => {\n    // Ensure the module has an 'init' method for initialization\n    return module && typeof module.init === \"function\";\n  },\n});\n\n// Register the middleware in the application\napp.use(roleBasedModuleLoader);\n```\n\n---\n\n#### Route Handling\n\nIn this part of the application, we‚Äôll set up a route where the module loaded dynamically based on the user role will be accessed. We will check if the module is present and then perform an action (e.g., call the `init` method of the module).\n\n```ts\n// Route to handle accessing the loaded module\napp.get(\"/dashboard\", async (ctx: Context) => {\n  const module = ctx.module; // The module is stored in the context by the middleware\n\n  if (module) {\n    try {\n      // Check if the module has the `init` method and invoke it\n      if (module.init) {\n        await module.init(ctx.dependencies, ctx); // Injecting dependencies like loggingService\n        return ctx.json({\n          message: `${module.constructor.name} initialized successfully.`,\n        });\n      } else {\n        throw new Error(`Module does not have an 'init' method.`);\n      }\n    } catch (error) {\n      ctx.setStatus(500);\n      return ctx.json({ error: error.message });\n    }\n  } else {\n    // If the module is not found in the context, return an error\n    ctx.setStatus(404);\n    return ctx.json({ error: \"Module not found.\" });\n  }\n});\n```\n\n---\n\n#### Example Modules\n\nHere are two simple example modules: `adminDashboardModule.js` and `userDashboardModule.js`.\n\n##### `adminDashboardModule.js`\n\n```js\nexport const adminDashboardModule = {\n  init: (dependencies, ctx) => {\n    // Initialization logic for the admin dashboard\n    console.log(\"Admin dashboard initialized.\");\n    dependencies.loggingService.log(\"Admin dashboard accessed.\");\n    return ctx.json({ message: \"Welcome to the Admin Dashboard.\" });\n  },\n};\n```\n\n##### `userDashboardModule.js`\n\n```js\nexport const userDashboardModule = {\n  init: (ctx, dependencies) => {\n    // Initialization logic for the user dashboard\n    console.log(\"User dashboard initialized.\");\n    dependencies.loggingService.log(\"User dashboard accessed.\");\n    return ctx.json({ message: \"Welcome to the User Dashboard.\" });\n  },\n};\n```\n\n---\n\n### Advanced Scenarios\n\n#### 1. **Module Loading Based on User Permissions**\n\nYou can enhance the logic by loading different modules depending on both the user's role and permissions. For example, an admin may have access to both the admin and user dashboard, while a regular user can only access the user dashboard.\n\n```ts\nmoduleKey: (ctx) => {\n  const role = ctx.user?.role;\n  const permissions = ctx.user?.permissions || [];\n\n  if (role === \"admin\") {\n    if (permissions.includes(\"viewAdminDashboard\")) {\n      return \"adminDashboardModule\";\n    } else {\n      return \"userDashboardModule\";\n    }\n  }\n  return \"userDashboardModule\"; // Regular users\n};\n```\n\n#### 2. **Custom Cache Storage Integration (e.g., Redis)**\n\nYou can replace the in-memory cache with a persistent cache solution, like Redis, to handle large-scale applications. Here‚Äôs an example of how to integrate Redis for caching:\n\n```ts\nimport { createClient } from \"redis\";\n\n// Initialize Redis client\nconst redisClient = createClient({ url: \"redis://localhost:6379\" });\n\nconst roleBasedModuleLoaderWithRedisCache: Middleware = lazyLoadModules({\n  // Use Redis as the cache storage\n  cacheStorage: redisClient,\n  enableCache: true,\n  cacheTTL: 3600000, // 1 hour\n\n  // Other configurations remain the same as above...\n});\n```\n\n#### 3. **Error Handling with Custom Response**\n\nYou can customize error handling in the lifecycle hooks for specific actions, such as logging the error or sending a custom response format.\n\n```ts\nlifecycleHooks: {\n  onError: (moduleName, error, ctx) => {\n    console.error(`Error loading module ${moduleName}:`, error);\n    ctx.setStatus(500);\n    return ctx.json({\n      error: `An error occurred while loading the module ${moduleName}. Please try again later.`,\n      details: error.message,\n    });\n  },\n},\n```\n\n#### 4. **Module Versioning**\n\nTo handle different versions of the same module, you can add versioning to the module names or configure the `getModuleLoader` function to load modules based on the requested version.\n\n```ts\ngetModuleLoader: (ctx) => {\n  const version = ctx.req.query.version || \"v1\"; // Default to v1\n  const moduleName = ctx.req.query.module;\n\n  if (!moduleName) {\n    throw new Error(\"Module name is required.\");\n  }\n\n  return () => import(`./modules/${moduleName}-${version}.js`);\n},\n```\n\n---\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "release-note/tsfsd",
      "name": "Tsfsd",
      "folder": "Release Note",
      "content": "tsrfc\nInstallation\nConfiguration\nLogger Function\n"
    },
    {
      "id": 2,
      "path": "need-to-know",
      "name": "Need To Know",
      "folder": ".",
      "content": "---\n# **Compatibility**\n\nThis section details the routing system‚Äôs compatibility with path patterns, including named parameters, wildcards, and optional parameters. It also covers overwriting behavior, matching priority, and key implementation notes.\n---\n\n## **Supported Route Patterns**\n\n- **Named Parameters** (`:id`): Matches a specific URL segment (e.g., `/users/123`).\n- **Wildcard Parameters** (`/*path` or `/*`): Captures all remaining URL segments.\n- **Optional Parameters** (`/:id?`): Allows a parameter to be optional (e.g., `/users` or `/users/123`).\n\n---\n\n## **1. Router Compatibility**\n\n### **Limitations**\n\n- Direct support for **wildcards** (`/*path`, `/*`) and **optional parameters** (`/:id?`) in route definitions is **not available**.\n- **Workaround**: Use the `basePath` property in the router configuration to enable optional parameters.\n\n### **Example: Optional Parameters with `basePath`**\n\n```typecript\nconst account = new Router<CustomContext>({\n  basePath: \"/account/:role?\",\n});\n```\n\n- **Behavior**: Matches both `/account` (no role) and `/account/admin` (role specified).\n\n---\n\n## **2. Overwriting Behavior**\n\n### **Route Overwriting**\n\n- When route patterns conflict, the **last defined handler overwrites earlier ones**.\n- Overwriting occurs in a **descending order** from parent to child routers.\n\n### **Example: Conflicting Routes**\n\n```ts\n// ‚ùå Conflicting Routes\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// Request to /users/john returns: { name: \"john\" }\n```\n\n- **Issue**: Both routes match `/users/:param`, and the latter overrides the former.\n\n### **Solution: Unique Paths**\n\n```ts\n// ‚úÖ Distinct Routes\napp.get(\"/users/id/:id\", handleUser); // Matches /users/id/123\napp.get(\"/users/name/:name\", handleByName); // Matches /users/name/john\n```\n\n- **Result**: No overlap, ensuring predictable behavior.\n\n### **Not Found Handler**\n\n- The `notFound` handler follows the same descending overwrite rule (parent to child).\n\n---\n\n## **3. Route Matching Priority**\n\nRoutes are matched based on the following priority order:\n\n1. **Static Paths** (e.g., `/users/list`)\n   - Exact matches take precedence.\n2. **Named Parameters** (e.g., `/users/:id`)\n   - Dynamic segments with specific names.\n3. **Wildcard Parameters** (e.g., `/users/*`)\n   - Catch-all patterns for remaining segments.\n4. **Optional Parameters** (e.g., `/users/:id?`)\n   - Lowest priority due to optional nature.\n\n- **Note**: More specific routes are evaluated before less specific ones.\n\n## **4. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# TezX - High-Performance Backend Framework\n\nTezX is a cutting-edge, high-performance, and lightweight JavaScript framework designed for speed, scalability, and flexibility. Built with modern web development needs in mind, TezX enables efficient routing, middleware management, and static file serving with minimal configuration. It is fully compatible with **Node.js, Deno, and Bun**, making it a truly cross-environment framework.\n\n---\n\n## üöÄ Key Features\n\n- **High Performance:** Optimized for speed and scalability.\n- **Minimal & Intuitive API:** Simple yet powerful.\n- **Built-in Static File Serving:** No additional setup required.\n- **Robust Middleware Support:** Easily extend functionality.\n- **Dynamic & Flexible Routing:** Define routes with ease.\n- **Security First:** Designed with security best practices.\n- **Efficient HTTP Handling:** Built for high concurrency.\n- **Cross-Environment Support:** Works with **Node.js, Deno, and Bun**.\n\n---\n\n## üì¶ Installation\n\n### **1. Create a New Project**\n\n```bash\nmkdir my-tezx-app\ncd my-tezx-app\n```\n\n### **2. Install TezX Framework**\n\n#### **For Node.js**\n\n```bash\nnpm init -y\nnpm install tezx\n```\n\n#### **For Bun**\n\n```bash\nbun add tezx\n```\n\n### **3. Project Structure Setup**\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment config\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îî‚îÄ‚îÄ tsconfig.json      # TypeScript config\n```\n\n---\n\n## ‚öôÔ∏è **Environment Configuration**\n\n### **1. Create `.env` File**\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üíª **Basic Server Setup**\n\n### **1. Create `src/index.ts`**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\nimport { nodeAdapter } from \"tezx/adapter\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX!\");\n});\n\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`Server running on port ${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\n### **Clone Repository & Install Dependencies**\n\n```bash\ngit clone https://github.com/tezxjs/tezx-app-example\nnpm install tezx@latest\n```\n\n### **Run Project in Development Mode**\n\n```bash\nnpm run dev\n```\n\nThis will start the TezX server on **<http://localhost:3000>**.\n\n---\n\n## **Platform-Specific Configurations**\n\n### **Node.js**\n\nAdd the following scripts to **`package.json`**:\n\n```json\n\"scripts\": {\n    \"clean\": \"rm -rf dist\",\n    \"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n    \"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n    \"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n    \"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n    \"start\": \"node dist/index.js\",\n    \"nodemon\": \"nodemon src/index.ts\",\n    \"dev\": \"tsx watch src/index.ts\"\n}\n```\n\n### **Bun**\n\n```json\n\"scripts\": {\n    \"dev\": \"bun run --hot --watch src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { bunAdapter } from \"tezx/adapter\";\nbunAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n### **Deno**\n\n```json\n\"scripts\": {\n    \"dev\": \"deno run --watch --allow-net --allow-read --allow-env --unstable-sloppy-imports src/index.ts\"\n}\n```\n\n**`src/index.ts`**\n\n```ts\nimport { denoAdapter } from \"tezx/adapter\";\ndenoAdapter(server).listen(3000, (message) => {\n  console.log(message);\n});\n```\n\n---\n\n## üîß **Advanced Configuration**\n\n### **1. Add Static File Support**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## **Build & Deployment**\n\n### **Compiling TypeScript to JavaScript**\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n#### **Using `pkgroll`**\n\n```json\n\"build\": \"npx pkgroll --clean-dist\"\n```\n\n### **Exports Configuration for Node.js**\n\n```json\n\"exports\": {\n    \".\": {\n      \"require\": \"./dist/index.js\",\n      \"import\": \"./dist/index.mjs\",\n      \"types\": \"./dist/index.d.ts\"\n    }\n}\n```\n\n---\n\n## üö® **Troubleshooting**\n\n### **Common Issues & Solutions**\n\n| Error                           | Solution                         |\n| ------------------------------- | -------------------------------- |\n| `Cannot find module 'tezx'`     | Run `npm install`                |\n| `Port already in use`           | Change `PORT` in `.env`          |\n| `TypeScript compilation errors` | Check `tsconfig.json` settings   |\n| `Missing .env variables`        | Verify file path and permissions |\n\n---\n\n## üìú License\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX - Build fast, scale faster.**\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "# **TezX Configuration**\n\n## **Overview**\n\nThe `TezX` class constructor accepts a configuration object that customizes server behavior, including middleware handling, route overwriting, logging, environment variables, and base path settings. This guide details each option and provides practical examples.\n\n---\n\n## **Example Configuration**\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/helper\";\nimport { logger } from \"tezx/middleware\";\n\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  debugMode: true,\n  env, // Environment variables\n  allowDuplicateMw: true, // Allow duplicate middleware\n  basePath, // Base path for all routes\n  overwriteMethod: false, // Prevent overwriting existing handlers\n});\n```\n\n---\n\n## **Configuration Type Definition**\n\nThe `TezXConfig` type defines available options, extending `RouterConfig` for routing-specific settings.\n\n```ts\nexport type TezXConfig = {\n  /**\n   * Controls whether duplicate middleware functions are allowed.\n   * - `true`: Permits multiple instances of the same middleware.\n   * - `false`: Ensures uniqueness by filtering duplicates.\n   * @default false\n   */\n  allowDuplicateMw?: boolean;\n\n  /**\n   * Determines if new route handlers overwrite existing ones for the same\n   * HTTP method and path.\n   * - `true`: New handler replaces the existing one.\n   * - `false`: Preserves the original handler.\n   * @default true\n   */\n  overwriteMethod?: boolean;\n\n  /**\n   * Enables or disables debugging for the middleware.\n   * When set to `true`, detailed debug logs will be output,\n   * useful for tracking the flow of requests and identifying issues.\n   *\n   * @default false\n   */\n  debugMode?: boolean;\n} & RouterConfig;\n\nexport type RouterConfig = {\n  /**\n   * Environment variables as key-value pairs.\n   * Keys are strings; values can be strings or numbers.\n   */\n  env?: Record<string, string | number>;\n\n  /**\n   * Base path prefix for all routes in the router.\n   */\n  basePath?: string;\n};\n```\n\n---\n\n## **Configuration Options Explained**\n\n### **1. `allowDuplicateMw`**\n\n- **Type**: `boolean`\n- **Default**: `false`\n- **Purpose**: Controls whether duplicate middleware can be registered for a route or context.\n- **Behavior**:\n  - `true`: Allows duplicates, enabling multiple executions.\n  - `false`: Filters duplicates, ensuring each middleware is unique.\n- **Example**:\n\n  ```ts\n  app.use((ctx, next) => next()); // First instance\n  app.use((ctx, next) => next()); // Second instance (allowed if true)\n  ```\n\n---\n\n### **2. `overwriteMethod`**\n\n- **Type**: `boolean`\n- **Default**: `true`\n- **Purpose**: Determines if a new handler overwrites an existing one for the same method and path.\n- **Behavior**:\n  - `true`: New handler replaces the old one.\n  - `false`: Original handler persists; new handler is ignored.\n- **Example**:\n\n  ```ts\n  app.get(\"/products\", (ctx) => ctx.text(\"Old\"));\n  app.get(\"/products\", (ctx) => ctx.text(\"New\")); // Overwrites if true\n  ```\n\n---\n\n### **3. `debugMode`**\n\n- **Type**: `boolean`\n- **Default**: `undefined`\n- **Purpose**: Enables or disables detailed logging for tracking application events, such as requests, responses, or errors.\n- **Behavior**: When set to `true`, logging functions for various levels (`info`, `warn`, `error`, etc.) are enabled, providing insights into application behavior. When set to `false`, logging is disabled.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ debugMode: true });\n  ```\n\n---\n\n### **4. `env`**\n\n- **Type**: `Record<string, string | number>`\n- **Default**: `undefined`\n- **Purpose**: Supplies environment variables for configuration.\n- **Behavior**: Accessible throughout the app via the server instance.\n- **Example**:\n\n  ```ts\n  const env = { PORT: \"3001\", API_KEY: \"secret\" };\n  const app = new TezX({ env });\n  console.log(app.config.env.PORT); // \"3001\"\n  ```\n\n---\n\n### **5. `basePath`**\n\n- **Type**: `string`\n- **Default**: `undefined`\n- **Purpose**: Sets a prefix for all registered routes.\n- **Behavior**: Prepends the base path to all route paths.\n- **Example**:\n\n  ```ts\n  const app = new TezX({ basePath: \"/api\" });\n  app.get(\"/products\", (ctx) => ctx.text(\"Products\")); // /api/products\n  ```\n\n---\n\n## **Usage Example with Routes**\n\n```ts\nimport { Router, TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { loadEnv } from \"tezx/helper\";\nimport { denoAdapter } from \"tezx/adapter\";\nconst env = loadEnv();\nconst basePath = \"/api\";\n\nconst app = new TezX({\n  logger,\n  env,\n  allowDuplicateMw: true,\n  basePath,\n  overwriteMethod: false,\n});\n\n// Standalone route\napp.get(\"/products/test\", (ctx) => ctx.text(\"From outside\"));\n\n// Product sub-router\nconst productRouter = new Router();\nproductRouter.group(\"\", (group) => {\n  group.use((ctx, next) => {\n    console.log(\"Inside router\");\n    return next();\n  });\n  group.get(\"/products\", async (ctx) => ctx.json({}));\n});\napp.use(\"/\", productRouter);\n\n// Start server\ndenoAdapter(server).listen(3001, () => {\n  console.log(\"Server running on http://localhost:3001\");\n});\n```\n\n### **Resulting Routes**\n\n- `/api/products/test` ‚Üí \"From outside\"\n- `/api/products` ‚Üí `{}` (with middleware logging)\n\n---\n\n## **Key Interactions**\n\n- **`allowDuplicateMw` + Middleware**: With `true`, middleware can repeat (e.g., logging twice).\n- **`overwriteMethod` + Routes**: With `false`, redefining `/products` preserves the original handler.\n- **`basePath` + Routes**: All routes inherit `/api`, enabling versioning or prefixing.\n\n---\n\n## **Best Practices**\n\n1. **Protect Routes in Production**\n\n   - Set `overwriteMethod: false` to avoid accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Organize with `basePath`**\n\n   - Use prefixes like `/v1` or `/api` for clarity:\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n```\n\n3. **Enhance Logging**\n\n   - Include timestamps and details in `logger`:\n\n```ts\nconst logger = (msg: string) =>\n  console.log(`[${new Date().toISOString()}] ${msg}`);\n```\n\n4. **Safely Access `env`**\n\n   - Check critical variables:\n\n```ts\nconst port = app.config.env.PORT || \"3000\";\n```\n\n---\n"
    },
    {
      "id": 5,
      "path": "getting-started/node",
      "name": "Node",
      "folder": "Getting Started",
      "content": "# **TezX + Node.js**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide demonstrates how to set up **TezX** with **Node.js** and use **pkgroll** for bundling the application.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Node.js**\n\nEnsure that you have **Node.js** installed. You can download it from the official [Node.js website](https://nodejs.org/). To verify the installation, run the following commands:\n\n```bash\nnode -v\nnpm -v\n```\n\n### 2. **Create a New Project**\n\nCreate a new directory for your project and navigate into it:\n\n```bash\nmkdir tezx-node-app && cd tezx-node-app\n```\n\n### 3. **Initialize the Project**\n\nInitialize a **Node.js** project using the following command:\n\n```bash\nnpm init -y\n```\n\n### 4. **Install TezX Framework**\n\nInstall **TezX** as a dependency:\n\n```bash\nnpm install tezx\n```\n\n### 5. **Install pkgroll**\n\nInstall **pkgroll** as a development dependency for bundling your application:\n\n```bash\nnpm install --save-dev pkgroll\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.js        # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.js          # Environment configuration\n‚îú‚îÄ‚îÄ public/             # Static assets\n‚îú‚îÄ‚îÄ .env                # Environment variables\n‚îú‚îÄ‚îÄ package.json        # Project metadata and dependencies\n‚îî‚îÄ‚îÄ tsconfig.json       # TypeScript configuration (optional)\n```\n\n---\n\n## üíª **Setting Up the Server**\n\n### 1. **Configure Environment Variables**\n\nCreate a `.env` file in the root of your project to store environment variables:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n### 2. **Set Up the Server**\n\nCreate the main server file in `src/index.js`:\n\n```javascript\nconst { TezX } = require(\"tezx\");\nconst { logger } = require(\"tezx/middleware\");\nconst { loadEnv } = require(\"tezx/helper\");\nimport { nodeAdapter } from \"tezx/adapter\";\n\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize TezX server\nconst app = new TezX({\n  env: env,\n});\n\napp.use(logger());\n// Define a simple route\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello TezX on Node.js!\");\n});\n\n// Start the server with Node.js adapter\nnodeAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running on http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo run the server in development mode, use the following command:\n\n```bash\nnode src/index.js\n```\n\nFor **development with hot reloading**, you can use **Nodemon**:\n\n1. Install **Nodemon** as a development dependency:\n\n```bash\nnpm install --save-dev nodemon\n```\n\n2. Add a script to `package.json` for running the app with hot reload:\n\n```json\n\"scripts\": {\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\nRun the server in development mode:\n\n```bash\nnpm run dev\n```\n\nThe server will be available at `http://localhost:3000`.\n\n---\n\n## üì¶ **Building & Bundling with pkgroll**\n\n### 1. **Add Build Script**\n\nNow, let's use **pkgroll** to bundle your application. First, update the `scripts` section of your `package.json` to include a build command:\n\n```json\n\"scripts\": {\n  \"build\": \"npx pkgroll --clean-dist\",\n  \"start\": \"node dist/index.js\",\n  \"dev\": \"nodemon src/index.js\"\n}\n```\n\n#### **Using `tsc`**\n\n```json\n\"clean\": \"rm -rf dist\",\n\"build:cjs\": \"tsc --module CommonJS --outDir dist/cjs --removeComments\",\n\"build:esm\": \"tsc --module ESNext --outDir dist/mjs --removeComments\",\n\"build:dts\": \"tsc --module ESNext --outDir dist/types --declaration --emitDeclarationOnly\",\n\"build\": \"npm run clean && npm run build:cjs && npm run build:esm && npm run build:dts\",\n```\n\n**tsconfig.json**:\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"CommonJS\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"removeComments\": false,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n### 2. **Build the Application**\n\nTo bundle your application for production, use **pkgroll**:\n\n```bash\nnpm run build\n```\n\nThis command will clean the `dist` directory and bundle your application for production in the `dist` folder.\n\n---\n\n## üîß **Advanced Configuration**\n\n### 1. **Static File Serving**\n\nTo serve static files, you can use the `static()` method from **TezX**:\n\n```javascript\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing), use the following configuration:\n\n```javascript\nconst { cors } = require(\"tezx/middleware\");\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### 3. **Custom Middleware**\n\nFor adding custom middleware, define it like this:\n\n```javascript\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**             | **Solution**                                                                              |\n| --------------------- | ----------------------------------------------------------------------------------------- |\n| `Module not found`    | Run `npm install` to ensure all dependencies are installed.                               |\n| `Port already in use` | Change the `PORT` value in `.env` or set the environment variable before running the app. |\n| `Permission Denied`   | Ensure you have the necessary permissions for your environment variables.                 |\n\n---\n\n## üìú **License**\n\nTezX is open-source under the MIT License. See [LICENSE](LICENSE) for details.\n\n---\n\nüöÄ **TezX + Node.js: Fast, Scalable, and Flexible!**\n\n---\n"
    },
    {
      "id": 6,
      "path": "getting-started/bun",
      "name": "Bun",
      "folder": "Getting Started",
      "content": "# TezX + Bun\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide provides a structured approach to setting up **TezX** with **Bun** for a seamless development experience.\n\n---\n\n## üöÄ Getting Started\n\n### **1. Install Bun**\n\nIf you haven‚Äôt installed **Bun** yet, install it using:\n\n```bash\ncurl -fsSL https://bun.sh/install | bash\n```\n\nOr, using **npm**:\n\n```bash\nnpm install -g bun\n```\n\nVerify the installation:\n\n```bash\nbun --version\n```\n\nor To install bun command, follow the instruction in the official web site.\n<https://bun.sh>\n\n### **2. Create a New Project**\n\n```bash\nmkdir tezx-bun-app && cd tezx-bun-app\n```\n\n### **3. Initialize Bun Project**\n\n```bash\nbun init\n```\n\nThis will generate a `bun.lockb` file and `package.json`.\n\n### **4. Install TezX**\n\n```bash\nbun add tezx\n```\n\n---\n\n## üìÇ Project Structure\n\n```bash\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main server file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment variables\n‚îú‚îÄ‚îÄ public/            # Static files\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ tsconfig.json      # TypeScript config\n‚îî‚îÄ‚îÄ package.json       # Project config\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate `src/index.ts`:\n\n```ts\nimport { TezX } from \"tezx\";\nimport { logger } from \"tezx/middleware\";\nimport { loadEnv } from \"tezx/helper\";\nimport { bunAdapter } from \"tezx/adapter\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Bun!\");\n});\n\nbunAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n### **5. Configure Environment Variables**\n\nCreate a `.env` file:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nStart the development server:\n\n```bash\nbun run src/index.ts\n```\n\nFor hot reloading:\n\n```bash\nbun run --hot src/index.ts\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### **1. Build the Project**\n\n```bash\nbun build src/index.ts --outdir dist\n```\n\n### **2. Run the Compiled File**\n\n```bash\nbun run dist/index.js\n```\n\n---\n\n## üî• **Advanced Features**\n\n### **1. Static File Serving**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### **2. Enable CORS**\n\n```ts\nimport { cors } from \"tezx/middleware\";\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  }),\n);\n```\n\n### **3. Custom Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| Issue                           | Solution                                 |\n| ------------------------------- | ---------------------------------------- |\n| `Cannot find module 'tezx'`     | Run `bun install`                        |\n| `Port already in use`           | Change `PORT` in `.env`                  |\n| `Missing .env variables`        | Verify file path and permissions         |\n| `Unexpected token` in Bun build | Ensure TypeScript is properly configured |\n\n---\n\nüöÄ **TezX + Bun ‚Äì Fast, Lightweight, and Scalable!**\n"
    },
    {
      "id": 7,
      "path": "getting-started/deno",
      "name": "Deno",
      "folder": "Getting Started",
      "content": "### Coming soon\n\n<!--\n\n---\n\n# **TezX + Deno: High-Performance Backend Framework**\n\nTezX is a high-performance, lightweight backend framework designed for speed, scalability, and flexibility. This guide walks you through the setup and configuration of **TezX** with **Deno** for a seamless and efficient development experience.\n\n---\n\n## üöÄ **Getting Started**\n\n### 1. **Install Deno**\n\nTo install **Deno**, use the following commands based on your platform:\n\n#### For Unix-based systems\n\n```bash\ncurl -fsSL https://deno.land/x/install/install.sh | sh\n```\n\n#### For macOS (using Homebrew)\n\n```bash\nbrew install deno\n```\n\nVerify the installation:\n\n```bash\ndeno --version\n```\n\n### 2. **Create a New Project**\n\nSet up a new project directory:\n\n```bash\nmkdir tezx-deno-app && cd tezx-deno-app\n```\n\n### 3. **Initialize the Project**\n\nIn **Deno**, dependencies are managed with the `deps.ts` file. Create the file and import the necessary TezX modules:\n\nCreate `deps.ts`:\n\n```ts\nexport { TezX, loadEnv, logger, denoAdapter } from \"https://deno.land/x/tezx/mod.ts\";\n```\n\n### 4. **Set Up Environment Variables**\n\nDeno requires explicit permission to access environment variables. Create a `.env` file in the root of your project:\n\nCreate `.env`:\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=your_secure_key_here\n```\n\n---\n\n## üìÇ **Project Structure**\n\nThe recommended project structure is as follows:\n\n```\n.\n‚îú‚îÄ‚îÄ src/\n‚îÇ   ‚îú‚îÄ‚îÄ index.ts       # Main application file\n‚îÇ   ‚îî‚îÄ‚îÄ env.ts         # Environment configuration\n‚îú‚îÄ‚îÄ public/            # Static assets\n‚îú‚îÄ‚îÄ .env               # Environment variables\n‚îú‚îÄ‚îÄ deps.ts            # External dependencies\n‚îî‚îÄ‚îÄ deno.json          # Deno configuration\n```\n\n---\n\n## üíª **Setting Up the Server**\n\nCreate a `src/index.ts` file and initialize the TezX server with Deno:\n\n```ts\nimport { TezX, loadEnv, logger, denoAdapter } from \"../deps.ts\";\n\nconst env = loadEnv();\nconst app = new TezX({\n  logger: logger,\n  env: env,\n});\n\napp.get(\"/\", (ctx) => {\n  return ctx.text(\"Hello, TezX on Deno!\");\n});\n\ndenoAdapter(server).listen(env.PORT, () => {\n  console.log(`üöÄ Server running at http://localhost:${env.PORT}`);\n});\n```\n\n---\n\n## ‚ñ∂Ô∏è **Running the Server**\n\nTo start the server, run the following command:\n\n```bash\ndeno run --allow-net --allow-read --allow-env src/index.ts\n```\n\nFor **hot reloading** during development, install **denon**:\n\n```bash\ndeno install -qAf --unstable https://deno.land/x/denon/denon.ts\n```\n\nRun the server with hot reload:\n\n```bash\ndenon start\n```\n\n---\n\n## üì¶ **Building & Deploying**\n\n### 1. **Compile the Project**\n\nTo compile the project to a single executable, use the following command:\n\n```bash\ndeno compile --allow-net --allow-read --allow-env -o dist/app src/index.ts\n```\n\n### 2. **Run the Compiled File**\n\nOnce compiled, run the generated executable:\n\n```bash\n./dist/app\n```\n\n---\n\n## üî• **Advanced Features**\n\n### 1. **Static File Serving**\n\nTo serve static files, use the following code:\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: {\n    \"X-Custom-Header\": \"static-file\",\n  },\n});\n```\n\n### 2. **Enable CORS**\n\nTo enable **CORS** (Cross-Origin Resource Sharing) for your application, use this:\n\n```ts\nimport { cors } from \"../deps.ts\";\n\napp.use(\n  cors({\n    origin: [\"http://localhost:3000\"],\n    methods: [\"GET\", \"POST\"],\n  })\n);\n```\n\n### 3. **Custom Middleware**\n\nFor custom middleware functionality:\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${new Date().toISOString()}] ${ctx.method} ${ctx.pathname}`);\n  return next();\n});\n```\n\n---\n\n## üöÄ **Deploying with Deno**\n\n### 1. **Deploy on Deno Deploy**\n\nDeno provides an easy way to deploy your application to the cloud using **Deno Deploy**:\n\n1. Install the **Deno Deploy CLI**:\n\n```bash\ncurl -fsSL https://deno.land/x/deploy/install.sh | sh\n```\n\n2. Deploy your project:\n\n```bash\ndeno deploy\n```\n\n### 2. **Deploy with Docker**\n\nTo deploy with **Docker**, create a `Dockerfile` in your project root:\n\n```Dockerfile\nFROM denoland/deno:latest\nWORKDIR /app\nCOPY . .\nCMD [\"deno\", \"run\", \"--allow-net\", \"--allow-read\", \"--allow-env\", \"src/index.ts\"]\n```\n\nBuild and run the Docker container:\n\n```bash\ndocker build -t tezx-deno .\ndocker run -p 3000:3000 tezx-deno\n```\n\n---\n\n## ‚ö†Ô∏è **Troubleshooting**\n\n| **Issue**                           | **Solution**                                 |\n| ------------------------------------ | -------------------------------------------- |\n| `Module not found`                  | Check if `deps.ts` is correctly imported.    |\n| `Port already in use`               | Change the `PORT` value in `.env`.           |\n| `Permission Denied`                 | Ensure you have the necessary `--allow` flags. |\n\n---\n\nüöÄ **TezX + Deno: Fast, Lightweight, and Secure!**\n\n---\n\n-->\n"
    },
    {
      "id": 8,
      "path": "api/middleware-api/merging-middlewares",
      "name": "Merging Middlewares",
      "folder": "API/Middleware API",
      "content": "# **Merging Middlewares**\n\n## **Overview**\n\nThe `mergeMiddleware` function integrates middleware from a new router into an existing parent router structure. This process mirrors route merging, efficiently combining middleware arrays while respecting the `allowDuplicateMw` configuration for handling duplicates.\n\n---\n\n## **Before Merging**\n\n### **Parent Router (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n```\n\n- `/test`: Middleware array `[m1]`.\n- `/test/1`: Nested route with middleware `[m2]`.\n\n---\n\n## **New Router to Merge (`RouterMiddlewares`)**\n\n### **New Sub-Router**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m3]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]\n```\n\n- `/test`: Middleware array `[m3]`.\n- `/test/2`: Nested route with middleware `[m4]`.\n\n---\n\n## **After Merging**\n\n### **Resulting Structure (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/1\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m2]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/test/2\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [m4]  # New addition\n```\n\n- `/test`: Middleware arrays `[m1]` and `[m3]` are combined into `[m1, m3]`.\n- `/test/1`: Remains unchanged with `[m2]`.\n- `/test/2`: Added as a new child route with `[m4]`.\n\n---\n\n## **Configuration: `allowDuplicateMw`**\n\nThe `allowDuplicateMw` option controls whether duplicate middleware functions are permitted during merging or registration.\n\n### **Definition**\n\n```ts\n/**\n * Determines whether duplicate middleware functions are allowed in the router.\n *\n * - `true`: Permits the same middleware to be added multiple times.\n * - `false`: Ensures each middleware is registered only once per route or context.\n *\n * @default false\n */\nallowDuplicateMw?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Allows duplicate middleware\n  overwriteMethod: false, // Preserves existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`allowDuplicateMw: true`**\n\n- Permits duplicate middleware in the same array.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3, m3]  # Duplicates allowed\n  ```\n\n#### **`allowDuplicateMw: false` (Default)**\n\n- Filters out duplicates, ensuring uniqueness.\n- **Example**:\n\n  ```plaintext\n  RootMiddlewares\n   ‚îú‚îÄ‚îÄ \"/test\" (Middleware)\n   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [m1, m3]  # No duplicates\n  ```\n\n---\n\n## **Key Features**\n\n1. **Path-Based Merging**\n\n   - Middleware arrays are combined when paths match (e.g., `/test`).\n\n2. **Recursive Merging**\n\n   - Nested middleware (e.g., `/test/2`) is recursively integrated into the parent structure.\n\n3. **Memory Optimization**\n   - Post-merge, unused middleware arrays are cleared (`middlewares.length = 0`), and child nodes are reset (`children.clear()`) to free memory.\n\n---\n\n## **Example**\n\n### **Before Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n```\n\n### **New RouterMiddlewares**\n\n```plaintext\nRouterMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [rateLimiter]\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]\n```\n\n### **After Merging**\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter]  # Merged\n ‚îÇ   ‚îú‚îÄ‚îÄ children:\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/profile\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [logger]\n ‚îÇ       ‚îú‚îÄ‚îÄ \"/api/users/settings\" (Middleware)\n ‚îÇ           ‚îú‚îÄ‚îÄ middlewares: [audit]  # New child\n```\n\n#### **With `allowDuplicateMw: true`**\n\nIf `rateLimiter` is added again:\n\n```plaintext\nRootMiddlewares\n ‚îú‚îÄ‚îÄ \"/api/users\" (Middleware)\n ‚îÇ   ‚îú‚îÄ‚îÄ middlewares: [authMiddleware, rateLimiter, rateLimiter]  # Duplicates permitted\n```\n\n---\n\n## **Implementation Example**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\nconst app = new TezX({ allowDuplicateMw: false });\n\n// Parent middleware\napp.use(\"/api/users\", authMiddleware);\napp.use(\"/api/users/profile\", logger);\n\n// New sub-router\nconst newRouter = new Router();\nnewRouter.use(\"/api/users\", rateLimiter);\nnewRouter.use(\"/api/users/settings\", audit);\n\n// Merge\napp.use(\"/\", newRouter);\n\n// Resulting routes:\n// - /api/users         ‚Üí [authMiddleware, rateLimiter]\n// - /api/users/profile ‚Üí [logger]\n// - /api/users/settings ‚Üí [audit]\n```\n\n---\n\n## **Best Practices**\n\n1. **Control Duplicates**\n\n   - Set `allowDuplicateMw: false` in production to avoid unintended middleware repetition.\n\n```ts\nconst app = new TezX({ allowDuplicateMw: false });\n```\n\n2. **Debugging**\n\n   - Log middleware arrays to verify merging:\n\n```ts\napp.use(\"/test\", (ctx, next) => {\n  logger().info(\"Middleware m1\");\n  return next();\n});\n```\n\n3. **Optimize Middleware Order**\n\n   - Place critical middleware (e.g., authentication) before less critical ones (e.g., logging) to ensure proper execution flow.\n\n4. **Test Post-Merge Behavior**\n   - Validate the middleware chain after merging to ensure expected execution.\n\n---\n\n## **Summary**\n\n- **Recursive Strategy**: Merges middleware recursively across all nested levels.\n- **Configurable Duplicates**: `allowDuplicateMw` provides control over middleware uniqueness.\n- **Memory Efficient**: Clears unused structures post-merge to optimize resources.\n\n---\n"
    },
    {
      "id": 9,
      "path": "api/middleware-api/middleware",
      "name": "Middleware",
      "folder": "API/Middleware API",
      "content": "# **Middleware Guide**\n\n## **Overview**\n\nMiddleware in `TezX` enables preprocessing of requests before they reach the final route handler. It‚Äôs ideal for tasks like authentication, logging, rate limiting, and more, with a flexible chainable design.\n\n---\n\n## **Core Types**\n\n### **1. `Middleware<T>`**\n\nDefines middleware that processes requests and optionally invokes the next step in the chain.\n\n#### **Definition**\n\n```ts\ntype Middleware<T> = (\n  ctx: ctx<T>,\n  next: NextCallback,\n) => NextCallback | Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**:\n  - `ctx`: Typed context object with custom properties via `T`.\n  - `next`: Callback to proceed to the next middleware or handler.\n- **Returns**: `next()` (to continue), a `TezResponse`, or a `Promise<TezResponse>`.\n\n#### **Example**\n\n```ts\nconst logger: Middleware<any> = async (ctx, next) => {\n  console.log(`Request: ${ctx.req.method} ${ctx.req.pathname}`);\n  return next();\n};\n```\n\n---\n\n### **2. `Callback<T>`**\n\nDefines a final route handler that produces a response.\n\n#### **Definition**\n\n```ts\ntype Callback<T> = (ctx: ctx<T>) => Promise<TezResponse> | TezResponse;\n```\n\n- **Parameters**: `ctx` (context object).\n- **Returns**: A `TezResponse` or `Promise<TezResponse>`.\n\n#### **Example**\n\n```ts\nconst handler: Callback<any> = (ctx) => {\n  return ctx.json({ message: \"Hello\" });\n};\n```\n\n---\n\n### **3. `ctx<T>`**\n\nA flexible context object combining framework features with custom properties.\n\n#### **Definition**\n\n```ts\ntype ctx<T = {}> = Context<T> & T;\n```\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; name: string };\n}\n\nconst authMiddleware: Middleware<AuthContext> = async (ctx, next) => {\n  ctx.user = await getUser(ctx.headers.get(\"Authorization\"));\n  return next();\n};\n```\n\n---\n\n## **Middleware Registration (`use()`)**\n\nThe `use()` method registers middleware or sub-routers with flexible overloads.\n\n### **Method Overloads**\n\n| Signature             | Example                         | Description                           |\n| --------------------- | ------------------------------- | ------------------------------------- |\n| **Path + Middleware** | `.use(\"/api\", auth)`            | Applies middleware to `/api` routes.  |\n| **Path + Multiple**   | `.use(\"/admin\", [auth, audit])` | Chains multiple middleware for path.  |\n| **Path + Sub-Router** | `.use(\"/v1\", v1Router)`         | Mounts a sub-router at `/v1`.         |\n| **Global Middleware** | `.use(logger)`                  | Applies to all routes.                |\n| **Multiple Global**   | `.use([cors, bodyParser])`      | Registers multiple global middleware. |\n\n---\n\n## **Usage Patterns**\n\n### **1. Basic Middleware Chain**\n\n```ts\nserver\n  .use(logger) // Logs all requests\n  .use(cors()) // Adds CORS headers\n  .get(\"/\", (ctx) => ctx.text(\"Hello\"));\n```\n\n### **2. Path-Scoped Middleware**\n\n```ts\napp.use(\"/api\", apiRateLimiter).group(\"/api\", (group) => {\n  group.use(authMiddleware);\n  group.get(\"/data\", fetchDataHandler);\n});\n// Routes: /api/data ‚Üí [apiRateLimiter, authMiddleware, fetchDataHandler]\n```\n\n### **3. Mixed Middleware with Sub-Router**\n\n```ts\napp.use(\n  \"/uploads\",\n  [fileFilter, diskStorage], // Middleware array\n  uploadRouter, // Sub-router\n);\n```\n\n---\n\n## **Execution Order**\n\nMiddleware executes in registration order, with responses flowing back through the chain.\n\n```mermaid\nsequenceDiagram\n  Client->>Middleware1: Request\n  Middleware1->>Middleware2: next()\n  Middleware2->>Handler: next()\n  Handler->>Middleware2: Response\n  Middleware2->>Middleware1: Return\n  Middleware1->>Client: Final Response\n```\n\n---\n\n## **Best Practices**\n\n### **1. Ordering**\n\n- Register global middleware first, then path-specific middleware, and finally handlers.\n\n```ts\nserver\n  .use(requestID) // Assigns unique IDs\n  .use(logger) // Logs requests\n  .use(errorHandler) // Catches errors last\n  .get(\"/data\", dataHandler);\n```\n\n### **2. Path Matching**\n\n- **Wildcard Matching**: Use `*` for subpaths.\n\n  ```ts\n  app.use(\"/api*\", apiMiddleware); // Matches /api, /api/v1, etc.\n  ```\n\n- **Exact Matching**: Use precise paths.\n\n  ```ts\n  app.use(\"/admin\", adminAuth); // Matches /admin only\n  ```\n\n### **3. Type Safety**\n\n- Extend context with generics for type-safe properties.\n\n```ts\ninterface AnalyticsContext {\n  trackEvent: (name: string) => void;\n}\n\napp.use<AnalyticsContext>((ctx, next) => {\n  ctx.trackEvent = (name) => analytics.log(name);\n  return next();\n});\n\napp.get(\"/event\", (ctx) => {\n  ctx.trackEvent(\"PageView\");\n  return ctx.text(\"Tracked\");\n});\n```\n\n---\n\n## **Common Recipes**\n\n### **Authentication**\n\n```ts\nconst authCheck: Middleware<any> = async (ctx, next) => {\n  if (!ctx.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n  return next();\n};\n\napp.use(\"/dashboard\", authCheck, (ctx) => {\n  return ctx.html(dashboardTemplate(ctx.user));\n});\n```\n\n### **Rate Limiting**\n\n```ts\nconst rateLimit = createRateLimiter({ limit: 100, windowMs: 60000 });\napp.use(\"/api\", rateLimit, apiHandler);\n```\n\n### **Request Validation**\n\n```ts\nconst validateSchema = (schema) => async (ctx, next) => {\n  const body = await ctx.req.json();\n  if (!schema.validate(body)) {\n    return ctx.status(400).json({ error: \"Invalid data\" });\n  }\n  return next();\n};\n\napp.post(\"/submit\", bodyParser(), validateSchema(submitSchema), submitHandler);\n```\n\n---\n\n## **Performance Tips**\n\n1. **Prioritize Synchronous Middleware**\n\n   - Place synchronous middleware before asynchronous ones to reduce latency.\n\n```ts\nserver\n  .use(syncOperation) // Fast sync task\n  .use(asyncMiddleware); // Slower async task\n```\n\n2. **Avoid Heavy Logic in Middleware**\n\n   - Delegate intensive tasks to handlers.\n\n```ts\n// ‚ùå Avoid\napp.use(async (ctx, next) => {\n  await processLargeFile();\n  return next();\n});\n\n// ‚úÖ Prefer\napp.get(\"/process\", (ctx) => processLargeFile());\n```\n\n3. **Cache Repeated Operations**\n\n   - Store results in the context to avoid redundant work.\n\n```ts\napp.use((ctx, next) => {\n  ctx.cachedData = expensiveOperation();\n  return next();\n});\n\napp.get(\"/data\", (ctx) => ctx.json(ctx.cachedData));\n```\n\n---\n\n## **Error Reference**\n\n| **Error Pattern**                             | **Solution**                                              |\n| --------------------------------------------- | --------------------------------------------------------- |\n| `Type 'X' is not assignable to Middleware<T>` | Ensure middleware follows `(ctx, next) => ...` signature. |\n| Missing `next()` call                         | Explicitly return `next()` or a `TezResponse`.            |\n| Type mismatches in `ctx`                      | Verify generic `T` aligns across middleware and handlers. |\n\n---\n"
    },
    {
      "id": 10,
      "path": "api/router/router-merging",
      "name": "Router Merging",
      "folder": "API/Router",
      "content": "---\n\n# **Router with Merging**\n\n## **Overview**\n\nRouter merging allows you to combine a parent router with a new sub-router, integrating their route structures seamlessly. The resulting **final router** depends on the configuration, particularly the `overwriteMethod` setting, which controls how overlapping routes are handled.\n\n- **Parent Router**: The existing routing structure before merging.\n- **New Sub-Router**: The routing structure to be merged into the parent.\n- **Final Router**: The combined structure after merging.\n\n---\n\n## **Example: Before Merge**\n\n### **Parent Router**\n\n```bash\nParent Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n```\n\n- `/test`: `GET` handler (`handler1`).\n- `/test/1`: `GET` handler (`handler2`).\n\n---\n\n## **Merging a New Router**\n\n### **New Sub-Router**\n\n```bash\nNew Sub-Router:\n‚îú‚îÄ‚îÄ products\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/products/2`: `GET` handler (`handler3`).\n\n---\n\n## **After Merging**\n\n### **Final Router**\n\n```bash\nFinal Router:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 1 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler2 }\n‚îú‚îÄ‚îÄ products (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ children:\n‚îÇ       ‚îú‚îÄ‚îÄ 2 (Router)\n‚îÇ           ‚îú‚îÄ‚îÄ GET -> { handler3 }\n```\n\n- `/test` and `/test/1` remain unchanged.\n- `/products/2` is added as a new root-level branch.\n\n#### **Note**\n\nIf the new sub-router‚Äôs paths overlap with the parent (e.g., both define `/test`), the `overwriteMethod` setting determines the outcome (see below).\n\n---\n\n## **Configuration: `overwriteMethod`**\n\nThe `overwriteMethod` option dictates how overlapping routes‚Äîwhere a new handler targets the same path and HTTP method as an existing one‚Äîare resolved.\n\n### **Definition**\n\n```ts\n/**\n * Controls whether existing route handlers are overwritten when a new handler\n * for the same HTTP method and path is added.\n *\n * - `true`: New handler replaces the existing one (default).\n * - `false`: Existing handler is preserved; new handler is ignored.\n *\n * @default true\n */\noverwriteMethod?: boolean;\n```\n\n### **Usage**\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX({\n  logger: logger,\n  allowDuplicateMw: true, // Optional: Allows duplicate middleware\n  overwriteMethod: false, // Prevents overwriting existing handlers\n});\n```\n\n### **Behavior**\n\n#### **`overwriteMethod: true` (Default)**\n\nNew handlers overwrite existing ones for the same path and method.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter adding new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { newHandler }\n```\n\n---\n\n#### **`overwriteMethod: false`**\n\nExisting handlers are preserved; new handlers are ignored.\n\n##### **Example**\n\n```bash\nBefore:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 }\n\nAfter attempting to add new GET handler:\n‚îú‚îÄ‚îÄ test (Router)\n‚îÇ   ‚îú‚îÄ‚îÄ GET -> { handler1 } (unchanged)\n```\n\n---\n\n## **Key Features**\n\n1. **Efficient Merging**\n\n   - Sub-routers integrate without affecting unrelated routes.\n   - Example: Merging `/products` doesn‚Äôt alter `/test`.\n\n2. **Overlapping Control**\n\n   - `overwriteMethod` provides flexibility for handling conflicts.\n\n3. **Nested Routes**\n   - Supports deep nesting (e.g., `/test/1`, `/products/2`).\n\n---\n\n## **Merging Example**\n\n### **Code**\n\n```ts\nimport { Router, TezX } from \"tezx\";\n\n// Parent router\nconst app = new TezX({ overwriteMethod: false });\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// New sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge\napp.use(\"/\", productRouter);\n\n// Resulting routes:\n// - GET /test     ‚Üí \"Handler 1\"\n// - GET /test/1   ‚Üí \"Handler 2\"\n// - GET /products/2 ‚Üí \"Handler 3\"\n```\n\n#### **With Overlap**\n\n```ts\nconst overlapRouter = new Router();\noverlapRouter.get(\"/test\", (ctx) => ctx.text(\"New Handler\"));\n\n// With overwriteMethod: false\napp.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"Handler 1\" (original preserved)\n\n// With overwriteMethod: true\nconst app2 = new TezX({ overwriteMethod: true });\napp2.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp2.use(\"/\", overlapRouter);\n// GET /test ‚Üí \"New Handler\" (overwritten)\n```\n\n---\n\n## **Best Practices**\n\n1. **Protect Production Routes**\n\n   - Set `overwriteMethod: false` to prevent accidental overwrites:\n\n```ts\nconst app = new TezX({ overwriteMethod: false });\n```\n\n2. **Debugging Conflicts**\n\n   - Use descriptive handler names or logging:\n\n```ts\napp.get(\"/test\", (ctx) => {\n  logger().info(\"Original /test handler\");\n  return ctx.text(\"Handler 1\");\n});\n```\n\n3. **Test Merged Structure**\n\n   - Verify the final router matches expectations:\n\n```ts\nconsole.log(app.routes); // Inspect route tree (if exposed)\n```\n\n4. **Consistent Prefixes**\n   - Use clear, non-overlapping prefixes for sub-routers (e.g., `/auth`, `/products`).\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/router/router-api",
      "name": "Router API",
      "folder": "API/Router",
      "content": "# **Router API**\n\n## **Overview**\n\nThe `Router` class provides a hierarchical, type-safe routing system with support for middleware, route grouping, and nested routers. It enables modular and organized route management for web applications.\n\n---\n\n## **Core Concepts**\n\n### **1. Router Class**\n\nA flexible routing system with the following features:\n\n| Feature              | Description                                   |\n| -------------------- | --------------------------------------------- |\n| **Nested Routing**   | Mount sub-routers with path prefixes.         |\n| **Middleware Chain** | Execute pre- and post-processing middleware.  |\n| **Path Isolation**   | Routes inherit parent path prefixes.          |\n| **Type Propagation** | Maintain typed context across nested routers. |\n\n---\n\n### **2. Middleware System**\n\nMiddleware executes sequentially in a defined order.\n\n#### **Execution Flow**\n\n```bash\ngraph TD\n  A[Request] --> B[Parent Middleware]\n  B --> C[Router Middleware]\n  C --> D[Route Middleware]\n  D --> E[Handler]\n  E --> F[Post Middleware]\n  F --> G[Response]\n```\n\n---\n\n### **3. Route Groups**\n\nLogically group routes with shared configuration and middleware.\n\n#### **Example**\n\n```ts\napp.group(\"/admin\", (group) => {\n  group.use(adminAuth, auditLogger); // Shared middleware\n  group.get(\"/users\", getAdminUsers);\n  group.post(\"/config\", updateConfig);\n});\n// Routes: /admin/users, /admin/config\n```\n\n---\n\n## **API Reference**\n\n### **1. `addRouter(path: string, router: Router)`**\n\nMounts a sub-router under a specified path prefix.\n\n#### **Parameters**\n\n| Parameter | Type     | Description                      |\n| --------- | -------- | -------------------------------- |\n| `path`    | `string` | Base path for sub-router routes. |\n| `router`  | `Router` | Configured sub-router instance.  |\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\n\nconst authRouter = new Router()\n  .post(\"/login\", handleLogin)\n  .get(\"/logout\", handleLogout);\n\n// Mount with prefix\napp.addRouter(\"/auth\", authRouter);\n// Routes: /auth/login, /auth/logout\n```\n\n#### **With Middleware**\n\n```ts\napp.use(\"/auth\", authRouter); // Supports middleware chain\n```\n\n#### **Restrictions**\n\n- Wildcards (`/*`) and optional parameters (`:param?`) are **not supported** in `path`.\n- Use `basePath` in the sub-router for dynamic parameters:\n\n  ```ts\n  const accountRouter = new Router<CustomContext>({\n    basePath: \"/account/:role?\",\n  });\n  app.use(\"/accounts\", accountRouter);\n  ```\n\n---\n\n### **2. `group(prefix: string, callback: (router: Router) => void)`**\n\nCreates a scoped route group with shared configuration.\n\n#### **Parameters**\n\n| Parameter  | Type       | Description                           |\n| ---------- | ---------- | ------------------------------------- |\n| `prefix`   | `string`   | Path prefix for the group.            |\n| `callback` | `function` | Callback receiving a router instance. |\n\n#### **Advanced Example**\n\n```ts\napp.group(\"/api/v1\", (group) => {\n  group.use(apiVersionHeader(\"v1\"), rateLimiter);\n\n  // Nested group\n  group.group(\"/users\", (userGroup) => {\n    userGroup.get(\"/:id\", getUser);\n    userGroup.patch(\"/:id\", updateUser);\n  });\n\n  group.delete(\"/posts/:id\", deletePost);\n});\n// Routes: /api/v1/users/123, /api/v1/posts/456\n```\n\n#### **Notes**\n\n- Supports dynamic parameters (e.g., `:id`), optional parameters (e.g., `:id?`), and wildcards (e.g., `*path`).\n\n---\n\n## **Advanced Configuration**\n\n### **1. Middleware Scoping**\n\nApply middleware at different levels.\n\n#### **Examples**\n\n```ts\n// Global middleware\napp.use(loggingMiddleware);\n\n// Router-specific middleware\nconst paymentRouter = new Router()\n  .use(validateCreditCard)\n  .post(\"/charge\", processPayment);\n\n// Route-specific middleware\napp.get(\"/admin/stats\", [adminAuth, geolock], getStatistics);\n```\n\n---\n\n### **2. Context Propagation**\n\nEnsure type-safe context inheritance across routers.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string };\n  requestId: string;\n}\n\nconst app = new Router<CustomContext>();\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ id: ctx.requestId });\n});\n```\n\n---\n\n### **3. Not Found Handler**\n\nCustomize the 404 response with descending overwrite behavior (parent to child).\n\n#### **Example**\n\n```ts\napp.notFound((ctx) => {\n  return ctx.text(\"Custom 404 Message\", 404);\n});\n```\n\n---\n\n### **4. Error Handler**\n\nCustomize error responses with descending overwrite behavior.\n\n#### **Example**\n\n```ts\napp.onError((error, ctx) => {\n  return ctx.text(error.message, 500);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Route Organization**\n\nStructure routes in a modular directory layout.\n\n#### **Example**\n\n```bash\nroutes/\n‚îú‚îÄ‚îÄ auth/\n‚îÇ   ‚îú‚îÄ‚îÄ login.ts\n‚îÇ   ‚îî‚îÄ‚îÄ logout.ts\n‚îú‚îÄ‚îÄ api/\n‚îÇ   ‚îú‚îÄ‚îÄ v1/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users.ts\n‚îÇ   ‚îî‚îÄ‚îÄ v2/\n‚îÇ       ‚îî‚îÄ‚îÄ users.ts\n```\n\n#### **Implementation**\n\n```ts\nimport authRoutes from \"./routes/auth\";\nimport apiV1Routes from \"./routes/api/v1\";\n\napp.use(\"/auth\", authRoutes);\napp.use(\"/api/v1\", apiV1Routes);\n```\n\n---\n\n### **2. Middleware Ordering**\n\n- Place authentication and validation middleware early.\n- Apply route-specific middleware close to handlers.\n\n#### **Example**\n\n```ts\napp.use(authMiddleware); // Global\napp.group(\"/secure\", (group) => {\n  group.use(rateLimiter); // Group-specific\n  group.get(\"/data\", [cacheMiddleware], getData); // Route-specific\n});\n```\n\n---\n\n### **3. Error and Not Found Handling**\n\n- Define fallback handlers at the top level and override in sub-routers as needed.\n\n```ts\napp.notFound((ctx) => ctx.text(\"Not Found\", 404));\napp.onError((err, ctx) => ctx.text(\"Server Error\", 500));\n\nconst subRouter = new Router().notFound((ctx) =>\n  ctx.text(\"Sub-router 404\", 404),\n);\napp.use(\"/sub\", subRouter); // Overrides parent notFound\n```\n\n---\n"
    },
    {
      "id": 12,
      "path": "api/router/route-parameter",
      "name": "Route Parameter",
      "folder": "API/Router",
      "content": "# **Parameter Types**\n\n## **Overview**\n\nThis section outlines the supported parameter types for route definitions in `TezX`, including standard, optional, and wildcard parameters. It covers their behaviors, matching priorities, and best practices for effective use.\n\n---\n\n## **1. Standard Parameters (`:param`)**\n\n### **Description**\n\nCaptures mandatory dynamic path segments between slashes.\n\n### **Syntax**\n\n```ts\n\"/path/:parameterName\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/users/:id\", (ctx) => {\n  // /users/123 ‚Üí ctx.req.params.id = \"123\"\n  return ctx.json({ id: ctx.req.params.id });\n});\n\napp.get(\"/posts/:year/:month\", (ctx) => {\n  // /posts/2023/09 ‚Üí { year: \"2023\", month: \"09\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Must be present in the request path.\n- **Delimiter**: Matches until the next `/`.\n- **Order-Dependent**: Must follow the declared sequence.\n\n---\n\n## **2. Optional Parameters (`:param?`)**\n\n### **Description**\n\nCaptures optional path segments that may be omitted.\n\n### **Syntax**\n\n```ts\n\"/path/:optionalParam?\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/archive/:year?/:month?\", (ctx) => {\n  // /archive/2023/08 ‚Üí { year: \"2023\", month: \"08\" }\n  // /archive/2023     ‚Üí { year: \"2023\", month: undefined }\n  // /archive          ‚Üí { year: undefined, month: undefined }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Optional**: Can be absent from the request.\n- **Sequential**: Must appear at the end; subsequent parameters must also be optional.\n- **Default**: Returns `undefined` if not provided.\n\n---\n\n## **3. Wildcard Parameters (`*`)**\n\n### **Description**\n\nCaptures all remaining path segments as a single string. `use it always end.\n\n**Not wokring**:\n\n```ts\n// ‚ùå not working. return 404 error\napp.get(\"/uploads/*folder/:test\", (ctx) => {\n  console.log(ctx.req.params);\n  return ctx.json({\n    success: true,\n    message: \"File uploaded successfully\",\n  });\n});\n```\n\n### **Syntax**\n\n```ts\n\"/path/*wildcardParam\";\n```\n\n### **Examples**\n\n```ts\napp.get(\"/files/*path\", (ctx) => {\n  // /files/images/2023/photo.jpg ‚Üí { path: \"images/2023/photo.jpg\" }\n  return ctx.json(ctx.req.params);\n});\n\napp.get(\"/docs/*category\", (ctx) => {\n  // /docs/api/v2/endpoints ‚Üí { category: \"api/v2/endpoints\" }\n  return ctx.json(ctx.req.params);\n});\n```\n\n### **Characteristics**\n\n- **Mandatory**: Always returns a string (empty if no segments follow).\n- **Final**: Must be the last segment in the route.\n- **Greedy**: Captures all remaining segments, including nested paths.\n\n---\n\n## **Matching Priority**\n\nRoutes are matched in this order:\n\n1. **Static Paths** (e.g., `/users/list`) ‚Äì Highest priority.\n2. **Named Parameters** (e.g., `/users/:id`) ‚Äì Specific dynamic segments.\n3. **Wildcard Parameters** (e.g., `/users/*`) ‚Äì Broad capture.\n4. **Optional Parameters** (e.g., `/users/:id?`) ‚Äì Lowest priority.\n\n### **Example Hierarchy**\n\n```ts\napp.get(\"/users/list\", handleList); // Matches first\napp.get(\"/users/:id\", handleUser);\napp.get(\"/users/*\", catchAll); // Matches last\n```\n\n---\n\n## **Parameter Access**\n\nParameters are accessed via `ctx.req.params`:\n\n### **Interface**\n\n```ts\ninterface Params {\n  [key: string]: string | undefined;\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/shop/:category/:item?\", (ctx) => {\n  const { category, item } = ctx.req.params;\n  // category: string (required)\n  // item: string | undefined (optional)\n  return ctx.json({ category, item });\n});\n```\n\n---\n\n## **Conflict Resolution**\n\n### **Ambiguous Routes**\n\nConflicting routes are resolved by the last registered handler.\n\n#### **Problem**\n\n```ts\napp.get(\"/users/:id\", handleUser); // Overwritten\napp.get(\"/users/:name\", handleByName); // Takes precedence\n// /users/john ‚Üí { name: \"john\" }\n```\n\n#### **Solution**\n\n```ts\napp.get(\"/users/id/:id\", handleUser); // /users/id/123\napp.get(\"/users/name/:name\", handleByName); // /users/name/john\n```\n\n---\n\n### **Wildcard Position**\n\nWildcards must be the final segment.\n\n#### **Invalid**\n\n```ts\napp.get(\"/*/profile\", handleProfile); // ‚ùå Wildcard not final\n```\n\n#### **Valid**\n\n```ts\napp.get(\"/user/*/profile\", handleProfile); // ‚úÖ Static prefix\n```\n\n---\n\n## **Escaping Special Characters**\n\nEscape `:` or `*` with a backslash to match literally.\n\n### **Examples**\n\n```ts\napp.get(\"/colon\\\\:test\", (ctx) => {\n  // Matches: /colon:test\n  return ctx.text(\"Colon matched\");\n});\n\napp.get(\"/asterisk\\\\*test\", (ctx) => {\n  // Matches: /asterisk*test\n  return ctx.text(\"Asterisk matched\");\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Order by Specificity**\n   - Register static routes before dynamic ones:\n\n```ts\napp.get(\"/api/static\", handleStatic);\napp.get(\"/api/:id\", handleDynamic);\n```\n\n2. **Validate Parameters**\n   - Sanitize and verify values:\n\n```ts\nconst id = parseInt(ctx.req.params.id);\nif (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n```\n\n3. **Limit Optional Parameters**\n\n   - Use sparingly for route clarity.\n\n4. **Document Complex Routes**\n   - Comment multi-parameter routes:\n\n```ts\n// Matches /api/v1/2023/users or /api/v1/users\napp.get(\"/api/v1/:version?/:resource\", handleApi);\n```\n\n5. **Control Wildcard Scope**\n   - Prioritize specific patterns:\n\n```ts\napp.get(\"/files/images/:id\", handleImage);\napp.get(\"/files/*path\", handleFile);\n```\n\n---\n\n## **`all()` - Universal Method Handler**\n\n### **Description**\n\nHandles all HTTP methods for a specified path.\n\n### **Signature**\n\n```ts\npublic all(path: string, ...args: RouteArgs): this\n```\n\n### **Parameter Support**\n\n| Type     | Example              | Captured Values                    |\n| -------- | -------------------- | ---------------------------------- |\n| Standard | `/:version/api`      | `version: \"v2\"`                    |\n| Optional | `/user/:id?/profile` | `id: \"123\" \\| undefined`           |\n| Wildcard | `/docs/*`            | `*path: \"getting-started\"`         |\n| Mixed    | `/:lang?/api/*`      | `lang: \"en\", *path: \"v2/endpoint\"` |\n\n### **Examples**\n\n#### **Basic Usage**\n\n```ts\napp.all(\"/healthcheck\", (ctx) => {\n  return ctx.text(`Method ${ctx.method} received`);\n});\n// GET /healthcheck ‚Üí \"Method GET received\"\n// POST /healthcheck ‚Üí \"Method POST received\"\n```\n\n#### **With Parameters**\n\n```ts\napp.all(\"/*service/status\", (ctx) => {\n  return ctx.json({\n    servicePath: ctx.req.params.service, // \"auth/api/v2\"\n    method: ctx.method, // \"PUT\"\n  });\n});\n// PUT /auth/api/v2/status ‚Üí { servicePath: \"auth/api/v2\", method: \"PUT\" }\n```\n\n#### **With Middleware**\n\n```ts\napp.all(\"/secure/:zone?\", [authMiddleware, loggingMiddleware], (ctx) => {\n  return ctx.text(`Accessed ${ctx.req.params.zone || \"default\"} zone`);\n});\n// POST /secure/admin ‚Üí Runs middleware, zone=\"admin\"\n```\n\n---\n\n## **`addMethod()` - Custom Method Registration**\n\n### **Description**\n\nRegisters handlers for non-standard or custom HTTP methods.\n\n### **Signature**\n\n```ts\npublic addMethod(method: HTTPMethod, path: string, ...args: RouteArgs): this\n```\n\n### **Supported Methods**\n\n| Standard Methods     | Custom Examples  |\n| -------------------- | ---------------- |\n| `GET`, `POST`, `PUT` | `PURGE`, `LOCK`  |\n| `PATCH`, `DELETE`    | `COPY`, `SEARCH` |\n| `HEAD`, `OPTIONS`    | `CUSTOM_API`     |\n\n### **Examples**\n\n#### **Custom Method**\n\n```ts\napp.addMethod(\"PURGE\", \"/cache/:region/:group*\", (ctx) => {\n  purgeCache({\n    region: ctx.req.params.region, // \"eu-west\"\n    group: ctx.req.params.group, // \"user-profiles/v2\"\n  });\n  return ctx.status(202).json({ success: true });\n});\n// PURGE /cache/eu-west/user-profiles/v2 ‚Üí { success: true }\n```\n\n#### **Optional Parameters**\n\n```ts\napp.addMethod(\"REPORT\", \"/stats/:type?\", (ctx) => {\n  generateReport(ctx.req.params.type || \"daily\");\n  return ctx.text(\"Report generated\");\n});\n// REPORT /stats/weekly ‚Üí \"Report generated\" (type=\"weekly\")\n// REPORT /stats ‚Üí \"Report generated\" (type=\"daily\")\n```\n\n#### **Wildcard**\n\n```ts\napp.addMethod(\"MSEARCH\", \"/files/*path\", (ctx) => {\n  searchFilesystem(ctx.req.params.path); // \"docs/archived/project.txt\"\n  return ctx.text(\"Search complete\");\n});\n// MSEARCH /files/docs/archived/project.txt ‚Üí \"Search complete\"\n```\n\n---\n\n## **Parameter Access Pattern**\n\n```ts\ninterface Context {\n  req: {\n    params: {\n      [key: string]: string | undefined;\n      \"*\": string; // Wildcard capture\n    };\n  };\n}\n\n// Access examples\nctx.req.params.paramName; // Standard/optional\nctx.req.params[\"*\"]; // Wildcard\n```\n\n---\n\n## **Conflict Resolution Table**\n\n| Method               | Path           | Priority | Match Example      |\n| -------------------- | -------------- | -------- | ------------------ |\n| `get()`              | `/cache/clear` | Highest  | `GET /cache/clear` |\n| `addMethod(\"PURGE\")` | `/cache`       | High     | `PURGE /cache`     |\n| `all()`              | `/cache/*`     | Medium   | `POST /cache/123`  |\n\n### **Resolution Rules**\n\n1. Exact method matches override `all()`.\n2. Specific paths take precedence over wildcards.\n3. Later registrations override earlier ones within the same priority.\n\n---\n\n## **Best Practices for `all()`**\n\n1. **Use Cases**\n\n   - Maintenance mode handlers.\n   - Global path-specific middleware.\n   - Method-agnostic endpoints.\n\n2. **Avoid**\n\n   - Complex logic suited for specific methods.\n   - Overlaps with method-specific handlers.\n\n3. **Ordering**\n\n```ts\napp.get(\"/api\", specificHandler); // Higher priority\napp.all(\"/*api\", globalMiddleware); // Lower priority\n```\n\n---\n"
    },
    {
      "id": 13,
      "path": "api/context/context-api",
      "name": "Context API",
      "folder": "API/Context",
      "content": "# **Context API**\n\nThis section outlines the public properties, methods, and utilities available on the context object (`ctx`) for handling requests and responses in your application.\n\n---\n\n## **Public Properties**\n\n| Property   | Type            | Description                                          |\n| ---------- | --------------- | ---------------------------------------------------- |\n| `env`      | `object`        | Environment variables and configuration.             |\n| `headers`  | `HeadersParser` | Instance for managing HTTP request/response headers. |\n| `pathname` | `string`        | Request path excluding query parameters.             |\n| `url`      | `string`        | Full request URL (protocol, host, path, query).      |\n| `method`   | `HTTPMethod`    | Uppercase HTTP method (e.g., `GET`, `POST`).         |\n| `state`    | `State`         | Container for sharing data across middleware.        |\n\n---\n\n## **Cookie Handling**\n\n### **`cookies` Getter**\n\nProvides a chainable API for managing HTTP cookies.\n\n#### **Methods**\n\n| Method   | Parameters                                                 | Description                              |\n| -------- | ---------------------------------------------------------- | ---------------------------------------- |\n| `get`    | `name: string`                                             | Retrieves a cookie value or `undefined`. |\n| `all`    | -                                                          | Returns all cookies as an object.        |\n| `set`    | `name: string`, `value: string`, `options?: CookieOptions` | Sets a cookie with optional settings.    |\n| `delete` | `name: string`, `options?: CookieOptions`                  | Invalidates a cookie.                    |\n\n#### **CookieOptions**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Inaccessible to JavaScript\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n#### **Usage**\n\n```ts\n// Get cookie\nconst session = ctx.cookies.get(\"sessionID\");\n\n// Set cookie\nctx.cookies.set(\"prefs\", \"darkMode=true\", { maxAge: 3600 });\n\n// Delete cookie\nctx.cookies.delete(\"oldSession\");\n```\n\n---\n\n## **Response Methods**\n\n### **1. `json(body, status?, headers?)`**\n\nSends a JSON response.\n\n#### **Usage**\n\n```ts\nctx.json({ message: \"Success\" });\nctx.json({ error: \"Not Found\" }, 404);\nctx.json(data, 200, { \"Cache-Control\": \"no-store\" });\n```\n\n---\n\n### **2. `send(body, status?, headers?)`**\n\nSends a response with auto-detected content type.\n\n#### **Usage**\n\n```ts\nctx.send(\"<h1>Hello</h1>\"); // text/html\nctx.send(Buffer.from(\"data\"), 201); // application/octet-stream\n```\n\n---\n\n### **3. `html(data, status?, headers?)`**\n\nSends an HTML response.\n\n#### **Usage**\n\n```ts\nctx.html(\"<div>Page</div>\");\nctx.html(template, 200, { ETag: \"123\" });\n```\n\n---\n\n### **4. `text(data, status?, headers?)`**\n\nSends a plain text response.\n\n#### **Usage**\n\n```ts\nctx.text(\"Processing complete\");\nctx.text(\"Error\", 500);\n```\n\n---\n\n### **5. `xml(data, status?, headers?)`**\n\nSends an XML response.\n\n#### **Usage**\n\n```ts\nctx.xml(\"<note><body>Message</body></note>\");\n```\n\n---\n\n### **6. `redirect(url, status=302, headers?)`**\n\nRedirects to a specified URL.\n\n#### **Usage**\n\n```ts\nctx.redirect(\"/login\");\nctx.redirect(\"https://external.site\", 301);\n```\n\n---\n\n### **7. `download(filePath, fileName?)`**\n\nTriggers a file download.\n\n#### **Usage**\n\n```ts\nawait ctx.download(\"/reports/q3.pdf\");\nawait ctx.download(\"/tmp/data.csv\", \"2023-data.csv\");\n```\n\n---\n\n### **8. `status(code)`**\n\nSets the HTTP status code (chainable).\n\n#### **Usage**\n\n```ts\nctx.status(404).text(\"Not found\");\nctx.status(201).json({ id: 42 });\n```\n\n---\n\n## **Request Access**\n\n### **`req` Getter**\n\nProvides a normalized request object.\n\n#### **Interface**\n\n```ts\ninterface Request {\n  method: HTTPMethod; // e.g., \"GET\"\n  headers: HeadersParser; // Request headers\n  params: Record<string, any>; // Route parameters\n  // Additional properties as needed\n}\n```\n\n#### **Usage**\n\n```ts\nconst userId = ctx.req.params.id;\nconst authHeader = ctx.req.headers.get(\"Authorization\");\n```\n\n---\n\n## **Headers (`headers`)**\n\n### **Description**\n\nManages request and response headers via the `HeadersParser` instance.\n\n#### **Usage**\n\n```ts\n// Get request header\nconst authHeader = ctx.req.headers.get(\"authorization\");\n\n// Set response header\nctx.headers.set(\"X-Response-Time\", Date.now().toString());\n```\n\n#### **Common Operations**\n\n```ts\n// Validate content type\nif (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n  // Process JSON request\n}\n\n// Set multiple headers\nctx.headers\n  .set(\"Cache-Control\", \"max-age=3600\")\n  .set(\"X-Powered-By\", \"MyFramework\");\n```\n\n---\n\n## **Example Workflow**\n\n### **Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID(); // Add custom property\n\n  if (!ctx.req.headers.get(\"Authorization\")) {\n    return ctx.status(401).json({ error: \"Unauthorized\" });\n  }\n\n  return await next();\n});\n```\n\n### **Route Handler**\n\n```ts\napp.get(\"/users/:id\", async (ctx) => {\n  const user = await db.getUser(ctx.req.params.id);\n\n  if (!user) {\n    return ctx.status(404).text(\"User not found\");\n  }\n\n  return ctx.json({\n    data: user,\n    requestId: ctx.requestId,\n  });\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. State Management**\n\nShare data across middleware using `state` or custom properties:\n\n```ts\n// Set in middleware\nctx.state.set(\"user\", authenticatedUser);\n// OR\nctx.user = authenticatedUser; // Context propagation\n\n// Access in route\nconst currentUser = ctx.state.get(\"user\");\n```\n\n### **2. Header Validation**\n\nEnsure content type compatibility:\n\n```ts\nconst contentType = ctx.req.headers.get(\"Content-Type\");\nif (![\"application/json\"].includes(contentType)) {\n  return ctx.status(415).text(\"Unsupported Media Type\");\n}\n```\n\n### **3. Parameter Sanitization**\n\nValidate dynamic parameters:\n\n```ts\nconst userId = parseInt(ctx.req.params.id);\nif (isNaN(userId)) {\n  return ctx.status(400).text(\"Invalid ID format\");\n}\n```\n\n---\n"
    },
    {
      "id": 14,
      "path": "api/context/state",
      "name": "State",
      "folder": "API/Context",
      "content": "# **State Management**\n\nThe `State` class provides a public container for storing and managing application data across middleware and plugins. It uses a `Map` internally to ensure efficient key-value storage and retrieval.\n\n---\n\n## **Overview**\n\nThe `ctx.state` property serves as a shared storage mechanism, enabling data persistence throughout the request lifecycle. It is particularly useful for passing information between middleware and route handlers.\n\n---\n\n## **Usage Example**\n\n```ts\n// Set state\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n\n// Retrieve state\nconsole.log(ctx.state.get(\"user\")); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n## **Class Definition**\n\n```ts\nexport class State {\n  private state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n```\n\n---\n\n## **Methods**\n\n### **`set(key: string, value: any): void`**\n\n#### **Description**\n\nStores a value under a specified key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The identifier for the value.\n- `value: any` ‚Äì The data to store (any type).\n\n#### **Example**\n\n```ts\nctx.state.set(\"user\", { id: 1, name: \"Alice\" });\n```\n\n---\n\n### **`get(key: string): any | undefined`**\n\n#### **Description**\n\nRetrieves the value associated with a key.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to look up.\n\n#### **Returns**\n\n- The stored value or `undefined` if the key doesn‚Äôt exist.\n\n#### **Example**\n\n```ts\nconst user = ctx.state.get(\"user\");\nconsole.log(user); // { id: 1, name: \"Alice\" }\n```\n\n---\n\n### **`delete(key: string): boolean`**\n\n#### **Description**\n\nRemoves a key-value pair from the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to delete.\n\n#### **Returns**\n\n- `true` if the key was removed, `false` if it didn‚Äôt exist.\n\n#### **Example**\n\n```ts\nctx.state.delete(\"user\");\nconsole.log(ctx.state.get(\"user\")); // undefined\n```\n\n---\n\n### **`has(key: string): boolean`**\n\n#### **Description**\n\nChecks if a key exists in the state.\n\n#### **Parameters**\n\n- `key: string` ‚Äì The key to check.\n\n#### **Returns**\n\n- `true` if the key exists, `false` otherwise.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.has(\"user\")); // true or false\n```\n\n---\n\n### **`keys(): string[]`**\n\n#### **Description**\n\nReturns an array of all stored keys.\n\n#### **Returns**\n\n- Array of key strings.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.keys()); // [\"user\"]\n```\n\n---\n\n### **`values(): any[]`**\n\n#### **Description**\n\nReturns an array of all stored values.\n\n#### **Returns**\n\n- Array of stored values (any type).\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.values()); // [{ id: 1, name: \"Alice\" }]\n```\n\n---\n\n### **`entries(): [string, any][]`**\n\n#### **Description**\n\nReturns an array of all key-value pairs.\n\n#### **Returns**\n\n- Array of tuples `[key, value]`.\n\n#### **Example**\n\n```ts\nconsole.log(ctx.state.entries()); // [[\"user\", { id: 1, name: \"Alice\" }]]\n```\n\n---\n\n### **`clear(): void`**\n\n#### **Description**\n\nRemoves all entries from the state.\n\n#### **Example**\n\n```ts\nctx.state.clear();\nconsole.log(ctx.state.keys()); // []\n```\n\n---\n\n## **Best Practices**\n\n1. **Consistent Key Naming**\n   Use descriptive, unique keys to avoid collisions:\n\n```ts\nctx.state.set(\"auth:user\", authenticatedUser);\n```\n\n2. **Cleanup**\n   Clear unnecessary state after use to manage memory:\n\n```ts\nctx.state.delete(\"temporaryData\");\n```\n\n3. **Type Safety**\n   Define an interface for type-safe state management:\n\n```ts\ninterface AppState {\n  user?: { id: number; name: string };\n  requestId?: string;\n}\n\nctx.state.set(\"user\", { id: 1, name: \"Alice\" } as AppState[\"user\"]);\n```\n\n4. **Middleware Integration**\n   Use `state` to share data across middleware:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.state.set(\"startTime\", Date.now());\n  await next();\n});\n\napp.get(\"/test\", (ctx) => {\n  const elapsed = Date.now() - ctx.state.get(\"startTime\");\n  return ctx.json({ elapsed });\n});\n```\n\n---\n"
    },
    {
      "id": 15,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "# **Context Propagation**\n\n## **Overview**\n\nContext propagation enables type-safe sharing of request-scoped data across middleware and route handlers. By leveraging TypeScript, it ensures strict type validation and supports hierarchical context extension, making it a robust solution for managing request-specific state.\n\n---\n\n## **Core Concepts**\n\n### **1. Type-Safe Context Definition**\n\nDefine the context shape using a TypeScript interface to enforce type safety.\n\n#### **Example**\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string; // Required request identifier\n}\n```\n\n---\n\n### **2. Router Initialization**\n\nInitialize the router with your custom context type.\n\n#### **Example**\n\n```ts\nimport { Router } from \"tezx\";\nconst app = new Router<CustomContext>();\n```\n\n---\n\n### **3. Middleware Implementation**\n\nEnrich the context with middleware, leveraging full type safety.\n\n#### **Example**\n\n```ts\n// Add authentication data\napp.use(async (ctx, next) => {\n  ctx.user = await authenticateRequest(ctx.request);\n  return next();\n});\n\n// Add request ID\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n### **4. Handler Access**\n\nAccess context properties in route handlers with type inference.\n\n#### **Example**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  return Response.json({\n    id: ctx.requestId, // Required: string\n    user: ctx.user?.email, // Optional: string | undefined\n  });\n});\n```\n\n---\n\n## **Advanced Features**\n\n### **Context Composition**\n\nCombine multiple context types for modular applications.\n\n#### **Example**\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface LoggingContext {\n  logger: Logger;\n  requestStart: number;\n}\n\ntype AppContext = AuthContext & LoggingContext;\n\nconst app = new Router<AppContext>();\n```\n\n---\n\n### **Validation Middleware**\n\nEnsure context integrity with runtime checks.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) {\n    throw new Error(\"Missing request ID\");\n  }\n  return next();\n});\n```\n\n---\n\n## **Error Handling**\n\n### **Type Safety Guards**\n\nTypeScript prevents invalid property access or type mismatches at compile time.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  // Error: Property 'newProp' does not exist on CustomContext\n  ctx.newProp = \"value\";\n  // Error: Type 'number' is not assignable to 'string'\n  ctx.requestId = 123;\n  return next();\n});\n```\n\n---\n\n### **Optional Properties**\n\nHandle optional context fields safely.\n\n#### **Example**\n\n```ts\napp.get(\"/public\", (ctx) => {\n  return ctx.user\n    ? Response.json(ctx.user)\n    : Response.json({ error: \"Unauthorized\" }, 401);\n});\n```\n\n---\n\n## **Best Practices**\n\n### **1. Initialization Order**\n\n- Set critical context properties early in the middleware chain.\n- Place validation middleware after initialization.\n\n#### **Example**\n\n```ts\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Request ID missing\");\n  return next();\n});\n```\n\n---\n\n### **2. Immutability**\n\nAvoid mutating context objects directly; create new objects instead.\n\n#### **Example**\n\n```ts\n// Avoid\nctx.user = { ...ctx.user, email: \"new@example.com\" };\n\n// Prefer\nconst updatedUser = { ...ctx.user, email: \"new@example.com\" };\nctx.user = updatedUser;\n```\n\n---\n\n### **3. Testing Patterns**\n\nMock context objects for unit tests.\n\n#### **Example**\n\n```ts\nconst testCtx: CustomContext = {\n  requestId: \"test-123\",\n  user: { id: 1, email: \"test@example.com\" },\n};\n\n// Test handler\nconst response = await handler(testCtx);\n```\n\n---\n\n## **Context Lifecycle**\n\n1. **Initialization**: Context is created for each request.\n2. **Middleware Processing**: Middleware enriches the context.\n3. **Handler Execution**: Handlers access and utilize the context.\n4. **Cleanup Hooks**: Context is discarded after response (optional cleanup via middleware).\n\n#### **Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Request\n  Server->>Middleware 1: Set requestId\n  Middleware 1->>Middleware 2: Set user\n  Middleware 2->>Handler: Process request\n  Handler->>Server: Response\n  Server->>Client: Response sent\n```\n\n---\n\n## **Benefits**\n\n- **Type Safety**: Prevents runtime errors with compile-time checks.\n- **Modularity**: Supports composition of context types for complex applications.\n- **Scalability**: Easily extend context for new features or middleware.\n\n---\n"
    },
    {
      "id": 16,
      "path": "api/context/cookies",
      "name": "Cookies",
      "folder": "API/Context",
      "content": "---\n# **Cookies**\n\n## **Overview**\n\nThe `ctx.cookies` API provides a convenient interface for managing HTTP cookies in your application. It supports setting, retrieving, and deleting cookies with customizable attributes, ensuring secure and efficient handling of client-side data.\n---\n\n## **Setting and Retrieving Cookies**\n\n### **Example: `PUT /data` Route**\n\n```ts\napp.put(\"/data\", async (ctx) => {\n  // Set a cookie\n  ctx.cookies.set(\"sessionToken\", \"abc123\", { httpOnly: true, secure: true });\n\n  // Get a cookie\n  const session = ctx.cookies.get(\"sessionToken\");\n\n  // Delete a cookie (optional)\n  // ctx.cookies.delete(\"sessionToken\");\n\n  return ctx.json({\n    success: true,\n    message: \"PUT request received\",\n    sessionToken: session,\n  });\n});\n```\n\n---\n\n## **Functions and Their Purpose**\n\n| **Function**                 | **Description**                                          |\n| ---------------------------- | -------------------------------------------------------- |\n| `get(name)`                  | Retrieves the value of a specific cookie or `undefined`. |\n| `all()`                      | Returns an object containing all cookies.                |\n| `set(name, value, options?)` | Sets a new cookie with optional attributes.              |\n| `delete(name, options?)`     | Deletes a cookie by setting its expiration to the past.  |\n\n### **Cookie Options**\n\n```ts\ninterface CookieOptions {\n  domain?: string; // e.g., \"example.com\"\n  path?: string; // e.g., \"/api\"\n  expires?: Date; // Expiration date\n  maxAge?: number; // Lifetime in seconds\n  secure?: boolean; // HTTPS-only\n  httpOnly?: boolean; // Blocks JavaScript access\n  sameSite?: \"Strict\" | \"Lax\" | \"None\"; // CSRF protection\n}\n```\n\n---\n\n## **Client-Side Example**\n\n### **Sending a Cookie with Fetch API**\n\n```javascript\nfetch(\"/data\", {\n  method: \"PUT\",\n  credentials: \"include\", // Required to send/receive cookies\n  headers: {\n    \"Content-Type\": \"application/json\",\n  },\n  body: JSON.stringify({ action: \"test\" }),\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(err));\n```\n\n- **Note**: The `credentials: \"include\"` option is mandatory for cookies to be sent or received in cross-origin requests.\n\n---\n\n## **Security Considerations**\n\n1. **Use `httpOnly` for Security**\n\n   - Prevents JavaScript access to cookies, mitigating XSS risks.\n   - Example: `{ httpOnly: true }`\n\n2. **Use `secure` for HTTPS**\n\n   - Ensures cookies are only sent over encrypted connections.\n   - Example: `{ secure: true }`\n\n3. **Use `sameSite` to Prevent CSRF**\n\n   - `Strict`: Blocks all cross-site requests.\n   - `Lax`: Allows safe cross-site navigation (e.g., top-level GET requests).\n   - `None`: Permits cross-origin cookies (requires `secure: true`).\n   - Example: `{ sameSite: \"Strict\" }`\n\n4. **Set Expiry for Session Management**\n\n   - Use `expires` or `maxAge` to control cookie lifespan.\n   - Example: `{ maxAge: 3600 }` (1 hour)\n\n5. **Restrict Paths**\n   - Limit cookie scope to specific paths for better isolation.\n   - Example: `{ path: \"/api\" }`\n\n---\n\n## **Example with Security Options**\n\n```ts\napp.put(\"/secure\", (ctx) => {\n  ctx.cookies.set(\"authToken\", \"xyz789\", {\n    httpOnly: true, // Prevent XSS\n    secure: true, // HTTPS only\n    sameSite: \"Strict\", // Prevent CSRF\n    maxAge: 24 * 60 * 60, // 1 day\n    path: \"/secure\", // Restrict scope\n  });\n\n  return ctx.json({ message: \"Cookie set securely\" });\n});\n```\n\n---\n\n## **Notes**\n\n- **Attributes**: Cookies support attributes like `httpOnly`, `secure`, `sameSite`, and `expires` for fine-grained control.\n- **Credentials**: Ensure `credentials: \"include\"` is set in client requests when cookies are involved.\n- **Deletion**: The `delete` method sets the cookie‚Äôs expiration to a past date, effectively removing it from the client.\n\n---\n\n## **Best Practices**\n\n1. **Minimize Cookie Usage**\n\n   - Use cookies only for essential data (e.g., session tokens) to reduce overhead.\n\n2. **Validate Retrieved Cookies**\n\n   - Check cookie values before use:\n\n```ts\nconst session = ctx.cookies.get(\"sessionToken\");\nif (!session) return ctx.status(401).json({ error: \"No session\" });\n```\n\n3. **Log Cookie Operations (Optional)**\n\n   - Add logging for debugging:\n\n```ts\nctx.cookies.set(\"key\", \"value\");\nlogger().info(\"Cookie set: key\");\n```\n\n---\n"
    },
    {
      "id": 17,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "# **Request Handling API**\n\nThis section details the APIs available for handling HTTP requests, including methods, URL parsing, query parameters, route parameters, headers, and body parsing.\n\n---\n\n## **1. Method**\n\n### **Description**\n\nRetrieves the HTTP request method (e.g., `GET`, `POST`, `PUT`, `DELETE`).\n\n### **Property**\n\n- `ctx.req.method: string` ‚Äì Read-only, uppercase string.\n\n### **Example**\n\n```ts\napp.post(\"/users\", (ctx) => {\n  if (ctx.req.method === \"POST\") {\n    // Handle user creation\n    return ctx.json({ message: \"User created\" });\n  }\n});\n```\n\n---\n\n## **2. URL Reference (`urlRef`)**\n\n### **Description**\n\nProvides deconstructed components of the request URL.\n\n### **Interface**\n\n```ts\ninterface UrlRef {\n  hash?: string; // e.g., \"#section\"\n  protocol?: string; // e.g., \"https:\"\n  origin?: string; // e.g., \"https://example.com:8080\"\n  username?: string; // Auth username\n  password?: string; // Auth password\n  hostname?: string; // e.g., \"example.com\"\n  port?: string; // e.g., \"8080\"\n  href?: string; // Full URL\n  query: Record<string, string>; // Parsed query params\n  pathname: string; // e.g., \"/api/v2/users\"\n}\n```\n\n### **Usage**\n\n```ts\napp.get(\"/profile\", (ctx) => {\n  const url = ctx.req.urlRef;\n  // For URL: \"https://api.com:8080/users?id=123#details\"\n  console.log(url.port); // \"8080\"\n  console.log(url.hostname); // \"api.com\"\n  console.log(url.query); // { id: \"123\" }\n  console.log(url.hash); // \"details\"\n});\n```\n\n### **Note**\n\n- Missing components return `undefined`.\n\n---\n\n## **3. Query Parameters (`query`)**\n\n### **Description**\n\nAccesses parsed query string parameters from the URL.\n\n### **Behavior**\n\n- Decodes URL-encoded values.\n- Last value wins for duplicate keys.\n- Returns an empty object (`{}`) if no query parameters exist.\n\n### **Example**\n\n```ts\n// URL: /search?q=term&page=2&filter=new\napp.get(\"/search\", (ctx) => {\n  const query = ctx.req.query;\n  // { q: \"term\", page: \"2\", filter: \"new\" }\n  const page = query.page || \"1\";\n  return ctx.json({ page });\n});\n```\n\n---\n\n## **4. Dynamic Parameters (`params`)**\n\n### **Description**\n\nCaptures route parameters from dynamic path patterns.\n\n### **Supported Patterns**\n\n| Pattern   | Example Route     | Request Path         | Result                    |\n| --------- | ----------------- | -------------------- | ------------------------- |\n| `:param`  | `/users/:id`      | `/users/42`          | `{ id: \"42\" }`            |\n| `:param?` | `/archive/:year?` | `/archive`           | `{ year: undefined }`     |\n| `*`       | `/files/*path`    | `/files/docs/readme` | `{ path: \"docs/readme\" }` |\n\n### **Example**\n\n```ts\napp.get(\"/users/:id/posts/:slug*\", (ctx) => {\n  const params = ctx.req.params;\n  // For /users/42/posts/announcements/2023\n  // { id: \"42\", slug: \"announcements/2023\" }\n  return ctx.json(params);\n});\n```\n\n### **Best Practice**\n\n```ts\napp.get(\"/products/:id\", (ctx) => {\n  const id = parseInt(ctx.req.params.id);\n  if (isNaN(id)) return ctx.status(400).text(\"Invalid ID\");\n  return ctx.json({ productId: id });\n});\n```\n\n---\n\n## **5. Headers (`headers`)**\n\n### **Description**\n\nAccesses and modifies request and response headers.\n\n### **Usage**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  // Get request header\n  const auth = ctx.req.headers.get(\"authorization\");\n\n  // Set response headers\n  ctx.headers\n    .set(\"Cache-Control\", \"max-age=3600\")\n    .set(\"X-Response-Time\", Date.now().toString());\n\n  if (auth) return ctx.text(\"Authorized\");\n  return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n### **Common Operations**\n\n- Check `Content-Type`:\n\n  ```ts\n  if (ctx.req.headers.get(\"content-type\") === \"application/json\") {\n    // Handle JSON request\n  }\n  ```\n\n---\n\n## **Request Flow Diagram**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: GET /users/42?details=true\n  Server->>Handler: Route matched\n  Handler->>Parse URL: Extract { id: \"42\" }\n  Handler->>Check Headers: Verify Content-Type\n  Handler->>Process Query: { details: \"true\" }\n  Handler->>Response: Send JSON\n  Server->>Client: 200 OK with headers\n```\n\n---\n\n## **6. Body Parser**\n\n### **Description**\n\nParses request bodies based on `Content-Type`.\n\n### **Supported Formats**\n\n| Method       | Content-Type                                                 | Features                   |\n| ------------ | ------------------------------------------------------------ | -------------------------- |\n| `text()`     | `text/plain`                                                 | Raw text parsing           |\n| `json()`     | `application/json`                                           | JSON parsing/validation    |\n| `formData()` | `multipart/form-data`<br>`application/x-www-form-urlencoded` | Form fields + file uploads |\n\n---\n\n### **1. Text Parsing**\n\n#### **Use Case**\n\nPlain text, XML, CSV, or custom formats.\n\n#### **Example**\n\n```ts\napp.post(\"/raw\", async (ctx) => {\n  try {\n    const text = await ctx.req.text();\n    return ctx.text(`Received: ${text}`);\n  } catch (error) {\n    return ctx.status(400).text(\"Invalid payload\");\n  }\n});\n```\n\n#### **Config**\n\n- `maxBodySize`: Limits payload size (configurable).\n\n---\n\n### **2. JSON Parsing**\n\n#### **Behavior**\n\nValidates and parses JSON payloads.\n\n#### **Example**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  try {\n    const data = await ctx.req.json();\n    return ctx.json({ received: data });\n  } catch (error) {\n    return ctx.status(422).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n### **3. Form Data Handling**\n\n#### **URL-Encoded Forms**\n\n```ts\napp.post(\"/login\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const username = form.username; // \"john_doe\"\n  return ctx.json({ username });\n});\n```\n\n#### **Multipart File Uploads**\n\n```ts\nconst config = {\n  maxFileSize: 50 * 1024 * 1024, // 50MB\n  allowedTypes: [\"image/jpeg\", \"application/pdf\"],\n};\n\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData(config);\n  const file = form.avatar as File;\n  const buffer = await file.arrayBuffer();\n  writeFileSync(`./uploads/${file.name}`, Buffer.from(buffer));\n  return ctx.json({ file: file.name });\n});\n```\n\n---\n\n### **4. File Upload Example**\n\n#### **Route Handler**\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  try {\n    const form = await ctx.req.formData();\n    const files = form.attachments;\n    const results = [];\n\n    if (Array.isArray(files)) {\n      for (const file of files) {\n        const sanitizedName = sanitizeFilename(file.name);\n        const path = `./uploads/${sanitizedName}`;\n        await writeFile(path, await file.arrayBuffer());\n        results.push({ name: sanitizedName, status: \"success\" });\n      }\n    }\n\n    return ctx.json({ results });\n  } catch (error) {\n    return ctx.status(500).json({ error: \"Upload failed\" });\n  }\n});\n```\n\n#### **Client-Side**\n\n```javascript\nconst form = new FormData();\nform.append(\"attachments\", fileInput.files[0]);\n\nfetch(\"/upload\", {\n  method: \"POST\",\n  body: form,\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Validation**: Always validate `params` and `query` values (e.g., type checking).\n- **Error Handling**: Use try-catch with body parsers to handle malformed data.\n- **Security**: Sanitize file names and restrict upload types/sizes.\n\n---\n"
    },
    {
      "id": 18,
      "path": "api/request/body-parser",
      "name": "Body Parser",
      "folder": "API/Request",
      "content": "# **Body Parser**\n\nThe body parser API in `ctx.req` provides methods to handle various request body formats, including text, JSON, URL-encoded forms, and multipart form-data (with file upload support).\n\n---\n\n## **Supported Parsing Methods**\n\n- **`text()`**: Parses raw text bodies (`text/plain`).\n- **`json()`**: Parses JSON bodies (`application/json`).\n- **`formData()`**: Parses URL-encoded (`application/x-www-form-urlencoded`) and multipart (`multipart/form-data`) data, including file uploads.\n\n---\n\n## **1. Parsing Text Requests**\n\n### **Description**\n\nThe `text()` method reads the request body as a raw string.\n\n### **Usage**\n\n```ts\napp.post(\"/text\", async (ctx) => {\n  const body = await ctx.req.text();\n  return ctx.text(`Received: ${body}`);\n});\n```\n\n---\n\n## **2. Parsing JSON Requests**\n\n### **Description**\n\nThe `json()` method parses `application/json` request bodies, validating the content type beforehand.\n\n### **Usage**\n\n```ts\napp.post(\"/json\", async (ctx) => {\n  try {\n    const body = await ctx.req.json();\n    return ctx.json({ received: body });\n  } catch (error) {\n    return ctx.status(400).json({ error: \"Invalid JSON\" });\n  }\n});\n```\n\n---\n\n## **3. Parsing Form Data (URL-Encoded & Multipart)**\n\n### **Description**\n\nThe `formData()` method dynamically parses URL-encoded and multipart form submissions, supporting both fields and file uploads.\n\n### **Usage**\n\n```ts\napp.post(\"/form\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  return ctx.json(formData);\n});\n```\n\n---\n\n## **Example: File Upload Route**\n\n### **Purpose**\n\nHandles file uploads via `multipart/form-data`, saves files to an `uploads` directory, and returns the file path.\n\n### **Code**\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer();\n    const filePath = join(process.cwd(), \"uploads\", file.name);\n    await writeFile(filePath, Buffer.from(buffer));\n    return ctx.json({ message: \"File uploaded successfully\", path: filePath });\n  } catch (error: any) {\n    return ctx\n      .status(500)\n      .json({ error: \"File save failed\", details: error.message });\n  }\n});\n```\n\n---\n\n## **Example: Send Buffer Response**\n\n### **Purpose**\n\nReturns the uploaded file buffer as a response with the correct `Content-Type`.\n\n### **Code**\n\n```ts\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File;\n\n  if (!file) {\n    return ctx.json({ error: \"No file found\" }, 400);\n  }\n\n  const buffer = await file.arrayBuffer();\n  return ctx.send(buffer, { \"Content-Type\": file.type });\n});\n```\n\n---\n\n## **Client-Side Example: Uploading a File**\n\n### **JavaScript**\n\n```javascript\nconst fileInput = document.querySelector('input[type=\"file\"]');\nconst formData = new FormData();\nformData.append(\"files\", fileInput.files[0]);\n\nfetch(\"/data\", {\n  method: \"POST\",\n  body: formData,\n})\n  .then((response) => response.json())\n  .then((data) => console.log(data))\n  .catch((error) => console.error(\"Error:\", error));\n```\n\n---\n\n## **Summary of Features**\n\n| Method       | Content-Type                                                 | Description                   |\n| ------------ | ------------------------------------------------------------ | ----------------------------- |\n| `text()`     | `text/plain`                                                 | Parses raw text body          |\n| `json()`     | `application/json`                                           | Parses JSON data              |\n| `formData()` | `application/x-www-form-urlencoded`<br>`multipart/form-data` | Parses forms and file uploads |\n\n---\n\n## **Generic Form Handling**\n\n### **Accessing Values**\n\n```ts\nconst form = await ctx.req.formData();\nconst username = form.username; // Field value\nconst avatar = form.avatar as File; // Uploaded file\n```\n\n---\n\n## **File Upload Deep Dive**\n\n### **Configuration Options**\n\n```ts\ninterface UploadConfig {\n  maxFileSize?: number; // Default: 10MB (in bytes)\n  allowedTypes?: string[]; // e.g., [\"image/jpeg\", \"application/pdf\"]\n  maxFiles?: number; // Maximum number of files (default: undefined)\n}\n```\n\n### **cURL Example**\n\n```bash\ncurl -X POST \\\n  -F \"document=@report.pdf\" \\\n  -F \"metadata={\\\"category\\\":\\\"finance\\\"};type=application/json\" \\\n  http://api.example.com/data\n```\n\n### **Browser Fetch with Progress**\n\n```javascript\nconst uploadFile = async (file) => {\n  const form = new FormData();\n  form.append(\"files\", file);\n\n  const response = await fetch(\"/data\", {\n    method: \"POST\",\n    body: form,\n    headers: { \"X-Upload-Token\": \"auth_token_here\" },\n  });\n\n  if (!response.ok) throw new Error(`Upload failed: ${await response.text()}`);\n  return response.json();\n};\n```\n\n---\n\n## **Performance Tips**\n\n1. **Stream Processing**\n   For large files, use streams to avoid buffering:\n\n```ts\nconst stream = file.stream();\nconst transformer = new TransformStream();\n// Process stream\n```\n\n2. **Memory Management**\n   Set `maxFileSize` to limit memory usage:\n\n```ts\nconst form = await ctx.req.formData({ maxFileSize: 10 * 1024 * 1024 }); // 10MB\n```\n\n3. **Async Processing**\n   Offload large file handling to background workers.\n\n4. **CORS Configuration**\n   Ensure proper headers for cross-origin uploads:\n\n```ts\nctx.headers.set(\"Access-Control-Allow-Origin\", \"https://trusted-domain.com\");\n```\n\n---\n\n## **API Reference: `ctx.req.formData(options)`**\n\n### **Parameters**\n\n| Option         | Type       | Default    | Description                                       |\n| -------------- | ---------- | ---------- | ------------------------------------------------- |\n| `sanitized`    | `boolean`  | `false`    | Sanitizes filenames (removes special characters). |\n| `allowedTypes` | `string[]` | `[]`       | Array of allowed MIME types.                      |\n| `maxSize`      | `number`   | `Infinity` | Maximum file size in kilobytes.                   |\n\n### **Return Value**\n\n```ts\n{\n  fields: Record<string, string>; // Non-file form fields\n  files: Array<{\n    name: string; // Original filename\n    sanitizedName?: string; // Sanitized filename (if enabled)\n    type: string; // MIME type\n    size: number; // Size in bytes\n    path?: string; // Saved file path (if processed)\n  }>;\n}\n```\n\n---\n\n## **Examples**\n\n### **Allow Only PNG & JPEG**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\"],\n});\n```\n\n### **Allow Images & Videos**\n\n```ts\nconst formData = await ctx.req.formData({\n  allowedTypes: [\"image/png\", \"image/jpeg\", \"image/webp\", \"video/mp4\"],\n  maxSize: 8000, // 8MB in KB\n});\n```\n\n---\n\n## **Error Handling**\n\n- **Invalid File Type**: Files not matching `allowedTypes` are ignored (no error thrown).\n- **Size Exceeded**: Uploads exceeding `maxSize` are rejected.\n- **No Files**: Returns `{ files: [] }`.\n\n---\n\n## **Best Practices**\n\n- Use `allowedTypes` for type safety.\n- Enable `sanitized` when saving files to disk.\n- Set a reasonable `maxSize` to prevent abuse.\n- Log skipped files for debugging:\n\n  ```ts\n  if (!formData.files.length) logger().warn(\"No valid files uploaded\");\n  ```\n\n---\n"
    },
    {
      "id": 19,
      "path": "api/response/response",
      "name": "Response",
      "folder": "API/Response",
      "content": "# **Response**\n\n---\n\n## **Overview**\n\nThe `Response` methods are part of a web framework's context (`ctx`) object, enabling developers to send HTTP responses in various formats. The `Callback` type supports flexible return values, including `string`, `Record<string, any>`, `Response`, and now supports setting `ctx.body` to any value, which is automatically converted to a `Response`. This documentation details each method, the new `ctx.body` feature, their parameters, return types, and usage examples.\n\n### **Type Definitions**\n\n```typescript\nexport type NextCallback = () => Promise<any>;\n\nexport type ctx<T extends Record<string, any> = {}> = Context<T> &\n  T & {\n    body?: any; // New property to hold response body\n  };\n\nexport type Callback<T extends Record<string, any> = {}> = (\n  ctx: ctx<T>,\n) => Promise<Response | void> | Response | string | Record<string, any> | void;\n```\n\n- **`NextCallback`**: A function returning a `Promise` for middleware chaining.\n- **`ctx<T>`**: The context object, extensible with custom properties via `T`, now including an optional `body` property of type `any`.\n- **`Callback<T>`**: A handler function that can return:\n  - `Promise<Response | void>`: Asynchronous response or no response.\n  - `Response`: A native HTTP response object.\n  - `string`: Plain text response.\n  - `Record<string, any>`: JSON-serializable object.\n  - `void`: No response (e.g., for middleware). If `ctx.body` is set, it is automatically wrapped as a `Response`.\n\n---\n\n## **Custom Response**\n\nFor fine-grained control, return a native `Response` object directly:\n\n```typescript\napp.get(\"/data\", async (ctx: ctx) => {\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: { \"Content-Type\": \"text/plain\" },\n  });\n});\n```\n\n---\n\n## **üîß Using `ctx.body`**\n\n### **üìñ Description**\n\n`ctx.body` allows you to assign a response value inside a handler without explicitly returning a `Response`.  \nIf a handler does **not** return a value, the framework automatically constructs a `Response` using `ctx.body`, with intelligent content type and status inference.\n\n---\n\n### **üß† Priority Logic:**\n\n1. If the handler **returns** a value, it takes precedence.\n2. If the handler returns `undefined`, then `ctx.body` (if set) will be used to generate the response.\n\n---\n\n### **‚öôÔ∏è Behavior**\n\n- **üß© Type Inference:**\n\n  - `string` ‚Üí `Content-Type: text/plain`\n  - `object` (e.g. `{}`) ‚Üí `Content-Type: application/json`\n  - Other types ‚Üí Converts to string using `.toString()` (fallback to `text/plain`)\n\n- **‚úÖ Default Status**: `200 OK` (can be overridden using `ctx.status`)\n\n- **üì¨ Custom Headers**: Set via `ctx.set(\"Header-Name\", \"value\")` or `ctx.header()` method if defined.\n\n---\n\n### **üìå Usage Examples**\n\n```ts\n// Respond with plain text\napp.get(\"/text\", (ctx) => {\n  ctx.body = \"Hello from ctx.body!\";\n  // Responds with text/plain and status 200\n});\n\n// Respond with JSON\napp.get(\"/json\", (ctx) => {\n  ctx.body = { message: \"Hello\", status: \"ok\" };\n  // Responds with application/json and status 200\n});\n\n// Example with custom status and headers\napp.get(\"/custom\", (ctx) => {\n  ctx.status = 201;\n  ctx.set(\"X-Custom-Header\", \"Tezx\");\n  ctx.body = { created: true };\n});\n```\n\n---\n\n## **Response Methods**\n\n### **`json`**\n\n#### **Description**\n\nSerializes and sends a JSON response.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Data to serialize as JSON.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/json`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  return ctx.json({ message: \"Success\" }, 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/json\", (ctx: ctx) => {\n  ctx.body = { message: \"Success\" };\n});\n```\n\n---\n\n### **`html`**\n\n#### **Description**\n\nSends an HTML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì HTML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/html`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  return ctx.html(\"<h1>Hello</h1>\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/html\", (ctx: ctx) => {\n  ctx.header(\"content-type\", \"text/html\");\n  ctx.body = \"<h1>Hello</h1>\"; // Served as text/plain unless ctx.html() is used\n});\n```\n\n---\n\n### **`text`**\n\n#### **Description**\n\nSends a plain text response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì Text content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: text/plain`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  return ctx.text(\"Hello, World!\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/text\", (ctx: ctx) => {\n  ctx.body = \"Hello, World!\";\n});\n```\n\n---\n\n### **`xml`**\n\n#### **Description**\n\nSends an XML response.\n\n#### **Parameters**\n\n- `data: string` ‚Äì XML content.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Content-Type: application/xml`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  return ctx.xml(\"<note><msg>Hello</msg></note>\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/xml\", (ctx: ctx) => {\n  ctx.body = \"<note><msg>Hello</msg></note>\"; // Served as text/plain unless ctx.xml() is used\n});\n```\n\n---\n\n### **`send`**\n\n#### **Description**\n\nSends a response with automatic content-type inference.\n\n#### **Parameters**\n\n- `body: any` ‚Äì Response body (e.g., `string`, `object`).\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `200`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with inferred `Content-Type`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  return ctx.send(\"Custom Content\", 200);\n});\n```\n\n#### **With `ctx.body`**\n\n```typescript\napp.get(\"/send\", (ctx: ctx) => {\n  ctx.body = \"Custom Content\";\n});\n```\n\n---\n\n### **`redirect`**\n\n#### **Description**\n\nRedirects the client to a specified URL.\n\n#### **Parameters**\n\n- `url: string` ‚Äì Target URL.\n- `status?: number` (Optional) ‚Äì HTTP status code (default: `302`).\n- `headers?: ResponseHeaders` (Optional) ‚Äì Custom response headers.\n\n#### **Returns**\n\n`Response` with `Location` header.\n\n#### **Usage**\n\n```typescript\napp.get(\"/redirect\", (ctx: ctx) => {\n  return ctx.redirect(\"https://example.com\");\n});\n```\n\n---\n\n### **`download`**\n\n#### **Description**\n\nTriggers a file download.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName: string` ‚Äì Name for the downloaded file.\n\n#### **Returns**\n\n`Promise<Response>` with `Content-Disposition: attachment`.\n\n#### **Usage**\n\n```typescript\napp.get(\"/download\", async (ctx: ctx) => {\n  return ctx.download(\"/path/to/file.pdf\", \"document.pdf\");\n});\n```\n\n---\n\n### **`sendFile`**\n\n#### **Description**\n\nServes a static file.\n\n#### **Parameters**\n\n- `filePath: string` ‚Äì Path to the file.\n- `fileName?: string` (Optional) ‚Äì Name for the file in the response.\n\n#### **Returns**\n\n`Promise<Response>` with file stream.\n\n#### **Usage**\n\n```typescript\napp.get(\"/file\", async (ctx: ctx) => {\n  return ctx.sendFile(\"/path/to/image.jpg\");\n});\n```\n\n---\n\n## **Key Features**\n\n- **Flexible Returns**: The `Callback` supports:\n  - `string`: Sent as `text/plain`.\n  - `Record<string, any>`: Sent as `application/json`.\n  - `Response`: Custom response.\n  - `Promise`: Async handling.\n  - `void`: No explicit return; uses `ctx.body` if set.\n- **`ctx.body`**: Automatically wrapped as a `Response` with inferred content-type if no explicit return is provided.\n- **Type Safety**: Extend `ctx<T>` for custom properties (e.g., `ctx<{ userId: string }>`).\n- **Cross-Runtime**: Compatible with Node.js, Bun, and Deno.\n\n---\n\n## **Examples**\n\n### **Using `ctx.body` with String**\n\n```typescript\napp.get(\"/greet\", (ctx: ctx) => {\n  ctx.body = \"Hello, World!\";\n});\n```\n\n### **Using `ctx.body` with Object**\n\n```typescript\napp.get(\"/user\", (ctx: ctx) => {\n  ctx.body = { id: 1, name: \"Alice\" };\n});\n```\n\n### **Direct Returns**\n\n```typescript\napp.get(\"/direct\", (ctx: ctx) => {\n  return \"Direct Hello\"; // text/plain\n});\n\napp.get(\"/direct-obj\", (ctx: ctx) => {\n  return { data: \"Direct Object\" }; // application/json\n});\n```\n\n### **Mixed Usage**\n\n```typescript\napp.get(\"/mixed\", (ctx: ctx) => {\n  if (someCondition) {\n    return ctx.json({ error: \"Not found\" }, 404);\n  }\n  ctx.body = \"All good\";\n});\n```\n\n---\n\n## **Best Practices**\n\n- **Use `ctx.body`**: For simple responses without explicit formatting.\n- **Explicit Methods**: Use `ctx.json()`, `ctx.html()`, etc., for specific content-types.\n- **Status Codes**: Set explicitly when needed (e.g., `ctx.status = 201` with `ctx.body`).\n- **Async Safety**: `await` file methods like `download` and `sendFile`.\n- **Type Extensions**: Use `ctx<T>` for type-safe custom properties.\n\n---\n"
    },
    {
      "id": 20,
      "path": "api/headers-api/request-headers",
      "name": "Request Headers",
      "folder": "API/Headers API",
      "content": "\n# Request Headers (`ctx.req.headers`)\n\n## Overview\n\nThe `ctx.req.headers` property provides a read-only interface for accessing HTTP request headers sent by the client. Exposed as a getter, it returns an object with methods to query and iterate over header data, ensuring immutability and predictable behavior. This API is designed for inspecting request metadata such as content types, authentication tokens, and client preferences.\n\n### Key Features\n\n- **Read-Only Access**: Provides methods to retrieve and inspect headers without modification.\n- **Case-Insensitive Keys**: Normalizes header names to lowercase for consistent handling.\n- **Multi-Value Support**: Handles headers with multiple values (e.g., `Accept`).\n- **Iterator Support**: Offers flexible iteration over keys, values, and entries.\n\n### Context\n\n- **Location**: Available as `ctx.req.headers` within a `Context` object.\n- **Purpose**: Represents headers received in the HTTP request from the client.\n\n---\n\n## Implementation Context\n\nThe `ctx.req.headers` is implemented as a getter that returns an object with the following methods, backed by an internal `#headers` store (assumed to be a `Map`-like structure):\n\n```typescript\nget: function get(key: string): string | undefined {\n  return requestHeaders.get(key.toLowerCase());\n}\ngetAll: function getAll(key: string) {\n  return requestHeaders.get(key.toLowerCase()) || [];\n},\nhas: function has(key: string): boolean {\n  return requestHeaders.has(key.toLowerCase());\n}\nentries: function entries(): IterableIterator<[string, string[]]> {\n  return requestHeaders.entries();\n}\nkeys: function keys(): IterableIterator<string> {\n  return requestHeaders.keys();\n}\nvalues: function values(): IterableIterator<string[]> {\n  return requestHeaders.values();\n}\nforEach: function forEach(callback: (value: string[], key: string) => void): void {\n  return requestHeaders.forEach(callback);\n}\ntoObject: function toObject(): Record<string, string | string[]> {\n  return requestHeaders.toObject();\n}\n```\n\n---\n\n## Core Methods\n\n### 1. `get(key: string): string | undefined`\n\n#### Description\n\nRetrieves the first value of a specified request header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `string`: First value if the header exists.\n- `undefined`: If the header is not present.\n\n#### Example\n\n```typescript\nconst contentType = ctx.req.headers.get(\"content-type\");\n// Returns \"application/json\" or undefined\n```\n\n---\n\n### 2. `getAll(key: string): string[]`\n\n#### Description\n\nRetrieves all values for a specified request header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `string[]`: Array of all values; empty array if header is not present.\n\n#### Example\n\n```typescript\nconst accepts = ctx.req.headers.getAll(\"accept\");\n// Returns [\"application/json\", \"text/html\"] or []\n```\n\n---\n\n### 3. `has(key: string): boolean`\n\n#### Description\n\nChecks if a header exists in the request headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive; converted to lowercase).\n\n#### Returns\n\n- `boolean`: `true` if the header exists, `false` otherwise.\n\n#### Example\n\n```typescript\nif (ctx.req.headers.has(\"authorization\")) {\n  console.log(\"Authorization header present\");\n}\n```\n\n---\n\n## Iteration Methods\n\n### 4. `entries(): IterableIterator<[string, string[]]>`\n\n#### Description\n\nReturns an iterator of request header entries as `[key, values]` pairs.\n\n#### Returns\n\n- `IterableIterator<[string, string[]]>`: Iterator of header name and value arrays.\n\n#### Example\n\n```typescript\nfor (const [key, values] of ctx.req.headers.entries()) {\n  console.log(`${key}: ${values.join(\", \")}`);\n}\n// Output: \"accept: application/json, text/html\"\n```\n\n---\n\n### 5. `keys(): IterableIterator<string>`\n\n#### Description\n\nReturns an iterator of request header names.\n\n#### Returns\n\n- `IterableIterator<string>`: Iterator of header keys.\n\n#### Example\n\n```typescript\nfor (const key of ctx.req.headers.keys()) {\n  console.log(`Header: ${key}`);\n}\n// Output: \"content-type\", \"accept\", etc.\n```\n\n---\n\n### 6. `values(): IterableIterator<string[]>`\n\n#### Description\n\nReturns an iterator of request header value arrays.\n\n#### Returns\n\n- `IterableIterator<string[]>`: Iterator of header values.\n\n#### Example\n\n```typescript\nfor (const values of ctx.req.headers.values()) {\n  console.log(`Values: ${values.join(\", \")}`);\n}\n// Output: \"application/json\", \"en-US, es-ES\", etc.\n```\n\n---\n\n## Utility Methods\n\n### 7. `forEach(callback: (values: string[], key: string) => void): void`\n\n#### Description\n\nIterates over all request headers, invoking a callback for each.\n\n#### Parameters\n\n- `callback`: Function receiving `values` (array) and `key` (string).\n\n#### Example\n\n```typescript\nctx.req.headers.forEach((values, key) => {\n  console.log(`${key}: ${values.length} value(s)`);\n});\n// Output: \"accept: 2 value(s)\"\n```\n\n---\n\n### 8. `toObject(): Record<string, string | string[]>`\n\n#### Description\n\nConverts request headers to a plain JavaScript object.\n\n#### Returns\n\n- `Record<string, string | string[]>`: Headers as key-value pairs; single values as strings, multiple as arrays.\n\n#### Example\n\n```typescript\nconst headersObj = ctx.req.headers.toObject();\n// Returns: { \"content-type\": \"application/json\", \"accept\": [\"application/json\", \"text/html\"] }\n```\n\n---\n\n## Usage Patterns\n\n### Authentication Validation\n\n```typescript\napp.use(async (ctx, next) => {\n  if (!ctx.req.headers.has(\"authorization\")) {\n    return ctx.json({ error: \"Missing Authorization header\" }, 401);\n  }\n  await next();\n});\n```\n\n### Content Negotiation\n\n```typescript\napp.get(\"/data\", (ctx) => {\n  const accepts = ctx.req.headers.getAll(\"accept\");\n  if (accepts.includes(\"application/json\")) {\n    return ctx.json({ data: \"JSON response\" });\n  }\n  return ctx.text(\"Text response\");\n});\n```\n\n### Header Logging\n\n```typescript\napp.use(async (ctx, next) => {\n  const headers = ctx.req.headers.toObject();\n  console.log(\"Incoming Headers:\", headers);\n  await next();\n});\n```\n\n---\n\n## Request Header Operations Cheat Sheet\n\n| Method       | Description            | Mutable | Returns                        |\n|--------------|------------------------|---------|--------------------------------|\n| `get()`      | Get first value        | ‚ùå      | `string \\| undefined`          |\n| `getAll()`   | Get all values         | ‚ùå      | `string[]`                     |\n| `has()`      | Check existence        | ‚ùå      | `boolean`                      |\n| `entries()`  | Iterate [key, values]  | ‚ùå      | `IterableIterator<[string, string[]]>` |\n| `keys()`     | Iterate header names   | ‚ùå      | `IterableIterator<string>`     |\n| `values()`   | Iterate values         | ‚ùå      | `IterableIterator<string[]>`   |\n| `forEach()`  | Iterate with callback  | ‚ùå      | `void`                         |\n| `toObject()` | Convert to object      | ‚ùå      | `Record<string, string \\| string[]>` |\n\n---\n\n## Best Practices\n\n- **Inspection**: Use `get()` for single-value headers (e.g., `Content-Type`) and `getAll()` for multi-value headers (e.g., `Accept`).\n- **Validation**: Check header presence with `has()` before processing critical data.\n- **Debugging**: Use `toObject()` for a comprehensive snapshot of request headers.\n- **Performance**: Prefer `get()` over `getAll()` when only the first value is needed.\n- **Consistency**: Account for case-insensitivity when querying headers.\n\n---\n"
    },
    {
      "id": 21,
      "path": "api/headers-api/response-headers",
      "name": "Response Headers",
      "folder": "API/Headers API",
      "content": "\n# Response Headers (`ctx.headers`)\n\n## Overview\n\nThe `ctx.headers` object provides a powerful interface for managing HTTP response headers in a web application. It allows developers to set, modify, and inspect headers that will be sent back to the client, enabling fine-grained control over response metadata such as caching, security policies, and content negotiation. This API is designed for mutability, supporting both single and multi-value headers.\n\n### Key Features\n\n- **Case-Insensitive Keys**: Header names are normalized for consistent handling.\n- **Multi-Value Support**: Accommodates headers with multiple values (e.g., `Vary`).\n- **Chaining**: Many methods return the headers object for fluent usage.\n- **Type-Safe Operations**: Ensures predictable behavior for setting and retrieving values.\n\n### Context\n\n- **Location**: Available as `ctx.headers` within a `Context` object.\n- **Purpose**: Represents headers to be sent in the HTTP response to the client.\n\n---\n\n## Core Methods\n\n### 1. `add(headers: [string, string][] | Record<string, string>)`\n\n#### Description\n\nAdds multiple headers to the response without overwriting existing ones.\n\n#### Parameters\n\n- `headers`: Either an array of `[key, value]` tuples or a key-value object.\n\n#### Behavior\n\n- Appends new headers while preserving existing ones.\n- Merges values for duplicate headers into an array.\n\n#### Example\n\n```typescript\nctx.headers.add([\n  [\"Content-Type\", \"application/json\"],\n  [\"Cache-Control\", \"no-cache\"],\n]);\n\n// Using object syntax\nctx.headers.add({\n  \"X-Response-Time\": \"50ms\",\n  \"Server\": \"CustomServer\",\n});\n```\n\n---\n\n### 2. `set(key: string, value: string | string[])`\n\n#### Description\n\nSets or overwrites a response header with a single value or array of values.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n- `value`: Single string or array of strings.\n\n#### Behavior\n\n- Replaces all existing values for the specified header.\n\n#### Example\n\n```typescript\n// Single value\nctx.headers.set(\"Content-Type\", \"text/html\");\n\n// Multiple values\nctx.headers.set(\"Link\", [\n  \"</styles.css>; rel=preload\",\n  \"</script.js>; rel=preload\",\n]);\n```\n\n---\n\n### 3. `get(key: string): string | undefined`\n\n#### Description\n\nRetrieves the first value of a specified response header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `string`: First value if the header exists.\n- `undefined`: If the header is not present.\n\n#### Example\n\n```typescript\nconst cacheControl = ctx.headers.get(\"cache-control\");\n// Returns \"no-cache\" or undefined\n```\n\n---\n\n### 4. `getAll(key: string): string[]`\n\n#### Description\n\nRetrieves all values for a specified response header.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `string[]`: Array of all values; empty array if header is not present.\n\n#### Example\n\n```typescript\nconst links = ctx.headers.getAll(\"link\");\n// Returns [\"</styles.css>; rel=preload\", \"</script.js>; rel=preload\"] or []\n```\n\n---\n\n### 5. `has(key: string): boolean`\n\n#### Description\n\nChecks if a header exists in the response headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `boolean`: `true` if the header exists, `false` otherwise.\n\n#### Example\n\n```typescript\nif (ctx.headers.has(\"x-ratelimit-limit\")) {\n  console.log(\"Rate limit header set\");\n}\n```\n\n---\n\n### 6. `delete(key: string): boolean`\n\n#### Description\n\nRemoves a header from the response headers.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n\n#### Returns\n\n- `boolean`: `true` if the header was removed, `false` if it didn‚Äôt exist.\n\n#### Example\n\n```typescript\nconst removed = ctx.headers.delete(\"x-powered-by\");\n// Returns true if header was present\n```\n\n---\n\n### 7. `append(key: string, value: string)`\n\n#### Description\n\nAppends a value to an existing response header or creates a new one if it doesn‚Äôt exist.\n\n#### Parameters\n\n- `key`: Header name (case-insensitive).\n- `value`: Value to append.\n\n#### Behavior\n\n- Adds the value to the list of existing values for the header.\n\n#### Example\n\n```typescript\nctx.headers.append(\"Vary\", \"User-Agent\");\nctx.headers.append(\"Vary\", \"Accept-Encoding\");\n// Vary: User-Agent, Accept-Encoding\n```\n\n---\n\n## Iteration Methods\n\n### 8. `entries(): Iterable<[string, string[]]>`\n\n#### Description\n\nReturns an iterator of response header entries as `[key, values]` pairs.\n\n#### Returns\n\n- `Iterable<[string, string[]]>`: Iterator of header name and value arrays.\n\n#### Example\n\n```typescript\nfor (const [key, values] of ctx.headers.entries()) {\n  console.log(`${key}: ${values.join(\", \")}`);\n}\n// Output: \"vary: User-Agent, Accept-Encoding\"\n```\n\n---\n\n### 9. `keys(): Iterable<string>`\n\n#### Description\n\nReturns an iterator of response header names.\n\n#### Returns\n\n- `Iterable<string>`: Iterator of header keys.\n\n#### Example\n\n```typescript\nfor (const key of ctx.headers.keys()) {\n  console.log(`Header: ${key}`);\n}\n// Output: \"content-type\", \"vary\", etc.\n```\n\n---\n\n### 10. `values(): Iterable<string[]>`\n\n#### Description\n\nReturns an iterator of response header value arrays.\n\n#### Returns\n\n- `Iterable<string[]>`: Iterator of header values.\n\n#### Example\n\n```typescript\nfor (const values of ctx.headers.values()) {\n  console.log(`Values: ${values.join(\", \")}`);\n}\n// Output: \"application/json\", \"User-Agent, Accept-Encoding\", etc.\n```\n\n---\n\n## Utility Methods\n\n### 11. `forEach(callback: (values: string[], key: string) => void)`\n\n#### Description\n\nIterates over all response headers, invoking a callback for each.\n\n#### Parameters\n\n- `callback`: Function receiving `values` (array) and `key` (string).\n\n#### Example\n\n```typescript\nctx.headers.forEach((values, key) => {\n  console.log(`${key}: ${values.length} value(s)`);\n});\n// Output: \"vary: 2 value(s)\"\n```\n\n---\n\n### 12. `to```typescript\n\ntoObject(): Record<string, string | string[]>\n\n```\n\n#### Description\nConverts response headers to a plain JavaScript object.\n\n#### Returns\n- `Record<string, string | string[]>`: Headers as key-value pairs; single values as strings, multiple as arrays.\n\n#### Example\n```typescript\nconst headersObj = ctx.headers.toObject();\n// Returns: { \"content-type\": \"application/json\", \"vary\": [\"User-Agent\", \"Accept-Encoding\"] }\n```\n\n---\n\n## Usage Patterns\n\n### Security Headers\n\n```typescript\napp.use(async (ctx, next) => {\n  ctx.headers\n    .set(\"X-Content-Type-Options\", \"nosniff\")\n    .set(\"Content-Security-Policy\", \"default-src 'self'\")\n    .delete(\"Server\");\n  await next();\n});\n```\n\n### Rate Limiting Headers\n\n```typescript\napp.get(\"/rate-limited\", (ctx) => {\n  ctx.headers\n    .set(\"X-RateLimit-Limit\", \"100\")\n    .set(\"X-RateLimit-Remaining\", \"95\")\n    .set(\"X-RateLimit-Reset\", \"1698765432\");\n  return ctx.json({ message: \"OK\" });\n});\n```\n\n### Caching Control\n\n```typescript\napp.get(\"/static\", (ctx) => {\n  ctx.headers.set(\"Cache-Control\", \"public, max-age=3600\");\n  return ctx.sendFile(\"static/file.txt\");\n});\n```\n\n---\n\n## Response Header Operations Cheat Sheet\n\n| Method       | Description            | Mutable | Returns               |\n|--------------|------------------------|---------|-----------------------|\n| `add()`      | Add multiple headers   | ‚úÖ      | `void`                |\n| `set()`      | Replace header values  | ‚úÖ      | `void`                |\n| `get()`      | Get first value        | ‚ùå      | `string \\| undefined` |\n| `getAll()`   | Get all values         | ‚ùå      | `string[]`            |\n| `has()`      | Check existence        | ‚ùå      | `boolean`             |\n| `delete()`   | Remove header          | ‚úÖ      | `boolean`             |\n| `append()`   | Append value           | ‚úÖ      | `void`                |\n| `entries()`  | Iterate [key, values]  | ‚ùå      | `Iterable<[string, string[]]>` |\n| `keys()`     | Iterate header names   | ‚ùå      | `Iterable<string>`    |\n| `values()`   | Iterate values         | ‚ùå      | `Iterable<string[]>`  |\n| `forEach()`  | Iterate with callback  | ‚ùå      | `void`                |\n| `toObject()` | Convert to object      | ‚ùå      | `Record<string, string \\| string[]>` |\n\n---\n\n## Best Practices\n\n- **Security**: Set headers like `X-Content-Type-Options` and `Content-Security-Policy` early in the middleware chain.\n- **Caching**: Use `Cache-Control` and `ETag` for efficient client-side caching.\n- **Consistency**: Use `set()` for single-value headers and `append()` for multi-value headers like `Vary`.\n- **Debugging**: Leverage `toObject()` for logging or inspecting response headers.\n- **Standards**: Follow HTTP header conventions (e.g., `X-` prefix for custom headers).\n\n---\n\n## Notes\n\n- **Mutability**: Methods like `set`, `add`, `append`, and `delete` modify the response headers in place.\n- **Case Handling**: Header keys are case-insensitive per HTTP standards.\n- **Framework Integration**: Assumes `ctx.headers` is part of a broader `Context` object tied to the response lifecycle.\n\n---\n"
    },
    {
      "id": 22,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "## **Overview**\n\nThe `static()` method enables efficient serving of static files‚Äîsuch as HTML, CSS, JavaScript, images, videos, and fonts‚Äîfrom a designated directory. It provides flexibility to serve files either from the root URL (`/`) or a custom base route (e.g., `/static`), with support for advanced configuration options like caching and custom headers.\n\n---\n\n## **Usage**\n\n### **1. Serve Files from the Root (`/`)**\n\n```ts\napp.static(\"./public\");\n```\n\n- **Behavior**: Serves all files from the `\"public\"` directory directly under the root URL.\n- **Example**: A file at `public/style.css` becomes accessible at `http://yourdomain.com/style.css`.\n\n### **2. Serve Files from a Custom Route**\n\n```ts\napp.static(\"/static\", \"./assets\");\n```\n\n- **Behavior**: Serves files from the `\"assets\"` directory under the `/static` route.\n- **Example**: A file at `assets/logo.png` is available at `http://yourdomain.com/static/logo.png`.\n\n### **3. Serve Files with Custom Options**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=3600\",\n});\n```\n\n- **Behavior**: Applies HTTP caching with a `Cache-Control` header set to cache files for 1 hour (3600 seconds).\n\n---\n\n## **Method Signature**\n\n```ts\nstatic(route: string, folder: string, options?: StaticServeOption): this;\nstatic(folder: string, options?: StaticServeOption): this;\n```\n\n---\n\n## **Parameters**\n\n| Parameter              | Type                | Description                                                                                     |\n| ---------------------- | ------------------- | ----------------------------------------------------------------------------------------------- |\n| `route` _(optional)_   | `string`            | The base URL path for serving static files (e.g., `/static`). Defaults to `/` if not specified. |\n| `folder`               | `string`            | The filesystem directory containing static files (e.g., `\"./public\"`).                          |\n| `options` _(optional)_ | `StaticServeOption` | Configuration object for customizing static file serving behavior (see options below).          |\n\n---\n\n## **Options (`StaticServeOption`)**\n\nThe optional `options` parameter provides fine-grained control over how static files are served.\n\n| Option         | Type             | Default      | Description                                                                                    |\n| -------------- | ---------------- | ------------ | ---------------------------------------------------------------------------------------------- |\n| `cacheControl` | `string`         | `\"no-cache\"` | Defines the `Cache-Control` HTTP header. Example: `\"public, max-age=86400\"` for 1-day caching. |\n| `header`       | `HeaderResponse` | `undefined`  | A key-value record of additional HTTP headers to include in responses.                         |\n\n---\n\n## **Examples**\n\n### **1. Enable Caching for Performance**\n\n```ts\napp.static(\"./public\", {\n  cacheControl: \"public, max-age=86400\", // Cache files for 1 day\n});\n```\n\n- **Result**: Static files are cached by clients and intermediaries for 24 hours, improving load times.\n\n### **2. Method Chaining**\n\n```ts\napp.static(\"./public\").use((ctx) => {\n  console.log(\"Middleware executed\");\n});\n```\n\n- **Result**: The `static()` method returns the app instance, enabling seamless chaining with other middleware or routes.\n\n### **3. Overriding Static Paths**\n\n```ts\napp.static(\"/static\", \"./assets\");\n\napp.get(\"/static/image.png\", (ctx) => {\n  return ctx.text(\"Custom response overriding static file\");\n});\n```\n\n- **Result**: The custom `GET` handler takes precedence over the static file at `/static/image.png`.\n\n---\n\n## **Return Value**\n\n- **Type**: `this`\n- **Description**: Returns the current application instance, supporting method chaining for fluent configuration.\n\n---\n\n## **Key Features**\n\n- **Automatic MIME Type Detection**: Sets appropriate `Content-Type` headers based on file extensions.\n- **Security**: Prevents directory traversal attacks through secure path resolution.\n- **Cross-Platform Compatibility**: Works seamlessly with Node.js, Deno, and Bun with minimal adjustments.\n- **Flexible Paths**: Supports both absolute and relative directory paths.\n\n---\n\n## **Best Practices**\n\n- **Caching**: Use `cacheControl` to improve performance for infrequently updated assets (e.g., `\"public, max-age=31536000\"` for 1-year caching).\n- **Route Specificity**: Define custom routes (e.g., `/static`) to avoid conflicts with dynamic routes.\n- **Security**: Regularly audit served directories to prevent unintended file exposure.\n\n---\n\n## **Additional Resources**\n\n- [MDN: Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) ‚Äì Learn more about HTTP caching strategies.\n\n---\n"
    },
    {
      "id": 23,
      "path": "middlewares/cors-middleware",
      "name": "CORS Middleware",
      "folder": "Middlewares",
      "content": "# **CORS Middleware**\n\n## **Overview**\n\nThe `cors` middleware enables Cross-Origin Resource Sharing (CORS) by managing response headers. It supports dynamic origin validation, preflight request handling (`OPTIONS`), and fine-grained control over allowed methods, headers, and credentials.\n\n---\n\n## **Installation & Basic Usage**\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\n// Allow all origins (basic setup)\napp.use(cors());\n\n// Custom configuration\napp.use(\n  cors({\n    origin: [\"https://trusted.com\", /\\.example\\.com$/],\n    methods: [\"GET\", \"POST\"],\n    credentials: true,\n  }),\n);\n```\n\n---\n\n## **Configuration Options (`CorsOptions`)**\n\n| Property         | Type       | Default                             | Description                                                                                              |\n| ---------------- | ---------- | ----------------------------------- | -------------------------------------------------------------------------------------------------------- |\n| `origin`         | `string    | RegExp                              | (string or RegExp)[] or ((origin: string) => boolean)`or`\\*` (all origins) or Specifies allowed origins. |\n| `methods`        | `string[]` | `[\"GET\", \"POST\", \"PUT\", \"DELETE\"]`  | Defines allowed HTTP methods.                                                                            |\n| `allowedHeaders` | `string[]` | `[\"Content-Type\", \"Authorization\"]` | Headers clients may include in requests.                                                                 |\n| `exposedHeaders` | `string[]` | `undefined`                         | Headers exposed to clients in responses.                                                                 |\n| `credentials`    | `boolean`  | `false`                             | Enables cookies/credentials in requests.                                                                 |\n| `maxAge`         | `number`   | `undefined`                         | Preflight cache duration (seconds).                                                                      |\n\n---\n\n## **Detailed Behavior**\n\n### **1. Origin Handling**\n\n#### **Static Origin**\n\n```ts\ncors({ origin: \"https://strict-domain.com\" });\n```\n\n- **Result**: Only requests from `https://strict-domain.com` are allowed.\n\n#### **Multiple Origins**\n\n```ts\ncors({\n  origin: [\n    \"https://app.com\",\n    \"http://localhost:3000\",\n    /\\.staging\\.com$/, // Regex pattern\n  ],\n});\n```\n\n- **Result**: Allows specified domains and subdomains matching the regex.\n\n#### **Dynamic Validation**\n\n```ts\ncors({\n  origin: (requestOrigin) => validateOriginAgainstDB(requestOrigin),\n});\n```\n\n- **Result**: Custom logic determines origin validity (supports async via context).\n\n---\n\n### **2. Preflight Handling**\n\nHandles `OPTIONS` requests automatically:\n\n**Request Example:**\n\n```bash\nOPTIONS /resource HTTP/1.1\nOrigin: https://client.com\nAccess-Control-Request-Method: DELETE\nAccess-Control-Request-Headers: X-Custom-Header\n```\n\n**Response Example:**\n\n```bash\nHTTP/1.1 204 No Content\nAccess-Control-Allow-Origin: https://client.com\nAccess-Control-Allow-Methods: GET, POST, PUT, DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\nAccess-Control-Max-Age: 86400\n```\n\n---\n\n### **3. Credential Handling**\n\n```ts\ncors({ credentials: true });\n```\n\n- **Result**: Adds `Access-Control-Allow-Credentials: true` to responses.\n\n---\n\n## **Response Headers**\n\nThe middleware sets these headers based on configuration:\n\n| Header                             | Example Value                 |\n| ---------------------------------- | ----------------------------- |\n| `Access-Control-Allow-Origin`      | `https://trusted.com`         |\n| `Access-Control-Allow-Methods`     | `GET, POST`                   |\n| `Access-Control-Allow-Headers`     | `Content-Type, Authorization` |\n| `Access-Control-Expose-Headers`    | `X-Custom-Header`             |\n| `Access-Control-Max-Age`           | `3600`                        |\n| `Access-Control-Allow-Credentials` | `true`                        |\n\n---\n\n## **Advanced Examples**\n\n### **1. Route-Specific CORS**\n\n```ts\napp.get(\n  \"/api/data\",\n  cors({\n    origin: \"https://specific-client.com\",\n    methods: [\"GET\"],\n  }),\n  dataHandler,\n);\n```\n\n- **Result**: CORS applies only to the `/api/data` route.\n\n### **2. With Authentication**\n\n```ts\napp.use(\n  cors({\n    origin: \"https://app.com\",\n    allowedHeaders: [\"Authorization\", \"X-API-Key\"],\n    credentials: true,\n  }),\n);\napp.use(authMiddleware);\n```\n\n- **Result**: Enables authenticated cross-origin requests.\n\n### **3. Long Preflight Cache**\n\n```ts\ncors({ maxAge: 86400 }); // 24 hours\n```\n\n- **Result**: Browsers cache preflight responses for 24 hours.\n\n---\n\n## **Error Handling**\n\n- **Default Behavior**: Invalid origins receive an empty `Access-Control-Allow-Origin` header; `OPTIONS` requests return 204 regardless.\n- **Strict Enforcement**: Throw an error in the origin function for custom blocking:\n\n```ts\ncors({\n  origin: (origin) => {\n    if (!isValid(origin)) throw new Error(\"Invalid origin\");\n    return origin;\n  },\n});\n```\n\n---\n\n## **Best Practices**\n\n1. **Restrict Origins**\n\n```ts\n// ‚ùå Avoid in production\ncors({ origin: \"*\" });\n// ‚úÖ Secure setup\ncors({ origin: process.env.ALLOWED_ORIGINS });\n```\n\n2. **Limit Exposed Headers**\n\n```ts\ncors({ exposedHeaders: [\"X-RateLimit-Limit\", \"X-RateLimit-Remaining\"] });\n```\n\n3. **Use Credentials Judiciously**\n\n```ts\ncors({ credentials: true }); // Enable only when required\n```\n\n4. **Pair with Rate Limiting**\n\n```ts\napp.use(rateLimiter());\napp.use(cors());\n```\n\n---\n\n## **Regex-Specific Features**\n\n### **1. Regex Origin Patterns**\n\n```ts\ncors({ origin: /\\.example\\.com$/ }); // All subdomains\ncors({ origin: /https:\\/\\/app-(dev|staging)\\.com/ }); // Specific patterns\n```\n\n### **2. Mixed Array Support**\n\n```ts\ncors({\n  origin: [\n    \"https://production.com\",\n    /\\.staging\\.com$/,\n    \"http://localhost:3000\",\n  ],\n});\n```\n\n---\n\n## **Matching Logic**\n\n### **Priority Order**\n\n1. **String Exact Match**: `\"https://exact-domain.com\"`\n2. **Regex Pattern Test**: `/\\.domain\\.com$/`\n3. **Array Membership**: Strings or regexes\n4. **Function Validation**: Custom logic\n\n### **Matching Flow**\n\n```bash\ngraph TD\n  A[Request Origin] --> B{Is string?}\n  B -->|Yes| C[Exact match]\n  B -->|No| D{Is regex?}\n  D -->|Yes| E[Regex test]\n  D -->|No| F{Is array?}\n  F -->|Yes| G[Check array]\n  F -->|No| H{Is function?}\n  H -->|Yes| I[Function validation]\n```\n\n---\n\n## **Examples**\n\n### **1. Regex Origin Validation**\n\n```ts\ncors({\n  origin: [/\\.company\\.com$/, /localhost:\\d+/, \"https://partner-site.com\"],\n});\n```\n\n### **2. Dynamic Regex**\n\n```ts\nconst dynamicOrigins = [\n  new RegExp(`${process.env.ALLOWED_SUBDOMAINS_REGEX}`),\n  process.env.PRIMARY_DOMAIN,\n];\napp.use(cors({ origin: dynamicOrigins }));\n```\n\n### **3. Regex + Function**\n\n```ts\ncors({\n  origin: (origin) => /localhost:\\d+/.test(origin) || someOtherCheck(origin),\n});\n```\n\n---\n\n## **Special Cases**\n\n### **Regex Edge Handling**\n\n```ts\ncors({ origin: /^https:\\/\\/exact\\.com$/ }); // Exact match\ncors({ origin: /^https?:\\/\\/app\\.com$/ }); // HTTP or HTTPS\n```\n\n### **Port Matching**\n\n```ts\ncors({ origin: /http:\\/\\/localhost:\\d+/ }); // Any localhost port\n```\n\n---\n\n## **Security Considerations**\n\n1. **Anchor Regexes**\n\n```ts\n   // ‚ùå Vulnerable\n   /example\\.com/\n   // ‚úÖ Secure\n   /^https:\\/\\/.*\\.example\\.com$/\n```\n\n2. **Escape Characters**\n\n```ts\nconst domain = \"special.domain.com\";\nconst escaped = domain.replace(/\\./g, \"\\\\.\");\nnew RegExp(`^https://${escaped}$`);\n```\n\n3. **Use Allow Lists**\n\n```ts\nconst allowed = loadFromDB();\ncors({ origin: allowed.concat([/\\.safe-domain\\.com$/]) });\n```\n\n---\n\n## **Debugging Tips**\n\n### **Test Regex**\n\n```ts\nconst regex = /\\.staging\\.com$/;\nconsole.log(regex.test(\"https://app.staging.com\")); // true\n```\n\n### **Log Origins**\n\n```ts\napp.use((ctx, next) => {\n  console.log(\"CORS Origin:\", ctx.headers.get(\"origin\"));\n  return next();\n});\n```\n\n---\n\n## **API Reference**\n\n### **cors(options?: CorsOptions)**\n\n- **Returns**: Middleware function\n- **Behavior**:\n  1. Validates the request origin.\n  2. Sets appropriate CORS headers.\n  3. Handles `OPTIONS` requests with a 204 response.\n  4. Proceeds to the next middleware for non-`OPTIONS` requests.\n\n---\n"
    },
    {
      "id": 24,
      "path": "middlewares/i18nmiddleware",
      "name": "I18nMiddleware",
      "folder": "Middlewares",
      "content": "# üåç `i18nMiddleware`\n\n> Advanced internationalization (i18n) middleware for `tezx` with dynamic translation loading, fallback language chains, caching, and custom message formatting.\n\n---\n\n## üìÑ Usage\n\n### ‚úÖ Basic Usage\n\n```ts\nimport { i18nMiddleware } from \"tezx/middleware\";\n\napp.use(\n  i18nMiddleware({\n    loadTranslations: (lang) => import(`./locales/${lang}.json`),\n    defaultLanguage: \"en\",\n  }),\n);\n```\n\n---\n\n## üîß API: `i18nMiddleware(options: I18nOptions): Middleware`\n\n### üß© Interface: `I18nOptions`\n\n| Option                   | Type                                                          | Default                           | Description                                   |\n| ------------------------ | ------------------------------------------------------------- | --------------------------------- | --------------------------------------------- |\n| `loadTranslations`       | `(language: string) => Promise<{ translations, expiresAt? }>` | **Required**                      | Function that dynamically loads translations. |\n| `defaultCacheDuration`   | `number`                                                      | `3600000` (1 hr)                  | Time (ms) before cache expires.               |\n| `isCacheValid`           | `(cached, language) => boolean`                               | `expiresAt > Date.now()`          | Custom logic to validate cached translations. |\n| `detectLanguage`         | `(ctx: Context) => string`                                    | Query > Cookie > Header > default | Custom language detection.                    |\n| `defaultLanguage`        | `string`                                                      | `'en'`                            | Fallback language if detection fails.         |\n| `fallbackChain`          | `string[]`                                                    | `[]`                              | Array of fallback languages in priority.      |\n| `translationFunctionKey` | `string`                                                      | `'t'`                             | Key name attached to `ctx` for translating.   |\n| `formatMessage`          | `(message: string, options?: Record<string, any>) => string`  | Basic `{{var}}` replace           | Message interpolation.                        |\n| `cacheTranslations`      | `boolean`                                                     | `true`                            | Enable/disable translation caching.           |\n\n---\n\n## üí¨ Translation Format\n\nYou can structure translations as nested objects:\n\n```json\n{\n  \"home\": {\n    \"title\": \"Welcome, {{name}}!\",\n    \"subtitle\": \"Your dashboard\"\n  },\n  \"common\": {\n    \"logout\": \"Log out\"\n  }\n}\n```\n\n---\n\n## üß† Features Explained\n\n### 1. üåê Language Detection\n\nDefault flow:\n\n- Query Param: `?lang=fr`\n- Cookie: `lang=fr`\n- Header: `Accept-Language: fr`\n- Fallback: `'en'`\n\nYou can override this behavior:\n\n```ts\ndetectLanguage: (ctx) => ctx.cookies.get(\"user_lang\") || \"en\";\n```\n\n---\n\n### 2. üîÅ Fallback Chain\n\nSupport fallback chains like:\n\n```ts\nfallbackChain: [\"fr-CA\", \"fr\", \"en\"];\n```\n\n---\n\n### 3. üß† Cache with Expiry\n\n```ts\ncacheTranslations: true,\ndefaultCacheDuration: 1000 * 60 * 60 // 1 hour\n```\n\nOr use expiration from backend:\n\n```ts\nloadTranslations: async (lang) => {\n  const result = await fetchFromAPI(lang);\n  return {\n    translations: result.data,\n    expiresAt: Date.now() + 60000, // 1 min\n  };\n};\n```\n\n---\n\n### 4. üß© Message Interpolation\n\n```ts\nctx.t(\"home.title\", { name: \"Alice\" });\n// Output: \"Welcome, Alice!\"\n```\n\nYou can customize it:\n\n```ts\nformatMessage: (msg, vars) => {\n  return msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars[k] ?? \"\");\n};\n```\n\n---\n\n### 5. üìö Nested Key Support\n\n```ts\n// JSON\n{\n  \"user\": {\n    \"profile\": {\n      \"greeting\": \"Hello, {{name}}\"\n    }\n  }\n}\n\n// Access\nctx.t('user.profile.greeting', { name: 'John' });\n```\n\n---\n\n## üß™ Advanced Example\n\n```ts\napp.use(\n  i18nMiddleware({\n    loadTranslations: async (lang) => {\n      const res = await fetch(`https://api.example.com/lang/${lang}`);\n      const json = await res.json();\n      return {\n        translations: json.data,\n        expiresAt: json.expiresAt, // Optional\n      };\n    },\n    defaultLanguage: \"en\",\n    fallbackChain: [\"en-GB\", \"en\"],\n    detectLanguage: (ctx) => ctx.headers.get(\"x-custom-lang\") || \"en\",\n    translationFunctionKey: \"translate\",\n    formatMessage: (msg, vars) => {\n      return msg.replace(\n        /\\{\\{(.*?)\\}\\}/g,\n        (_, key) => vars?.[key.trim()] ?? \"\",\n      );\n    },\n    cacheTranslations: true,\n    isCacheValid: (cached, lang) => {\n      return cached.expiresAt > Date.now();\n    },\n  }),\n);\n```\n\n---\n\n## üìå What `ctx` contains after middleware\n\n| Property            | Type                                      | Description             |\n| ------------------- | ----------------------------------------- | ----------------------- |\n| `ctx.t(key, vars)`  | `(string, Record<string, any>) => string` | Translation function    |\n| `ctx.language`      | `string`                                  | Selected language       |\n| `ctx.languageChain` | `string[]`                                | Language fallback chain |\n\n---\n\n## ‚ùó Error Handling\n\nIf no translations are found for any language in the chain, the middleware throws an error and sets:\n\n```ts\nctx.setStatus = 500;\n```\n\n---\n\n## üì§ Exported Types\n\nYou can reuse types for strong typing in your app:\n\n```ts\nimport type {\n  I18nOptions,\n  loadTranslations,\n  TranslationMap,\n} from \"tezx/middleware\";\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "middlewares/lazy-load-modules",
      "name": "Lazy Load Modules",
      "folder": "Middlewares",
      "content": "# **Lazy Module Loader Middleware**\n\n## **Overview**\n\nThe **Lazy Module Loader Middleware** is designed for dynamic, on-demand loading of modules in web applications. It helps optimize application startup time by only loading the modules when required. This middleware supports caching, lifecycle hooks, and dependency injection to enhance flexibility and performance in large-scale applications.\n\nThe middleware is ideal for applications with varying user requirements, such as role-based module loading, where different users need access to different sets of modules.\n\n---\n\n## **Key Features**\n\n- **Dynamic Module Loading:** Modules are loaded based on request parameters, user roles, or custom conditions.\n- **Caching Support:** Automatically cache modules to reduce load time for frequently used modules.\n- **Lifecycle Hooks:** Track events during the module loading process (e.g., before load, after load, on cache hit, on error).\n- **Dependency Injection:** Inject dependencies into modules upon loading (e.g., external services, configurations).\n- **Validation:** Ensure modules meet specific requirements (e.g., must implement certain methods before use).\n- **Error Handling:** Built-in error handling for failed module loading.\n\n---\n\n## **Usage**\n\n### **Basic Setup**\n\nBelow is the basic setup for using the **Lazy Module Loader Middleware** within a web application.\n\n1. Import the necessary modules:\n\n```ts\nimport { Context, Middleware } from \"tezx\"; // Adjust based on your framework\nimport { lazyLoadModules } from \"tezx/middleware\"; // Adjust path as needed\n```\n\n2. Initialize the middleware with default settings:\n\n```ts\nconst lazyModuleMiddleware: Middleware = lazyLoadModules({\n  // Define the method for determining which module to load based on request.\n  moduleKey: (ctx: Context) => ctx.req.query.module || ctx.req.params.module,\n\n  // Specify how to load the module dynamically.\n  getModuleLoader: (ctx: Context) => {\n    const moduleName = ctx.req.query.module || ctx.req.params.module;\n    if (moduleName) {\n      return () => import(`./modules/${moduleName}.js`);\n    }\n    return null;\n  },\n\n  // Cache configuration: Use an in-memory cache by default.\n  enableCache: true,\n  cacheTTL: 3600000, // Cache Time-to-Live (TTL) in milliseconds (1 hour)\n\n  // Inject dependencies into the module.\n  // it work with int function.\n  dependencies: {\n    logger: console,\n    config: { env: process.env.NODE_ENV },\n  },\n\n  // Provide lifecycle hooks to track module loading events.\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) => {\n      console.log(`Loading module: ${moduleName}`);\n    },\n    onCacheHit: (moduleName, module, ctx) => {\n      console.log(`Cache hit for module: ${moduleName}`);\n    },\n    onComplete: (moduleName, module, ctx) => {\n      console.log(`Module loaded successfully: ${moduleName}`);\n    },\n    onError: (moduleName, error, ctx) => {\n      console.error(`Error loading module: ${moduleName}`, error);\n    },\n  },\n\n  // Module validation: Ensure the module meets required criteria before use.\n  validateModule: (module) =>\n    typeof module.init === \"function\" && typeof module.execute === \"function\",\n});\n\n// Register the middleware with the application.\napp.use(lazyModuleMiddleware);\n```\n\n### **Accessing the Loaded Module**\n\nOnce the middleware has loaded the module, it attaches it to the context. You can access it in route handlers like so:\n\n```ts\napp.get(\"/execute\", async (ctx: Context) => {\n  const module = ctx.loadedModule;\n  if (module && module.execute) {\n    module.execute();\n    return ctx.json({ message: \"Module action executed successfully.\" });\n  } else {\n    return ctx.json({\n      error: \"Module is either not loaded or missing the 'execute' function.\",\n    });\n  }\n});\n```\n\n---\n\n## **Configuration Options**\n\nThe middleware is highly configurable, allowing you to define how modules are loaded, cached, and validated. Below are the available configuration options:\n\n### **1. moduleKey** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function to determine which module to load based on the incoming request. It should return a string representing the module name or key.\n\nExample:\n\n```ts\nmoduleKey: (ctx: Context) => ctx.req.query.module || ctx.req.params.module;\n```\n\n### **2. getModuleLoader** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function that returns a Promise which dynamically imports the module based on the context (e.g., URL parameters, user roles).\n\nExample:\n\n```ts\ngetModuleLoader: (ctx: Context) => {\n  const moduleName = ctx.req.query.module || ctx.req.params.module;\n  if (moduleName) {\n    return () => import(`./modules/${moduleName}.js`);\n  }\n  return null;\n};\n```\n\n### **3. enableCache** (Boolean)\n\n- **Type:** `Boolean`\n- **Default:** `true`\n- **Description:** Enable or disable caching of modules. By default, modules are cached in memory.\n\nExample:\n\n```ts\nenableCache: true;\n```\n\n### **4. cacheTTL** (Number)\n\n- **Type:** `Number`\n- **Default:** `3600000` (1 hour)\n- **Description:** Time-to-Live (TTL) in milliseconds for cached modules. After this time, the module will be reloaded.\n\nExample:\n\n```ts\ncacheTTL: 3600000;\n```\n\n### **5. dependencies** (Object)\n\n- **Type:** `Object`\n- **Description:** Inject dependencies into the loaded modules (e.g., services, configurations). This is useful when the module requires external dependencies for initialization.\n- **Work:** It always work with module `int function`.\n  Example:\n\n```ts\ndependencies: {\n  logger: console,\n  config: { env: process.env.NODE_ENV }\n}\n\n// dashboard.js\nexport function init(dependencies, ctx) {\n    // ctx. ....................\n    // operation\n    console.log(dependencies, 534)\n}\n// with response\nexport function init(dependencies, ctx) {\n    return ctx.json({ x: 345 })\n}\n```\n\n### **6. lifecycleHooks** (Object)\n\n- **Type:** `Object`\n- **Description:** A set of hooks that are called during different stages of the module loading process. These hooks provide insight into the module loading, caching, and error handling flow.\n\n#### Available hooks\n\n- **onLoad(moduleName, ctx):** Triggered when the module is being loaded.\n- **onCacheHit(moduleName, module, ctx):** Triggered when a module is found in the cache.\n- **onCacheSet(moduleName, module, ctx):** Triggered after a module is added to the cache.\n- **onComplete(moduleName, module, ctx):** Triggered when the module has been successfully loaded.\n- **onError(moduleName, error, ctx):** Triggered when an error occurs during module loading.\n\nExample:\n\n```ts\nlifecycleHooks: {\n  onLoad: (moduleName, ctx) => console.log(`Loading module: ${moduleName}`),\n  onCacheHit: (moduleName, module, ctx) => console.log(`Cache hit for: ${moduleName}`),\n  onComplete: (moduleName, module, ctx) => console.log(`Module loaded: ${moduleName}`),\n  onError: (moduleName, error, ctx) => console.error(`Error loading module: ${moduleName}`, error)\n}\n```\n\n### **7. validateModule** (Function)\n\n- **Type:** `Function`\n- **Required:** Yes\n- **Description:** A function that validates the loaded module before it is used. This function should return `true` if the module is valid or `false` otherwise.\n\nExample:\n\n```ts\nvalidateModule: (module) =>\n  typeof module.init === \"function\" && typeof module.execute === \"function\";\n```\n\n---\n\n## **Advanced Features**\n\n### **Custom Cache Storage**\n\nIf you want to replace the default in-memory cache with a custom storage backend (e.g., Redis), you can implement a custom cache interface that adheres to the `Map` API.\n\nExample of using a Redis client (or any custom storage):\n\n```ts\nclass RedisCache {\n  async get(key: string): Promise<any> {\n    return redisClient.get(key); // Replace with Redis or other storage logic\n  }\n  async set(key: string, value: any): Promise<void> {\n    return redisClient.set(key, JSON.stringify(value)); // Adjust according to your storage solution\n  }\n  async delete(key: string): Promise<void> {\n    return redisClient.del(key); // Adjust according to your storage solution\n  }\n}\n```\n\nYou can then pass this cache object as the `cacheStorage` option in the middleware configuration.\n\n---\n\n## **Error Handling**\n\nThe middleware provides built-in error handling that logs errors when module loading fails. You can customize the error handling by defining your own error handler inside the `lifecycleHooks.onError` callback.\n\nExample:\n\n```ts\nlifecycleHooks: {\n  onError: (moduleName, error, ctx) => {\n    console.error(`Failed to load module: ${moduleName}`, error);\n    ctx.setStatus = 500;\n  };\n}\n```\n\n---\n\n## **Best Practices**\n\n- **Module Validation:** Always validate modules before using them to ensure they have the necessary methods and properties.\n- **Caching Strategy:** Use caching with a reasonable TTL to optimize performance while preventing stale data from being served.\n- **Error Handling:** Implement robust error handling to capture and respond to failures gracefully.\n\n---\n\n## **Conclusion**\n\nThe **Lazy Module Loader Middleware** is an essential tool for applications that need to load modules dynamically based on various conditions. It provides advanced features like caching, lifecycle hooks, and dependency injection, which help optimize performance and maintain flexibility. By customizing this middleware according to your application‚Äôs needs, you can efficiently manage dynamic module loading with reduced overhead.\n\n```ts\napp.use(\n  lazyLoadModules<WidgetModule>({\n    getModuleLoader: (ctx) => () =>\n      import(`./widgets/${ctx.req.params.widget}`),\n    validateModule: (module) =>\n      typeof module.render === \"function\" && typeof module.init === \"function\",\n    cacheTTL: 86400000, // 24 hours\n    dependencies: { logger, config },\n    lifecycleHooks: {\n      onLoad: (name) => console.log(`Loading ${name}`),\n      onError: (name, err) => metrics.trackError(err),\n      onCacheHit: (name) => console.log(`Cache hit for ${name}`),\n    },\n  }),\n);\n```\n"
    },
    {
      "id": 26,
      "path": "middlewares/logger",
      "name": "Logger",
      "folder": "Middlewares",
      "content": "# Logger Middleware\n\n## Overview\n\nThe `logger` middleware is a utility for logging HTTP requests in a structured and color-coded format. It captures and logs details such as request method, pathname, status, and execution time.\n\n## Features\n\n- Logs incoming HTTP requests with method and pathname.\n- Captures execution time for each request.\n- Displays status codes upon response completion.\n- Handles and logs errors encountered during request processing.\n\n## Usage\n\n### Import the `logger` Middleware\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(logger());\n```\n\n### Return Value\n\nReturns a middleware function that logs request details and execution time.\n\n## Implementation Details\n\n1. Logs the incoming request method and pathname.\n2. Captures the start time before executing the next middleware.\n3. Calls `await next()` to process the request.\n4. Computes execution time after response processing.\n5. Logs response details including method, pathname, status code, and execution time.\n6. Handles and logs errors if encountered during execution.\n\n## Example Output\n\n```bash\n<-- GET /api/data\n--> GET /api/data 200 45.32ms\n```\n\n## Error Handling\n\nIf an error occurs during middleware execution, it:\n\n- Logs the error details to the console.\n- Throws the error to be handled by upstream middleware.\n"
    },
    {
      "id": 27,
      "path": "middlewares/powered-by",
      "name": "Powered By",
      "folder": "Middlewares",
      "content": "# PoweredBy Middleware\n\n## Overview\n\nThe `poweredBy` middleware is a simple utility that adds an `X-Powered-By` HTTP header to responses. It allows customization of the server name, with a default value of `TezX`.\n\n## Features\n\n- Adds an `X-Powered-By` header to every response.\n- Allows an optional custom server name.\n- Lightweight and efficient middleware.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `poweredBy` Middleware\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n## Function Signature\n\n```ts\nexport const poweredBy = (serverName?: string): Middleware;\n```\n\n### Parameters\n\n- `serverName` _(optional, string)_: Custom name for the `X-Powered-By` header. Defaults to `TezX`.\n\n### Return Value\n\nReturns a middleware function that sets the `X-Powered-By` header.\n\n## Implementation Details\n\n1. Sets the `X-Powered-By` header on the response.\n2. Uses the provided `serverName` or defaults to `TezX`.\n3. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Powered-By: MyServer\n```\n\n## Notes\n\n- Ensure this middleware is included early in the middleware stack to guarantee header presence.\n- Customizing the `X-Powered-By` value can help with branding or security measures.\n"
    },
    {
      "id": 28,
      "path": "middlewares/request-id",
      "name": "Request ID",
      "folder": "Middlewares",
      "content": "# Request ID Middleware\n\n## Overview\n\nThe `requestID` middleware assigns a unique request ID to each incoming request. This helps with request tracking, debugging, and logging.\n\n## Features\n\n- Assigns a unique request ID to each request.\n- Uses an existing request ID from headers if available.\n- Stores the request ID in the request context for easy access.\n- Sets the request ID in the response headers.\n\n## Installation\n\nEnsure your project is set up to use this middleware in an Express-like environment or a framework that supports middleware functions.\n\n## Usage\n\n### Import the `requestID` Middleware\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n### Apply the Middleware\n\n```ts\napp.use(requestID());\n```\n\n## Function Signature\n\n```ts\nexport const requestID = (headerName?: string): Middleware;\n```\n\n### Parameters\n\n- `headerName` _(optional, string)_: Custom header name for the request ID. Defaults to `\"X-Request-ID\"`.\n\n### Return Value\n\nReturns a middleware function that assigns and tracks request IDs.\n\n## Implementation Details\n\n1. Checks if the request already has an ID in the specified header.\n2. If not, generates a new request ID using `generateID()`.\n3. Stores the request ID in `ctx.state` for easy access.\n4. Adds the request ID to the response headers.\n5. Proceeds to the next middleware in the stack.\n\n## Example Response Header\n\n```bash\nX-Request-ID: req-123456789\n```\n\n## Notes\n\n- Ensure this middleware is included early in the stack to track all requests.\n- Customizing the header name allows flexibility in integration with different systems.\n- Using a consistent request ID helps in debugging and tracing requests across services.\n"
    },
    {
      "id": 29,
      "path": "middlewares/secure-headers",
      "name": "Secure Headers",
      "folder": "Middlewares",
      "content": "# Secure Headers Middleware\n\n## Overview\n\nThe `secureHeaders` middleware enhances the security of your application by dynamically setting HTTP security headers based on the request context.\n\n## Features\n\n- Configurable security headers for enhanced protection.\n- Supports dynamic header values based on request context.\n- Default settings provide strong security practices.\n\n## Usage\n\n### Import the `secureHeaders` Middleware\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n```\n\n### Apply the Middleware with Default Security Headers\n\n```ts\napp.use(secureHeaders());\n```\n\n### Apply the Middleware with Custom Security Headers\n\n```ts\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: \"default-src 'self'\",\n    frameGuard: true,\n    hsts: true,\n    referrerPolicy: \"no-referrer\",\n  }),\n);\n```\n\n## Function Signature\n\n```ts\nexport const secureHeaders = (options?: SecurityHeaderOptions): Middleware;\n```\n\n### Parameters\n\n- `options` _(optional, SecurityHeaderOptions)_: An object specifying custom security headers.\n\n### Return Value\n\nReturns a middleware function that sets security-related HTTP headers.\n\n## Security Headers Implemented\n\n| Header                      | Description                                       |\n| --------------------------- | ------------------------------------------------- |\n| `Content-Security-Policy`   | Controls resources allowed to load on a page.     |\n| `X-Frame-Options`           | Protects against clickjacking attacks.            |\n| `Strict-Transport-Security` | Enforces HTTPS connections.                       |\n| `X-XSS-Protection`          | Helps prevent cross-site scripting (XSS) attacks. |\n| `X-Content-Type-Options`    | Prevents MIME-type sniffing.                      |\n| `Referrer-Policy`           | Controls referrer information sent with requests. |\n| `Permissions-Policy`        | Restricts browser feature permissions.            |\n\n## Implementation Details\n\n1. Resolves dynamic values for security headers.\n2. Sets default values if no custom options are provided.\n3. Applies headers to the response.\n4. Proceeds to the next middleware in the stack.\n\n#### **1. Default Values**\n\nEach header has a sensible default value:\n\n| Header                      | Default Value                                                                              |\n| --------------------------- | ------------------------------------------------------------------------------------------ |\n| `Content-Security-Policy`   | `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';` |\n| `X-Frame-Options`           | `DENY`                                                                                     |\n| `Strict-Transport-Security` | `max-age=63072000; includeSubDomains`                                                      |\n| `X-XSS-Protection`          | `1; mode=block`                                                                            |\n| `X-Content-Type-Options`    | `nosniff`                                                                                  |\n| `Referrer-Policy`           | `no-referrer`                                                                              |\n| `Permissions-Policy`        | `geolocation=(), microphone=(), camera=()`                                                 |\n\n#### **2. Dynamic Overrides**\n\nUsers can override these defaults by providing custom values or functions that generate headers dynamically based on the request context.\n\n#### **3. Environment Awareness**\n\nThe `hsts` header is enabled only in production (`process.env.NODE_ENV === \"production\"`), ensuring it doesn't interfere with development workflows.\n\n---\n\n### **3. Usage Example**\n\nHere‚Äôs how you can use the enhanced `secureHeaders` middleware with default values and dynamic overrides:\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\napp.use(\n  secureHeaders({\n    contentSecurityPolicy: (ctx) =>\n      ctx.url.includes(\"/admin\")\n        ? \"default-src 'self'; script-src 'self';\"\n        : undefined, // Use default for non-admin routes\n    hsts: false, // Disable HSTS globally\n    referrerPolicy: \"strict-origin-when-cross-origin\", // Override default\n  }),\n);\n\napp.get(\"/\", (ctx) => {\n  return ctx.send(\"Hello, World!\");\n});\n\napp.get(\"/admin\", (req, res) => {\n  return ctx.send(\"Admin Dashboard\");\n});\n```\n\n---\n\n### **4. Testing**\n\n#### **1. Check Default Headers**\n\nMake a request to `/`:\n\n```bash\ncurl -I http://localhost:3000/\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **2. Check Admin-Specific Headers**\n\nMake a request to `/admin`:\n\n```bash\ncurl -I http://localhost:3000/admin\n```\n\nExpected Output:\n\n```bash\nHTTP/1.1 200 OK\nContent-Security-Policy: default-src 'self'; script-src 'self';\nX-Frame-Options: DENY\nX-XSS-Protection: 1; mode=block\nX-Content-Type-Options: nosniff\nReferrer-Policy: strict-origin-when-cross-origin\nPermissions-Policy: geolocation=(), microphone=(), camera=()\n```\n\n#### **3. Disabled HSTS**\n\nSince `hsts` is explicitly disabled, the `Strict-Transport-Security` header will not appear in responses.\n\n---\n"
    },
    {
      "id": 30,
      "path": "middlewares/xss-protection",
      "name": "XSS Protection",
      "folder": "Middlewares",
      "content": "# XSS Protection Middleware\n\n## Overview\n\nThe `xssProtection` middleware provides robust cross-site scripting (XSS) protection by setting appropriate security headers and implementing configurable protection strategies. This middleware is designed to be flexible while providing sensible defaults for most use cases.\n\n## Installation\n\n```ts\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(xssProtection());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n    mode: \"filter\", // Sanitize instead of block\n    fallbackCSP: \"default-src 'self' https://trusted.cdn.com\",\n  }),\n);\n```\n\n## Configuration Options\n\n### `enabled: boolean | (ctx: Context) => boolean`\n\n- **Default:** `true`\n- Determines whether XSS protection is active\n- Can be a boolean or a function that dynamically evaluates based on the request context\n- **Example:**\n\n  ```ts\n  enabled: true; // Always enable\n  enabled: (ctx) => !ctx.isAdmin; // Disable for admin routes\n  ```\n\n### `mode: \"block\" | \"filter\"`\n\n- **Default:** `\"block\"`\n- Specifies the protection strategy:\n  - `\"block\"`: Completely blocks the page if XSS is detected\n  - `\"filter\"`: Attempts to sanitize the page if XSS is detected\n- **Example:**\n\n  ```ts\n  mode: \"block\"; // More secure but may break legitimate content\n  mode: \"filter\"; // More permissive but safer for complex applications\n  ```\n\n### `fallbackCSP: string`\n\n- **Default:** `\"default-src 'self'; script-src 'self';\"`\n- Provides a fallback Content Security Policy for browsers without XSS protection\n- Only applied if no existing CSP header is present\n- **Example:**\n\n  ```ts\n  fallbackCSP: \"default-src 'none'; script-src 'self' https://trusted.cdn.com\";\n  ```\n\n## Technical Implementation Details\n\n### Header Configuration\n\n- Sets the `X-XSS-Protection` header with values based on the selected mode:\n  - `1; mode=block` for \"block\" mode\n  - `1` for \"filter\" mode\n- Optionally sets `Content-Security-Policy` header if no existing CSP is present\n\n### Execution Flow\n\n1. Checks if protection is enabled (either statically or dynamically)\n2. If disabled, skips to next middleware with a warning\n3. Sets XSS protection header based on configured mode\n4. Optionally sets fallback CSP if none exists\n5. Proceeds to next middleware in the chain\n\n## Debugging Information\n\nThe middleware logs important events through the global debugging system:\n\n- üü† Warning when XSS protection is disabled\n- üü¢ Confirmation when X-XSS-Protection header is set\n- üü£ Notification when fallback CSP is applied\n\n## Best Practices\n\n1. **Testing**: Always test with your application's content to ensure the blocking mode doesn't interfere with legitimate functionality\n2. **CSP Coordination**: If you have a comprehensive CSP policy, consider leaving `fallbackCSP` empty\n3. **Conditional Enablement**: Use the functional `enabled` option to disable protection for trusted routes (e.g., admin interfaces)\n4. **Monitoring**: Monitor your application logs for XSS protection warnings to identify potential attacks\n\n## Browser Compatibility\n\n- The `X-XSS-Protection` header is supported in most modern browsers\n- The fallback CSP provides additional protection for browsers without XSS filtering\n- Consider polyfills or additional security measures for very old browsers\n\n## Security Considerations\n\n- This middleware is only one layer of defense - implement additional XSS protections like:\n  - Input validation\n  - Output encoding\n  - Proper Content Security Policies\n- The \"filter\" mode is less secure than \"block\" but may be necessary for complex applications\n- Regularly review and update your CSP policies as your application evolves\n"
    },
    {
      "id": 31,
      "path": "middlewares/sanitize-headers",
      "name": "Sanitize Headers",
      "folder": "Middlewares",
      "content": "# Header Sanitization Middleware\n\n## Overview\n\nThe `sanitizeHeaders` middleware provides comprehensive HTTP header sanitization to enhance security and ensure compliance with standards. It offers multiple protection layers including whitelisting, blacklisting, normalization, and value sanitization.\n\n## Installation\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\napp.use(sanitizeHeaders());\n```\n\n## Advanced Configuration\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n    normalizeKeys: true,\n    allowUnsafeCharacters: false,\n  }),\n);\n```\n\n## Configuration Options\n\n### `whitelist: string[]`\n\n- **Default:** `[]` (allows all headers when empty)\n- Array of allowed header names (case-insensitive)\n- When non-empty, only headers in this list will be preserved\n- **Example:**\n\n  ```ts\n  whitelist: [\"content-type\", \"authorization\"]; // Strict allow list\n  ```\n\n### `blacklist: string[]`\n\n- **Default:** `[]` (blocks none when empty)\n- Array of prohibited header names (case-insensitive)\n- **Example:**\n\n  ```ts\n  blacklist: [\"x-powered-by\", \"server\"]; // Block server info headers\n  ```\n\n### `normalizeKeys: boolean`\n\n- **Default:** `true`\n- Converts header names to lowercase for consistency\n- **Example:**\n\n  ```ts\n  normalizeKeys: false; // Preserve original header case\n  ```\n\n### `allowUnsafeCharacters: boolean`\n\n- **Default:** `false`\n- Permits potentially dangerous characters in header values\n- **Warning:** Enabling reduces security against header injection\n- **Example:**\n\n  ```ts\n  allowUnsafeCharacters: true; // Allow CR/LF in headers (not recommended)\n  ```\n\n## Technical Implementation\n\n### Processing Pipeline\n\n1. **Header Iteration**: Processes each header entry in the request\n2. **Normalization**: Converts header names to lowercase (if enabled)\n3. **List Validation**:\n   - Checks against whitelist (if defined)\n   - Checks against blacklist\n4. **Name Validation**: Verifies header name format (RFC 7230)\n5. **Value Sanitization**:\n   - Trims whitespace\n   - Removes control characters (unless allowed)\n6. **Result Compilation**: Builds new sanitized headers collection\n7. **Header Replacement**: Overwrites original headers\n\n### Validation Standards\n\n- Header names must match regex: `/^[a-zA-Z0-9\\-_]+$/`\n- Header values are trimmed and cleaned of control characters by default\n\n## Debugging Information\n\nThe middleware logs security events through the global debugging system:\n\n- üö´ Header removal due to whitelist/blacklist violations\n- ‚ö†Ô∏è Invalid header name detection\n- ‚ö†Ô∏è Empty value removal notifications\n\n## Best Practices\n\n1. **Defensive Configuration**:\n\n```ts\n// Recommended security-focused setup\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"accept\", \"content-type\", \"authorization\"],\n    normalizeKeys: true,\n  }),\n);\n```\n\n2. **Information Hiding**:\n\n```ts\n// Hide server technology information\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\", \"x-aspnet-version\"],\n  }),\n);\n```\n\n3. **Compatibility Testing**:\n\n   - Test with your client applications after implementing whitelists\n   - Monitor logs for removed headers that may be needed\n\n4. **Security Layers**:\n   - Combine with other security middleware (CSP, CORS, etc.)\n   - Implement at both edge and application layers\n\n## Performance Considerations\n\n- The middleware creates a new headers collection rather than modifying in-place\n- Whitelist/blacklist checks use case-insensitive comparison\n- For optimal performance with whitelists:\n\n  - Keep the whitelist array small\n  - Consider pre-normalizing whitelist entries:\n\n```ts\nwhitelist: [\"content-type\", \"authorization\"].map((h) => h.toLowerCase());\n```\n\n## Security Considerations\n\n- **Header Injection**: Prevents CRLF injection attacks by default\n- **Information Leakage**: Helps remove server technology identifiers\n- **Normalization Benefits**:\n  - Prevents case-sensitivity issues\n  - Reduces attack surface for header manipulation\n- **Whitelist Advantages**:\n  - Most secure approach\n  - Explicitly defines allowed headers\n\n## Browser and Client Compatibility\n\n- Transparent to clients as it only removes/modifies headers\n- No client-side changes required\n- Particularly important for:\n  - Public-facing APIs\n  - Applications accepting untrusted input\n  - Systems requiring compliance standards (PCI DSS, HIPAA)\n"
    },
    {
      "id": 32,
      "path": "middlewares/rate-limiter",
      "name": "Rate Limiter",
      "folder": "Middlewares",
      "content": "# Rate Limiting Middleware\n\n## Overview\n\nThe `rateLimiter` middleware provides robust request throttling capabilities to protect your application from abuse and ensure fair resource allocation. It implements a sliding window rate limiting algorithm with configurable limits and client identification.\n\n**Note: It works with `app.use` api**\n\n## Installation\n\n```ts\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n## Basic Usage\n\n```ts\n// Basic rate limiting (100 requests per minute)\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n  }),\n);\n```\n\n## Advanced Configuration\n\n```ts\n// Customized rate limiting\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        error: \"Too Many Requests\",\n        retryAfter: `${retryAfter} seconds`,\n      });\n    },\n  }),\n);\n```\n\n## Default Configuration Values\n\n```ts\nconst defaultOptions: RateLimiterOptions = {\n  maxRequests: 100, // Default maximum requests\n  windowMs: 60_000, // Default 1 minute window (60,000 ms)\n  keyGenerator: (ctx) =>\n    `${ctx.req.remoteAddress.address}:${ctx.req.remoteAddress.port}`,\n  onError: (ctx, retryAfter, error) => {\n    ctx.setStatus = 429; // Too Many Requests\n    throw new Error(`Rate limit exceeded. Try again in ${retryAfter} seconds.`);\n  },\n};\n```\n\n## Configuration Options\n\n### `maxRequests: number`\n\n- **Required**: Yes\n- Maximum allowed requests per client in the time window\n- **Example**: `100` (allow 100 requests per window)\n\n### `windowMs: number`\n\n- **Required**: Yes\n- Time window in milliseconds for rate limiting\n- **Example**: `60_000` (1 minute window)\n\n### `keyGenerator: (ctx: Context) => string`\n\n- **Default**: Uses client IP and port\n- Generates a unique identifier for rate limiting\n- **Example**:\n\n  ```ts\n  keyGenerator: (ctx) => ctx.user?.id || ctx.ip;\n  ```\n\n### `onError: (ctx: Context, retryAfter: number, error: Error) => void`\n\n- **Default**: Sends 429 status with error message\n- Custom handler for rate limit exceeded cases\n- **Example**:\n\n  ```ts\n  onError: (ctx, retryAfter) => {\n    ctx.status = 429;\n    return ctx.json({ error: `Try again in ${retryAfter} seconds` });\n  };\n  ```\n\n```ts\n/**\n     * üîÑ Custom cache storage implementation (e.g., using `Map`, `Redis`, etc.).\n     * By default, it uses a `Map<string, { count: number; resetTime: number }>`.\n     */\n  cacheStorage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    delete: (key: string) => void;\n    entries: () => IterableIterator<[string, { count: number; resetTime: number }]>;\n  };\n\n```\n\n## Technical Implementation\n\n### Algorithm\n\n- **Sliding Window**: Tracks requests in fixed time windows\n- **In-Memory Storage**: Uses Map for tracking (Redis support planned)\n- **Atomic Counting**: Ensures accurate request counting\n\n### Headers\n\n- `X-RateLimit-Limit`: Maximum allowed requests\n- `X-RateLimit-Remaining`: Remaining requests in window\n- `X-RateLimit-Reset`: Unix timestamp when window resets\n- `Retry-After`: Seconds until next allowed request (on 429)\n\n## Best Practices\n\n### Production Configuration\n\n```ts\n// Recommended production settings\napp.use(\n  rateLimiter({\n    maxRequests: process.env.NODE_ENV === \"production\" ? 100 : 1000,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  }),\n);\n```\n\n### Layered Protection\n\n```ts\n// Different limits for different routes\nconst apiLimiter = rateLimiter({\n  maxRequests: 100,\n  windowMs: 15 * 60 * 1000, // 15 minutes\n});\n\nconst authLimiter = rateLimiter({\n  maxRequests: 5,\n  windowMs: 60 * 1000, // 1 minute\n});\n\napp.use(\"/api/\", apiLimiter);\napp.use(\"/auth/\", authLimiter);\n```\n\n## Performance Considerations\n\n1. **Memory Usage**:\n\n   - In-memory storage grows with unique clients\n   - Consider periodic cleanup of expired entries\n\n2. **Key Generation**:\n\n   - Keep key generation simple and efficient\n   - Avoid expensive operations in `keyGenerator`\n\n3. **Monitoring**:\n   - Track rate limit hits to identify abuse patterns\n   - Consider logging blocked requests\n\n## Security Considerations\n\n1. **IP Spoofing**:\n\n   - Be aware clients may change IPs\n   - Combine with other authentication for sensitive endpoints\n\n2. **Distributed Attacks**:\n\n   - In-memory storage won't protect against distributed attacks\n   - Future Redis support will help with this\n\n3. **Sensitive Endpoints**:\n   - Apply stricter limits to authentication endpoints\n   - Consider lower limits for password reset functionality\n\n## Error Handling\n\n### Custom Error Responses\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.status = 429;\n      return ctx.json({\n        code: \"RATE_LIMITED\",\n        message: `Please wait ${retryAfter} seconds`,\n        retryAfter,\n      });\n    },\n  }),\n);\n```\n\n### Error Monitoring\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter, error) => {\n      logRateLimitHit(ctx.ip, ctx.path);\n      throw error; // Let error propagate to global handler\n    },\n  }),\n);\n```\n\n## Future Enhancements\n\n1. **Redis Support**:\n\n```ts\n// Planned future usage\napp.use(\n  rateLimiter({\n    maxRequests: 1000,\n    windowMs: 3600000,\n    storage: \"redis\",\n    redisClient: redis.createClient(),\n  }),\n);\n```\n\n2. **Burst Protection**:\n\n   - Add support for burst limits with separate configuration\n\n3. **Cost-Based Limiting**:\n\n   - Implement variable costs for different endpoints\n\n4. **Metrics Integration**:\n   - Add Prometheus/StatsD metrics for monitoring\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Too Many 429s**:\n\n   - Increase `maxRequests` or `windowMs`\n   - Verify client identification is working correctly\n\n2. **Memory Growth**:\n\n   - Implement periodic cleanup of expired entries\n   - Monitor memory usage\n\n3. **Inconsistent Counting**:\n   - Verify `keyGenerator` produces stable identifiers\n   - Check for middleware ordering issues\n\n## Example Use Cases\n\n### API Protection\n\n```ts\n// Protect public API endpoints\napp.use(\n  \"/api/\",\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n  }),\n);\n```\n\n### Authentication Endpoints\n\n```ts\n// Strict limits on auth endpoints\napp.use(\n  \"/auth/\",\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60 * 1000, // 1 minute\n  }),\n);\n```\n\n### Admin Endpoints\n\n```ts\n// Higher limits for authenticated admin users\napp.use(\n  \"/admin/\",\n  rateLimiter({\n    maxRequests: (ctx) => (ctx.user?.isAdmin ? 1000 : 100),\n    windowMs: 60 * 1000,\n  }),\n);\n```\n"
    },
    {
      "id": 33,
      "path": "middlewares/pagination",
      "name": "Pagination",
      "folder": "Middlewares",
      "content": "# Pagination Middleware\n\n## Overview\n\nThe `paginationHandler` is an advanced middleware designed to streamline pagination in web applications. It automates query parameter parsing, supports dynamic data fetching, and provides comprehensive pagination metadata, making it ideal for APIs requiring paginated responses.\n\n### Features\n\n- **Automatic Parameter Handling**: Parses `page` and `limit` from query strings with sanitization.\n- **Dynamic Data Integration**: Fetches paginated data via a configurable `getDataSource`.\n- **Rich Metadata**: Includes total items, total pages, next/previous page indicators, and more.\n- **Flexible Workflow**: Integrates with subsequent middleware via `next()` when `getDataSource` is used.\n- **Error Handling**: Ensures robust input validation and fallback behavior.\n\n### Dependencies\n\n```typescript\nimport { Context } from \"tezx\";\nimport { Middleware } from \"tezx\";\n```\n\n- **`Context`**: Base context type for request handling, providing access to `req`, `body`, etc.\n- **`Middleware`**: Type for middleware functions that process requests and optionally call `next()`.\n\n---\n\n## Types\n\n### `PaginationOptions`\n\nConfiguration options for customizing pagination behavior.\n\n```typescript\nexport type PaginationOptions = {\n  /**\n   * üî¢ Default page number when not specified\n   * @default 1\n   * @example 1 // Start from first page\n   */\n  defaultPage?: number;\n\n  /**\n   * üìè Default items per page\n   * @default 10\n   * @example 25 // Show 25 items by default\n   */\n  defaultLimit?: number;\n\n  /**\n   * ‚ö†Ô∏è Maximum allowed items per page\n   * @default 100\n   * @example 50 // Never return more than 50 items\n   */\n  maxLimit?: number;\n\n  /**\n   * üîç Query parameter name for page number\n   * @default \"page\"\n   * @example \"p\" // Use ?p=2 instead of ?page=2\n   */\n  queryKeyPage?: string;\n\n  /**\n   * üîç Query parameter name for items limit\n   * @default \"limit\"\n   * @example \"size\" // Use ?size=20\n   */\n  queryKeyLimit?: string;\n\n  /**\n   * üìä Key to read total count from response\n   * @default \"total\"\n   * @example \"totalCount\" // Read from response.totalCount\n   */\n  countKey?: string;\n\n  /**\n   * üì¶ Key containing the data array in response\n   * @default \"data\"\n   * @example \"items\" // Process response.items array\n   */\n  dataKey?: string;\n\n  /**\n   * üõ†Ô∏è Function to fetch data dynamically\n   * @param ctx - Request context\n   * @param pagination - Pagination details (page, limit, offset)\n   * @returns Promise resolving to an object with data and total count\n   * @example\n   * getDataSource: async (ctx, { page, limit }) => {\n   *   return db.find().skip((page-1)*limit).limit(limit);\n   * }\n   */\n  getDataSource?: <T extends Record<string, any> = {}>(\n    ctx: Context<T>,\n    pagination: { page: number; limit: number; offset: number },\n  ) => Promise<{ [key: string]: any }>;\n};\n```\n\n### `PaginationBodyType`\n\nStructure of the response body when `getDataSource` is used.\n\n```typescript\nexport type PaginationBodyType = {\n  [x: string]: any;\n  pagination: {\n    page: number;\n    limit: number;\n    totalItems: any;\n    totalPages: number;\n    hasNextPage: boolean;\n    hasPrevPage: boolean;\n    nextPage: number | null;\n    prevPage: number | null;\n  };\n};\n```\n\n---\n\n## Function\n\n### `paginationHandler`\n\nCreates a middleware function for handling pagination.\n\n#### Signature\n\n```typescript\nexport const paginationHandler = (options: PaginationOptions = {}): Middleware;\n```\n\n#### Parameters\n\n- **`options: PaginationOptions`** (Optional) ‚Äì Configuration object for pagination settings. Defaults to an empty object.\n\n#### Returns\n\n- **`Middleware`**: A function that processes pagination and either sets `ctx.body` or proceeds to `next()`.\n\n#### Description\n\nHandles pagination by:\n\n1. Parsing and sanitizing `page` and `limit` query parameters.\n2. Attaching pagination metadata to `ctx.pagination`.\n3. Optionally fetching data via `getDataSource`, constructing a `PaginationBodyType` response, and setting `ctx.body`.\n4. Supporting middleware chaining with `next()` when applicable.\n\n---\n\n## Examples\n\n### 1. Basic Usage\n\nAttaching pagination context without a data source.\n\n```typescript\napp.get(\"/users\", paginationHandler(), async (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  const users = await db.users.find().skip(offset).limit(limit);\n  const total = await db.users.countDocuments();\n  return ctx.json({ data: users, total });\n});\n```\n\n**Request**: `GET /users?page=2&limit=20`  \n**Effect**: Sets `ctx.pagination` with `page: 2`, `limit: 20`, `offset: 20`.  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 20 users */\n  ],\n  \"total\": 100\n}\n```\n\n---\n\n### 2. With Dynamic Data Source\n\nFetching data directly within the middleware.\n\n```typescript\napp.get(\n  \"/products\",\n  paginationHandler({\n    getDataSource: async (ctx, { page, limit, offset }) => {\n      const result = await Product.findAndCountAll({\n        offset,\n        limit,\n      });\n      return {\n        data: result.rows,\n        total: result.count,\n      };\n    },\n  }),\n  async (ctx) => {\n    return ctx.json(ctx.body); // Pass through the pre-set body\n  },\n);\n```\n\n**Request**: `GET /products?page=3&limit=10`  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 10 products */\n  ],\n  \"total\": 50,\n  \"pagination\": {\n    \"page\": 3,\n    \"limit\": 10,\n    \"totalItems\": 50,\n    \"totalPages\": 5,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 4,\n    \"prevPage\": 2\n  }\n}\n```\n\n---\n\n### 3. Custom Query Parameters and Keys\n\nUsing custom query names and response keys.\n\n```typescript\napp.get(\n  \"/articles\",\n  paginationHandler({\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n    countKey: \"totalArticles\",\n    dataKey: \"articles\",\n    getDataSource: async (ctx, { offset, limit }) => {\n      const articles = await Article.find().skip(offset).limit(limit);\n      return {\n        articles,\n        totalArticles: await Article.countDocuments(),\n      };\n    },\n  }),\n);\n```\n\n**Request**: `GET /articles?p=1&size=5`  \n**Response**:\n\n```json\n{\n  \"articles\": [\n    /* 5 articles */\n  ],\n  \"totalArticles\": 25,\n  \"pagination\": {\n    \"page\": 1,\n    \"limit\": 5,\n    \"totalItems\": 25,\n    \"totalPages\": 5,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": false,\n    \"nextPage\": 2,\n    \"prevPage\": null\n  }\n}\n```\n\n---\n\n### 4. Middleware Chaining\n\nCombining with additional middleware.\n\n```typescript\napp.get(\n  \"/orders\",\n  paginationHandler({\n    getDataSource: async (ctx, { offset, limit }) => {\n      const orders = await Order.find().skip(offset).limit(limit);\n      return {\n        data: orders,\n        total: await Order.countDocuments(),\n      };\n    },\n  }),\n  async (ctx) => {\n    const body = ctx.body as PaginationBodyType;\n    return ctx.json({\n      ...body,\n      timestamp: new Date().toISOString(),\n    });\n  },\n);\n```\n\n**Request**: `GET /orders?page=2&limit=10`  \n**Response**:\n\n```json\n{\n  \"data\": [\n    /* 10 orders */\n  ],\n  \"total\": 30,\n  \"pagination\": {\n    \"page\": 2,\n    \"limit\": 10,\n    \"totalItems\": 30,\n    \"totalPages\": 3,\n    \"hasNextPage\": true,\n    \"hasPrevPage\": true,\n    \"nextPage\": 3,\n    \"prevPage\": 1\n  },\n  \"timestamp\": \"2025-04-07T12:00:00.000Z\"\n}\n```\n\n---\n\n### 5. Input Sanitization\n\nHandling invalid inputs with limits.\n\n```typescript\napp.get(\n  \"/posts\",\n  paginationHandler({\n    maxLimit: 50,\n    getDataSource: async (ctx, { offset, limit }) => {\n      const posts = await Post.find().skip(offset).limit(limit);\n      return {\n        data: posts,\n        total: await Post.countDocuments(),\n      };\n    },\n  }),\n);\n```\n\n**Request**: `GET /posts?page=-1&limit=100`  \n**Effect**:\n\n- `page` sanitized to `1`.\n- `limit` capped at `50`.  \n  **Response**: Contains first 50 posts with metadata.\n\n---\n\n## Best Practices\n\n- **Data Source**: Use `getDataSource` for self-contained logic; omit it to delegate to subsequent middleware.\n- **Custom Keys**: Align `countKey` and `dataKey` with your API‚Äôs response structure.\n- **Limits**: Set `maxLimit` to prevent excessive resource usage.\n- **Chaining**: Use `next()` to integrate with additional middleware for response customization.\n- **Type Safety**: Extend `Context<T>` with custom properties (e.g., `ctx.user`) for type-safe access.\n\n---\n\n## Notes\n\n- **Response Format**: When `getDataSource` is used, `ctx.body` is set to a `PaginationBodyType` object.\n- **Middleware Flow**: Without `getDataSource`, only `ctx.pagination` is set, requiring `next()` for further processing.\n- **Compatibility**: Works with Node.js, Bun, and Deno runtimes.\n\n---\n"
    },
    {
      "id": 34,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "# **Core Components**\n\nThis section describes the foundational components for configuring and initializing the server, including environment variable loading, custom context definition, and server setup.\n\n---\n\n## **1. `loadEnv(basePath?: string)`**\n\n### **Purpose**\n\nLoads environment variables from `.env` files into a structured object or `process.env` for runtime access.\n\n### **Parameters**\n\n| Parameter  | Type     | Default                   | Description                                      |\n| ---------- | -------- | ------------------------- | ------------------------------------------------ |\n| `basePath` | `string` | Current working directory | Optional directory path containing `.env` files. |\n\n### **Supported Files**\n\nLoads variables from the following files in order of precedence (later files override earlier ones):\n\n- `.env` ‚Äì Base environment variables.\n- `.env.local` ‚Äì Local overrides.\n- `.env.[mode]` ‚Äì Mode-specific variables (e.g., `.env.production`).\n- `.env.[mode].local` ‚Äì Mode-specific local overrides (e.g., `.env.production.local`).\n\n### **Return Type**\n\n```ts\ninterface EnvVariables {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n  PORT?: string;\n  API_KEY?: string;\n  // Additional custom variables\n}\n```\n\n### **Example**\n\n```ts\nimport { loadEnv } from \"tezx/helper\";\n// Load from a custom directory\nconst env = loadEnv(\"./config\");\n\n// Access variables\nconst port = env.PORT || \"3000\"; // Using returned object\n// OR\nconst port = process.env.PORT; // Using process.env\n```\n\n---\n\n## **2. `CustomContext` Interface**\n\n### **Purpose**\n\nExtends the base context with application-specific properties for type-safe middleware and route handling.\n\n### **Definition**\n\n```ts\ninterface CustomContext {\n  user?: {\n    id: string;\n    roles: string[];\n  };\n  requestId: string;\n  // Add custom properties as needed\n}\n```\n\n### **Usage in Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return await next();\n});\n```\n\n- **Behavior**: Adds `requestId` and `user` to the context, accessible in subsequent middleware and routes.\n\n---\n\n## **3. Server Initialization**\n\n### **Type-Safe Configuration**\n\n```ts\nconst app = new Accelero<CustomContext>({\n  env: loadEnv(),\n  // Additional options\n});\n```\n\n### **Configuration Options**\n\n| Option | Type           | Default                     | Description                          |\n| ------ | -------------- | --------------------------- | ------------------------------------ |\n| `env`  | `EnvVariables` | `process.env` or `Deno.env` | Container for environment variables. |\n\n- **Note**: The `env` option overrides the default environment source (`process.env` or `Deno.env`).\n\n---\n\n## **Complete Workflow Example**\n\n### **1. Basic Setup**\n\n```ts\n// Load environment variables\nconst env = loadEnv();\n\n// Initialize server\nconst app = new Accelero({\n  env,\n  logger: logger,\n});\n\n// Middleware with env access\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") {\n    return ctx.status(401).text(\"Unauthorized\");\n  }\n});\n```\n\n- **Result**: Environment variables are accessible via `ctx.env` for request validation.\n\n### **2. Advanced Context Usage**\n\n```ts\ninterface AppContext {\n  user?: UserProfile;\n  requestId: string;\n  analytics: AnalyticsTracker;\n}\n\nconst app = new Accelero<AppContext>({\n  env: loadEnv(\"./env\"),\n});\n\n// Middleware extending context\napp.use(async (ctx, next) => {\n  ctx.analytics = new Analytics(ctx.env.ANALYTICS_KEY);\n  ctx.analytics.flush();\n  return await next();\n});\n```\n\n- **Result**: Custom context properties like `analytics` are available throughout the request lifecycle.\n\n---\n\n## **Best Practices**\n\n### **1. Environment Management**\n\nOrganize environment files by mode for clarity and maintainability:\n\n```plaintext\n# .env.production\nNODE_ENV=production\nPORT=443\nAPI_KEY=prod_abcdef\n\n# .env.development\nNODE_ENV=development\nPORT=3000\nAPI_KEY=dev_123456\n```\n\n- **Tip**: Use `.env.[mode]` to separate configurations for different environments.\n\n### **2. Security**\n\nPrevent sensitive data exposure by excluding local env files from version control:\n\n```plaintext\n# .gitignore\n.env.local\n.env.*.local\n```\n\n### **3. Conditional Logic**\n\nLeverage environment variables for feature toggles:\n\n```ts\nif (env.DEBUG === \"true\") {\n  enableDebugging();\n}\n```\n\n---\n"
    },
    {
      "id": 35,
      "path": "examples/basic",
      "name": "Basic",
      "folder": "Examples",
      "content": ""
    },
    {
      "id": 36,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "## File Upload\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files as File; // Extract the file from FormData\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Define file path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save file\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n"
    },
    {
      "id": 37,
      "path": "examples/lazy-load-modules",
      "name": "Lazy Load Modules",
      "folder": "Examples",
      "content": "### Enhanced Example: Role-Based Dynamic Module Loading with Caching and Lifecycle Hooks\n\nIn this example, we will use **Lazy Module Loader** middleware to load different modules based on the user's role. For instance, an admin might have access to the admin dashboard, while a user might access a user dashboard. We will also implement caching for performance optimization, validation to ensure modules are valid, and lifecycle hooks to track the loading process.\n\n---\n\n#### Middleware Configuration: Role-Based Module Loading with Caching\n\n```ts\nimport { Context, Middleware } from \"tezx\";\nimport { lazyLoadModules } from \"tezx/middleware\"; // Assuming lazyLoadModules is correctly imported\n\n// Define the middleware with advanced configurations\nconst roleBasedModuleLoader: Middleware = lazyLoadModules({\n  // Key function to determine the module to load based on user role\n  moduleKey: (ctx) => {\n    const role = ctx.user?.role; // Get user role from the context\n    if (role === \"admin\") {\n      return \"adminDashboardModule\"; // Admin's module\n    } else if (role === \"user\") {\n      return \"userDashboardModule\"; // User's module\n    }\n    return \"guestDashboardModule\"; // Default module for guests\n  },\n\n  // Function to dynamically load the appropriate module based on role\n  getModuleLoader: (ctx) => {\n    const moduleName = ctx.req.query.module || ctx.req.params.module; // Fallback to query/params\n    if (!moduleName) {\n      throw new Error(\"Module name is required.\");\n    }\n\n    // Dynamically import the correct module\n    return () => import(`./modules/${moduleName}.js`);\n  },\n\n  // Custom query parameter for module selection\n  queryKeyModule: \"module\", // Optional: Used when you pass `module` in the URL query params\n\n  // Store the module in the context under the 'module' key\n  moduleContextKey: \"module\", // The key under which the loaded module will be stored\n\n  // Enable caching for the modules to improve performance\n  enableCache: true,\n\n  // Custom in-memory cache storage (could be replaced with Redis in production)\n  cacheStorage: new Map<string, CacheItem<any>>(),\n\n  // Set TTL for cached modules (1 hour)\n  cacheTTL: 3600000, // 1 hour in milliseconds\n\n  // Injecting dependencies (e.g., services or configuration)\n  dependencies: {\n    loggingService: ctx.loggingService,\n    configService: ctx.configService,\n  },\n\n  // Lifecycle hooks to manage module loading and actions\n  lifecycleHooks: {\n    onLoad: (moduleName, ctx) => {\n      console.log(\n        `Loading module: ${moduleName} for user role: ${ctx.user?.role}`,\n      );\n    },\n    onCacheHit: (moduleName, module, ctx) => {\n      console.log(`Cache hit for module: ${moduleName}`);\n    },\n    onCacheSet: (moduleName, module, ctx) => {\n      console.log(`Module ${moduleName} cached successfully.`);\n    },\n    onComplete: (moduleName, module, ctx) => {\n      console.log(`Module ${moduleName} loaded successfully.`);\n    },\n    onError: (moduleName, error, ctx) => {\n      console.error(`Error loading module ${moduleName}:`, error);\n      ctx.body = { error: `Failed to load module: ${moduleName}` };\n      ctx.setStatus(500);\n    },\n  },\n\n  // Validate the loaded module before usage\n  validateModule: (module) => {\n    // Ensure the module has an 'init' method for initialization\n    return module && typeof module.init === \"function\";\n  },\n});\n\n// Register the middleware in the application\napp.use(roleBasedModuleLoader);\n```\n\n---\n\n#### Route Handling\n\nIn this part of the application, we‚Äôll set up a route where the module loaded dynamically based on the user role will be accessed. We will check if the module is present and then perform an action (e.g., call the `init` method of the module).\n\n```ts\n// Route to handle accessing the loaded module\napp.get(\"/dashboard\", async (ctx: Context) => {\n  const module = ctx.module; // The module is stored in the context by the middleware\n\n  if (module) {\n    try {\n      // Check if the module has the `init` method and invoke it\n      if (module.init) {\n        await module.init(ctx.dependencies, ctx); // Injecting dependencies like loggingService\n        return ctx.json({\n          message: `${module.constructor.name} initialized successfully.`,\n        });\n      } else {\n        throw new Error(`Module does not have an 'init' method.`);\n      }\n    } catch (error) {\n      ctx.setStatus(500);\n      return ctx.json({ error: error.message });\n    }\n  } else {\n    // If the module is not found in the context, return an error\n    ctx.setStatus(404);\n    return ctx.json({ error: \"Module not found.\" });\n  }\n});\n```\n\n---\n\n#### Example Modules\n\nHere are two simple example modules: `adminDashboardModule.js` and `userDashboardModule.js`.\n\n##### `adminDashboardModule.js`\n\n```js\nexport const adminDashboardModule = {\n  init: (dependencies, ctx) => {\n    // Initialization logic for the admin dashboard\n    console.log(\"Admin dashboard initialized.\");\n    dependencies.loggingService.log(\"Admin dashboard accessed.\");\n    return ctx.json({ message: \"Welcome to the Admin Dashboard.\" });\n  },\n};\n```\n\n##### `userDashboardModule.js`\n\n```js\nexport const userDashboardModule = {\n  init: (ctx, dependencies) => {\n    // Initialization logic for the user dashboard\n    console.log(\"User dashboard initialized.\");\n    dependencies.loggingService.log(\"User dashboard accessed.\");\n    return ctx.json({ message: \"Welcome to the User Dashboard.\" });\n  },\n};\n```\n\n---\n\n### Advanced Scenarios\n\n#### 1. **Module Loading Based on User Permissions**\n\nYou can enhance the logic by loading different modules depending on both the user's role and permissions. For example, an admin may have access to both the admin and user dashboard, while a regular user can only access the user dashboard.\n\n```ts\nmoduleKey: (ctx) => {\n  const role = ctx.user?.role;\n  const permissions = ctx.user?.permissions || [];\n\n  if (role === \"admin\") {\n    if (permissions.includes(\"viewAdminDashboard\")) {\n      return \"adminDashboardModule\";\n    } else {\n      return \"userDashboardModule\";\n    }\n  }\n  return \"userDashboardModule\"; // Regular users\n};\n```\n\n#### 2. **Custom Cache Storage Integration (e.g., Redis)**\n\nYou can replace the in-memory cache with a persistent cache solution, like Redis, to handle large-scale applications. Here‚Äôs an example of how to integrate Redis for caching:\n\n```ts\nimport { createClient } from \"redis\";\n\n// Initialize Redis client\nconst redisClient = createClient({ url: \"redis://localhost:6379\" });\n\nconst roleBasedModuleLoaderWithRedisCache: Middleware = lazyLoadModules({\n  // Use Redis as the cache storage\n  cacheStorage: redisClient,\n  enableCache: true,\n  cacheTTL: 3600000, // 1 hour\n\n  // Other configurations remain the same as above...\n});\n```\n\n#### 3. **Error Handling with Custom Response**\n\nYou can customize error handling in the lifecycle hooks for specific actions, such as logging the error or sending a custom response format.\n\n```ts\nlifecycleHooks: {\n  onError: (moduleName, error, ctx) => {\n    console.error(`Error loading module ${moduleName}:`, error);\n    ctx.setStatus(500);\n    return ctx.json({\n      error: `An error occurred while loading the module ${moduleName}. Please try again later.`,\n      details: error.message,\n    });\n  },\n},\n```\n\n#### 4. **Module Versioning**\n\nTo handle different versions of the same module, you can add versioning to the module names or configure the `getModuleLoader` function to load modules based on the requested version.\n\n```ts\ngetModuleLoader: (ctx) => {\n  const version = ctx.req.query.version || \"v1\"; // Default to v1\n  const moduleName = ctx.req.query.module;\n\n  if (!moduleName) {\n    throw new Error(\"Module name is required.\");\n  }\n\n  return () => import(`./modules/${moduleName}-${version}.js`);\n},\n```\n\n---\n"
    }
  ]
}