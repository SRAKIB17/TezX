{
  "structure": [
    {
      "originalPath": "2. Benchmarking.md",
      "id": 1,
      "name": "Benchmarking",
      "type": "file",
      "path": "benchmarking",
      "content": "# 🚀 Benchmarking Performance\n\nTezX is built for speed and efficiency, supporting multiple JavaScript runtimes. This section highlights real-world HTTP server benchmarks comparing TezX performance on **Bun**, **Deno**, and **Node.js** using `wrk`, a popular HTTP benchmarking tool.\n\n---\n\n## ⚙️ Test Setup\n\n* **Benchmark Tool:** [wrk](https://github.com/wg/wrk) (v4.1+)\n* **Test Duration:** 10 seconds\n* **Threads:** 12\n* **Concurrent Connections:** 400\n* **Endpoint:** `/` (simple text response)\n* **Ports:** Bun & Deno on `3001`, Node.js on `3000`\n\n---\n\n## 📊 Benchmark Summary\n\n| Runtime     | Requests/sec     | Avg Latency | Transfer Rate |\n| ----------- | ---------------- | ----------- | ------------- |\n| **Bun**     | **69,367 req/s** | 5.66 ms     | 9.59 MB/s     |\n| **Deno**    | 58,061 req/s     | 6.76 ms     | 9.30 MB/s     |\n| **Node.js** | 13,859 req/s     | 28.63 ms    | 2.17 MB/s     |\n\n---\n\n## 🔍 Detailed Output\n\n### 🟢 Bun\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 5.66 ms | Stdev: 663.46 µs | Max: 12.62 ms\nRequests/sec Avg: 5.86k | Max peak: 35.51k\nTotal Requests: 700,594 | Transfer: 96.88 MB\n```\n\n### 🟡 Deno\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 6.76 ms | Stdev: 791.19 µs | Max: 13.53 ms\nRequests/sec Avg: 4.91k | Max peak: 62.61k\nTotal Requests: 586,419 | Transfer: 93.95 MB\n```\n\n### 🔴 Node.js\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3000\n\nLatency     Avg: 28.63 ms | Stdev: 5.89 ms | Max: 120 ms\nRequests/sec Avg: 1.16k | Max peak: 1.38k\nTotal Requests: 138,852 | Transfer: 21.72 MB\n```\n\n---\n\n## 💡 Insights\n\n* **Bun** demonstrates exceptional throughput and low latency, benefiting from its highly optimized JavaScript runtime and native HTTP server.\n* **Deno** performs admirably, striking a balance between speed and robustness with modern runtime features.\n* **Node.js** remains a solid choice but shows higher latency and lower request capacity under heavy concurrency.\n\n---\n\n## 📈 Why Does This Matter?\n\n* **High Throughput:** Enables TezX to handle thousands of requests per second, ideal for real-time apps and APIs.\n* **Low Latency:** Improves user experience by reducing response delays.\n* **Runtime Flexibility:** TezX runs efficiently on multiple platforms — choose the runtime that best fits your deployment needs.\n\n---\n\n## 🔗 Further Reading\n\n* [Bun Official Website](https://bun.sh)\n* [Deno Official Website](https://deno.land)\n* [Node.js Official Website](https://nodejs.org)\n* [wrk Benchmark Tool](https://github.com/wg/wrk)\n"
    },
    {
      "originalPath": "3. Getting Started",
      "name": "Getting Started",
      "path": "getting-started",
      "type": "folder",
      "children": [
        {
          "originalPath": "0. Create app.md",
          "id": 2,
          "name": "Create app",
          "type": "file",
          "path": "getting-started/create-app",
          "content": "# ⚡ Create TezX\n\nEasily scaffold a new [TezX](https://github.com/tezxjs/tezx) project using official starter templates. Whether you're building a backend with WebSocket support or a TypeScript-powered server, `create-tezx` gets you started fast.\n\n---\n\n## 🚀 Quick Start\n\nStarter templates are available for common runtimes and package managers. Run one of the following commands:\n\n```bash\n# npm\nnpm create tezx@latest\nnpx create-tezx-app@latest\n# yarn\nyarn create tezx\n\n# pnpm\npnpm create tezx@latest\n\n# bun\nbun create tezx@latest\n\n# deno\ndeno run -A npm:create-tezx@latest\n````\n\nThis will launch an interactive setup. You can also skip prompts using CLI flags.\n\n---\n\n## ⚙️ CLI Options\n\nYou can skip interactive prompts by passing options directly via the command line.\n\n### `-t`, `--template <template>`\n\nUse a specific template by name.\n\n```bash\nnpm create tezx@latest my-app -- --template minimal\n```\n\n---\n\n### `-i`, `--install`\n\nAutomatically install dependencies after project setup.\n\n```bash\nnpm create tezx@latest my-app -- --install\n```\n\n---\n\n### `-p`, `--pm <npm|pnpm|bun|yarn>`\n\nChoose a package manager.\n\n```bash\nnpm create tezx@latest my-app -- --pm bun\n```\n\n---\n\n### `--ts`, `-ts`\n\nEnable TypeScript in the scaffolded project.\n\n```bash\nnpm create tezx@latest my-app -- --ts\n```\n\n---\n\n### `--env`, `--runtime`, `-env`, `-runtime`\n\nSet the runtime environment: `node`, `bun`, or `deno`.\n\n```bash\nnpm create tezx@latest my-app -- --runtime bun\n```\n\n---\n\n### `--y`, `--yes`, `-y`, `-yes`\n\nSkip all prompts using sensible defaults.\n\n```bash\nnpm create tezx@latest my-app -- --yes\n```\n\n---\n\n## 📁 Supported Templates\n\n> ✅ More templates coming soon!\n\n| Template        | Description                     | Flag Example               |\n| --------------- | ------------------------------- | -------------------------- |\n| `minimal`       | Minimal TypeScript setup        | `--template minimal`       |\n<!-- | `ws`            | WebSocket support (Node or Bun) | `--template ws`            | -->\n| `google-oauth2` | Google OAuth2 integration       | `--template google-oauth2` |\n| `github-oauth2` | GitHub OAuth2 integration       | `--template github-oauth2` |\n\n---\n\n## 🧪 Example Usage\n\n```bash\nnpm create tezx@latest my-app -- --template ws --ts --runtime node --install\n```\n\n```bash\nbun create tezx@latest auth-app -- --template google-oauth2 --pm bun --yes\n```\n\n---\n\n## 🧑‍💻 Author\n\nBuilt by [Rakibul Islam](https://github.com/srakib17)\nand [TezX](https://github.com/tezxjs/tezx) contributors.\n\n---\n"
        },
        {
          "originalPath": "1. Installation.md",
          "id": 3,
          "name": "Installation",
          "type": "file",
          "path": "getting-started/installation",
          "content": "# ⚡ TezX — High-Performance Backend Framework\n\n**TezX** is a **modern, ultra-fast, and lightweight JavaScript framework** for **Node.js, Bun, and Deno**.\nIt’s built for **speed, scalability, and developer happiness** — with clean APIs, built-in middleware, and static file serving.\n\n---\n\n## ✨ Why TezX?\n\n* 🚀 **Blazing Fast** — Optimized for concurrency and low-latency\n* ⚙️ **Minimal API** — Learn once, scale everywhere\n* 🛡️ **Secure by Default** — Best practices baked in\n* 🧩 **Powerful Middleware** — Composable and modular\n* 🗂️ **Zero-Config Static Files** — Serve instantly\n* 🌐 **Universal Runtime** — Runs on **Node**, **Bun**, and **Deno**\n\n---\n\n## 🚀 Quick Start\n\n### 1. Setup\n\n```bash\nmkdir my-tezx-app && cd my-tezx-app\nnpm init -y               # or bun init\nnpm install tezx          # or bun add tezx\n```\n\n### 2. Project Structure\n\n```bash\n.\n├── src/\n│   └── index.ts        # App entry\n├── public/             # Static files\n├── .env                # Env variables\n└── tsconfig.json       # TypeScript config\n```\n\n### 3. Create `.env`\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=super_secret_key\n```\n\n---\n\n## 🖥️ Basic Server (Node.js)\n\n```ts\n// src/index.ts\nimport { TezX } from \"tezx\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { logger } from \"tezx/middleware\";\nimport { createServer } from \"http\";\n\nconst env = loadEnv();\nconst app = new TezX({ env });\n\napp.use(logger());\napp.get(\"/\", (ctx) => ctx.text(\"Hello TezX!\"));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(env.PORT || 3000, () => {\n  console.log(`🚀 Server running → http://localhost:${env.PORT || 3000}`);\n});\n```\n\n---\n\n## ⚙️ Runtime-Specific Setup\n\n### ▶️ Bun\n\n```ts\nimport { wsHandlers } from \"tezx/bun\";\n\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: wsHandlers(),\n});\n```\n\n### ▶️ Deno\n\n```ts\nDeno.serve({ port: 3001 }, (req, connInfo) => app.serve(req, connInfo));\n```\n\n---\n\n## 🛠️ Dev Scripts\n\n### Node (`package.json`)\n\n```json\n\"scripts\": {\n  \"dev\": \"tsx watch src/index.ts\",\n  \"build\": \"tsc\",\n  \"start\": \"node dist/index.js\"\n}\n```\n\n### Bun\n\n```json\n\"scripts\": {\n  \"dev\": \"bun run --hot src/index.ts\"\n}\n```\n\n### Deno\n\n```json\n\"scripts\": {\n  \"dev\": \"deno run --watch --allow-all src/index.ts\"\n}\n```\n\n---\n\n## 🔧 Middleware Examples\n\n### Serve Static Files\n\n```ts\napp.static(serveStatic(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: { \"X-Custom-Header\": \"static\" },\n}));\n```\n\n### Enable CORS\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\napp.use(cors({\n  origin: [\"http://localhost:3000\"],\n  methods: [\"GET\", \"POST\"],\n}));\n```\n\n### Logging\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## 📦 TypeScript Setup\n\n### Build\n\n```bash\ntsc\n```\n\n### Example `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"nodenext\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"nodenext\",\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n---\n\n## 🛠️ Troubleshooting\n\n| Problem                     | Solution                           |\n| --------------------------- | ---------------------------------- |\n| `Cannot find module 'tezx'` | Run `npm install` / `bun add tezx` |\n| Port already in use         | Change `PORT` in `.env`            |\n| TypeScript errors           | Review `tsconfig.json`             |\n| `.env not loading`          | Ensure `.env` exists at root       |\n\n---\n\n## 💡 Pro Tip\n\nFor **real-time apps** or **serverless workloads**, run **TezX on Bun** for:\n✅ Faster cold starts\n✅ Lower memory footprint\n✅ High-concurrency handling\n\n---\n\n⚡ **TezX is your go-to framework** when you need speed, flexibility, and a clean developer experience.\n\n---\n"
        },
        {
          "originalPath": "2. Configuration.md",
          "id": 4,
          "name": "Configuration",
          "type": "file",
          "path": "getting-started/configuration",
          "content": "# 🚀 TezX Configuration Guide\n\nThe `TezX` framework is **highly configurable**, letting you fine-tune routing, environment handling, middleware, and even plug in your own **custom router**.\n\nThis guide explains every option you can pass to the `TezX` constructor, including **advanced use cases with `routeRegistry`**.\n\n---\n\n## ⚡ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  debugMode: true,\n  env,\n  basePath: \"/api\",\n});\n```\n\n---\n\n## 🧠 `TezXConfig` at a Glance\n\nHere’s the configuration shape:\n\n```ts\nexport type TezXConfig = {\n  debugMode?: boolean;\n  onPathResolve?: (pathname: string) => string;\n  routeRegistry?: RouteRegistry; // plug in custom router\n} & RouterConfig;\n\nexport type RouterConfig = {\n  env?: Record<string, string | number>;\n  basePath?: string;\n};\n```\n\n---\n\n## ⚙️ Available Options\n\n### 1. `debugMode`\n\n* **Type**: `boolean`\n* **Default**: `false`\n* **What it does**: Enables verbose request/error logging for development.\n\n```ts\nconst app = new TezX({ debugMode: true });\n```\n\n---\n\n### 2. `env`\n\n* **Type**: `Record<string, string | number>`\n* **What it does**: Inject environment variables into the app.\n\n```ts\nconst env = { PORT: \"3001\", API_KEY: \"secret\" };\nconst app = new TezX({ env });\nconsole.log(process.env.PORT); // \"3001\"\n```\n\n---\n\n### 3. `basePath`\n\n* **Type**: `string`\n* **What it does**: Prefixes all routes with a global path (ideal for **API versioning**).\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n\napp.get(\"/users\", (ctx) => ctx.text(\"v1 Users\"));\n// → accessible at /v1/users\n```\n\n---\n\n### 4. `onPathResolve`\n\n* **Type**: `(pathname: string) => string`\n* **What it does**: Hook to rewrite or normalize request paths before routing.\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => path.toLowerCase().replace(/\\/+$/, \"\"),\n});\n```\n\n---\n\n### 5. `routeRegistry`\n\n* **Type**: `RouteRegistry`\n* **What it does**: Supply your own **custom router** implementation.\n* **Why**: Lets you control route resolution, sub-routing, and middleware execution at a lower level.\n\n---\n\n## 🧩 Using a Custom Router (`routeRegistry`)\n\nYou can pass any router implementing the `RouteRegistry` interface to `TezX`.\n\nThis gives you **complete control** over how routes are matched and middleware is executed.\n\n### Example: Plugging in a Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\nconst customRouter = new PowerfulCustomRouter();\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: customRouter,\n});\n```\n\n### How It Works\n\n* `TezX` internally calls `routeRegistry.search(method, path)` to resolve handlers.\n* Middleware registered with `\"ALL\"` runs before method-specific handlers.\n* Supports all HTTP methods + route parameters.\n\n---\n\n## 🛠 Real-World Example: Sub-Routing with Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst router = new CustomRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  async (ctx) => ctx.text(\"Hello from custom router!\"),\n]);\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: router,\n  basePath: \"/api\",\n});\n\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Start server with Bun, Deno, or Node.js\n```\n\n---\n\n## 📦 Summary of Options\n\n| Option          | Type                               | Purpose                                  |\n| --------------- | ---------------------------------- | ---------------------------------------- |\n| `debugMode`     | `boolean`                          | Enable verbose request/error logging     |\n| `env`           | `Record<string, string \\| number>` | Inject environment variables             |\n| `basePath`      | `string`                           | Add global prefix to all routes          |\n| `onPathResolve` | `(pathname: string) => string`     | Normalize/transform paths before routing |\n| `routeRegistry` | `RouteRegistry`                    | Use a custom router implementation       |\n\n---\n\n## ✅ Best Practices\n\n* Use **`basePath`** for API versioning (e.g., `/v1`, `/v2`).\n* Inject a **custom router** (`routeRegistry`) for fine-grained control.\n* Use **`onPathResolve`** to normalize paths (lowercasing, trimming).\n* Pass **`env`** for consistent environment configs across runtimes.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "4. Environment",
      "name": "Environment",
      "path": "environment",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. NodeJS.md",
          "id": 5,
          "name": "NodeJS",
          "type": "file",
          "path": "environment/nodejs",
          "content": "\n# 🔧 TezX with Node.js – (`mountTezXOnNode`)\n\nBuild modern, middleware-driven APIs in Node.js using **TezX**, a lightweight server framework with first-class support for the Fetch API and native HTTP integration.\n\n---\n\n## ✅ Prerequisites\n\n* [Node.js](https://nodejs.org/) v16 or higher\n* TezX installed via `npm`, `yarn`, or `pnpm`\n\n```bash\n# Choose your preferred package manager\nnpm install tezx\n# or\nyarn add tezx\n# or\npnpm add tezx\n```\n\n---\n\n## 🗂️ Recommended Project Structure\n\n```bash\nproject/\n├── src/\n│   └── app.ts          # TezX app instance\n├── server.ts           # Native Node.js HTTP server\n├── .env                # Environment config\n```\n\n---\n\n## 🚀 Setting Up the Server (`server.ts`)\n\n```ts\nimport { createServer } from \"node:http\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { app } from \"./src/app\";\n\n// Load environment variables from `.env` into process.env\nloadEnv();\n\n// Create a native HTTP server\nconst server = createServer();\n\n// Mount TezX to handle requests\nmountTezXOnNode(app, server);\n\n// Start listening on the defined port\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`🚀 TezX is running at http://localhost:${PORT}`);\n});\n```\n\n---\n\n## 📄 Example `.env`\n\n```env\nPORT=3000\n```\n\n> Loaded via `loadEnv()` and available as `process.env.PORT`\n\n---\n\n## 🧪 Running the Server\n\n```bash\nnode server.ts\n# or with live-reloading (recommended for dev)\nnpx nodemon server.ts\n```\n\n---\n\n## 🧠 What Does `mountTezXOnNode` Do?\n\n`mountTezXOnNode(app, server)` enables TezX to work natively with Node.js by:\n\n* 🔁 **Transforming** Node’s `IncomingMessage` into a Fetch-compatible `Request`\n* 📤 **Passing** the request to your TezX app via `app.serve()`\n* 📥 **Converting** the Fetch `Response` back into a native HTTP response\n* 🚰 **Supporting** streaming (files, JSON, Server-Sent Events)\n* 🛡️ **Handling** edge cases like errors and connection aborts cleanly\n\n---\n\n## 📚 Feature Breakdown\n\n| Feature                        | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| `createServer()`               | Standard Node.js HTTP server                                         |\n| `mountTezXOnNode(app, server)` | Binds your TezX app to the server                                    |\n| Request conversion             | `IncomingMessage` → Fetch `Request`                                  |\n| Response conversion            | Fetch `Response` → `ServerResponse` (with stream support)            |\n| Streaming & SSE support        | Handles large or continuous data (e.g., file download, live updates) |\n| Error handling                 | Graceful 500 responses and logging                                   |\n| `.env` support via `loadEnv()` | Automatically loads environment variables                            |\n| Compatibility                  | Works with HTTP/1.x and HTTP/2 servers in Node.js                    |\n\n---\n\n## ✅ Benefits\n\n* 🔧 Native Node.js support without needing adapters\n* ✨ Clean Fetch API interface (like Deno or Bun)\n* 🧱 Minimal boilerplate, ideal for microservices or APIs\n* 🌊 Streaming-ready (e.g., `ctx.stream()`, SSE, large files)\n* 🧩 Works with existing Node.js tooling (e.g., Nodemon, PM2, ts-node)\n\n---\n\n## 🔁 Next Steps\n\n* Add routes using `.get()`, `.post()`, `.use()` on your `app` instance\n* Integrate `middleware`, `env`, and `logging` for full control\n* Explore WebSocket support (if using Bun/Deno) or custom WS handlers for Node.js\n\n---\n"
        },
        {
          "originalPath": "2. Bun.md",
          "id": 6,
          "name": "Bun",
          "type": "file",
          "path": "environment/bun",
          "content": "# ⚡ TezX + Bun Integration Guide\n\nLeverage **TezX** on the ultra-fast **Bun** runtime to build modern, scalable APIs with WebSocket support.\n\n---\n\n## ✅ Prerequisites\n\nMake sure you have:\n\n* [**Bun**](https://bun.sh) — modern all-in-one JavaScript runtime\n* [**TezX**](https://www.npmjs.com/package/tezx) — high-performance backend framework\n\nInstall TezX via Bun:\n\n```bash\nbun add tezx\n```\n\n---\n\n## 📁 Recommended Project Structure\n\n```bash\nproject/\n├── src/\n│   └── app.ts       # TezX app instance & routes\n├── server.ts        # Bun HTTP server entry point\n├── .env             # Environment variables\n```\n\n---\n\n## 🌐 Server Setup (with WebSocket Support)\n\n### `server.ts`\n\n```ts\nimport { loadEnv, wsHandlers } from \"tezx/bun\";\nimport { app } from \"./src/app\"; // TezX app instance\n\n// Load environment variables from .env\nloadEnv();\n\nBun.serve({\n  port: Number(process.env.PORT) || 3001,\n  reusePort: true, // Enables multi-process clustering\n  fetch(req, server) {\n    return app.serve(req, server); // Handle requests via TezX\n  },\n  websocket: wsHandlers({\n    // Optional WebSocket configure\n  })\n});\n\nconsole.log(`🚀 Server running at http://localhost:${process.env.PORT}`);\n```\n\n---\n\n## 📄 Example `.env`\n\n```env\nPORT=3001\n```\n\n> TezX automatically loads `.env` variables via `loadEnv()`. Accessible in your code via `process.env`.\n\n---\n\n## 🧪 Running the Server\n\nStart with live-reload during development:\n\n```bash\nbun run --watch server.ts\n```\n\nOr start normally:\n\n```bash\nbun run server.ts\n```\n\n---\n\n## 📚 Key Concepts & Features\n\n| Feature              | Description                                                       |\n| -------------------- | ----------------------------------------------------------------- |\n| `Bun.serve()`        | Launches the HTTP server (similar to Node.js `createServer`)      |\n| `reusePort: true`    | Enables multi-process (cluster) support for improved scalability  |\n| `fetch(req, server)` | Entry point for handling HTTP requests via TezX's `app.serve()`   |\n| `websocket`          | Manages WS lifecycle: `open`, `message`, `close` events           |\n| `ws.data`            | Attach custom session-specific data per WebSocket connection      |\n| `loadEnv()`          | Automatically loads `.env` variables for consistent configuration |\n\n---\n\n## 🚀 Pro Tips\n\n* **Clustering**: `reusePort: true` allows Bun to spawn multiple processes for high-concurrency workloads.\n* **WebSockets**: Use `wsHandlers()` to easily manage real-time connections and events.\n* **Environment management**: Always define `PORT` and other sensitive values in `.env`.\n* **Middleware-ready**: TezX middlewares work seamlessly in Bun for logging, security, and more.\n\n---\n"
        },
        {
          "originalPath": "3. Deno.md",
          "id": 7,
          "name": "Deno",
          "type": "file",
          "path": "environment/deno",
          "content": "# 🚀 TezX with Deno — Developer Guide\n\nBuild modern, high-performance HTTP applications using the TezX framework on Deno.\n\n---\n\n## ✅ Prerequisites\n\n* [Deno](https://deno.land) installed (v1.44+ recommended)\n* Basic knowledge of Deno’s permissions and module system\n* TezX app instance (`app`) created in `src/index.ts`\n\n---\n\n## 🛠️ Setup: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { app } from \"./src/index.ts\";\n\n// Load environment variables from `.env` and `.env.local`\nawait loadEnv();\n\n// Start the HTTP server\nDeno.serve({ port: Number(Deno.env.get(\"PORT\") || 5000) }, (req, connInfo) => {\n  return app.serve(req, connInfo);\n});\n```\n\n---\n\n## 📁 Project Structure\n\n```bash\nmy-tezx-project/\n├── src/\n│   └── index.ts        # Your TezX app instance\n├── .env                # Environment variables\n├── server.ts           # Entry point\n```\n\n---\n\n## 📦 Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=MyDenoTezXApp\n```\n\nTezX will automatically load:\n\n* `.env`\n* `.env.local` (if exists)\n\nThese are injected into both `Deno.env` and `process.env` (polyfilled where applicable).\n\n---\n\n## 📌 Accessing Env Variables\n\n```ts\nconst port = Number(Deno.env.get(\"PORT\") || 5000);\nconst appName = Deno.env.get(\"APP_NAME\");\n```\n\n---\n\n## 📝 Deno Permissions\n\nTo use `.env` and serve HTTP, ensure the following permissions:\n\n```bash\ndeno run --allow-net --allow-env --allow-read server.ts\n```\n\nAlternatively, for full access during development:\n\n```bash\ndeno run --allow-all server.ts\n```\n\n---\n\n## 🔁 Live Development (with Watch)\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## 📦 Optional: Use with NPM via `npm:` specifier\n\nIf you're integrating with an NPM-style toolchain or writing hybrid code:\n\n```ts\nimport { loadEnv } from \"npm:tezx/deno\";\n```\n\n---\n\n## 🔧 Pro Tip: Create a Run Script\n\nAdd to your `deno.json` for easier use:\n\n```json\n{\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-all server.ts\",\n    \"start\": \"deno run --allow-all server.ts\"\n  }\n}\n```\n\nThen run with:\n\n```bash\ndeno task dev\n```\n\n---\n\n## 📚 Additional Docs\n\n* TezX Docs: *coming soon*\n* Deno Docs: [https://deno.land/manual](https://deno.land/manual)\n* Deno Permissions: [https://deno.land/manual@latest/basics/permissions](https://deno.land/manual@latest/basics/permissions)\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "5.API",
      "name": "API",
      "path": "api",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. TezX",
          "name": "TezX",
          "path": "api/1-tezx",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. App.md",
              "id": 8,
              "name": "App",
              "type": "file",
              "path": "api/tezx/app",
              "content": "# ⚡ TezX – Application Initialization Guide\n\n`TezX` is a **high-performance, middleware-driven server framework** designed for **Deno**, **Bun**, and **Node.js**. It provides first-class support for:\n\n* Route handling & dynamic path matching\n* Middleware chaining at global and route level\n* Runtime-agnostic request lifecycle management\n\n---\n\n## 🚀 Quick Start (`server.ts`)\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { TezX } from \"tezx/core\";\nimport { CustomRouter } from \"./router.ts\"; // Your custom routes\nimport { logger } from \"tezx/middleware\";\n\n// Load environment variables\nawait loadEnv();\n\n// Initialize TezX app\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),        // Custom route tree\n  debugMode: true,                          // Enable detailed debug logs\n  onPathResolve: (path) => path             // Optional path normalization\n                    .replace(/\\/+$/, \"\")\n                    .toLowerCase(),\n});\n\n// Register global middleware\napp.use(logger);\n\n// Start server (Deno example)\nDeno.serve({ port: 5000 }, app.serve);\n```\n\n---\n\n## 📁 Recommended Project Structure\n\n```bash\nproject/\n├── middlewares/\n│   └── logger.ts\n├── router.ts\n├── server.ts\n├── .env\n└── src/\n    └── handlers/\n        └── home.ts\n```\n\n---\n\n## ⚙ TezX Configuration (`TezXConfig`)\n\n| Option          | Type                       | Description                                         |\n| --------------- | -------------------------- | --------------------------------------------------- |\n| `routeRegistry` | `Router`                   | Custom router implementing the `Router` interface   |\n| `debugMode`     | `boolean`                  | Enable detailed middleware-level logging            |\n| `onPathResolve` | `(path: string) => string` | Hook to normalize or rewrite incoming request paths |\n| `basePath`      | `string`                   | Optional prefix for all routes (default `/`)        |\n| `env`           | `Record<string, any>`      | Custom environment object available in each context |\n\n---\n\n## 🛡 Global Middleware Support\n\nMiddleware functions have access to the **context (`ctx`)** and **`next()`** callback:\n\n```ts\nimport { Middleware } from \"tezx\";\n\nexport const loggerMiddleware: Middleware = async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n};\n\n// Register globally\napp.use(loggerMiddleware);\n```\n\n---\n\n## ➕ Route-Level Middleware\n\n`TezX` supports **ALL-method middleware** for interceptors, guards, or path-specific logic:\n\n```ts\napp.when(\"ALL\", \"/admin/:section\", adminAuthMiddleware);\n```\n\n---\n\n## ❌ Custom 404 Handler\n\n```ts\napp.notFound((ctx) => ctx.status(404).text(\"🔍 Not Found\"));\n```\n\n---\n\n## 🛠 Custom Error Handling\n\n```ts\napp.onError((err, ctx) => {\n  console.error(\"Unhandled error:\", err.details);\n  return ctx.status(500).text(\"🔥 Internal Server Error\");\n});\n```\n\n---\n\n## 📦 Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=TezXApp\n```\n\nAccess variables anywhere in your app:\n\n```ts\nconst port = Deno.env.get(\"PORT\");\n```\n\n---\n\n## 🧪 Running the Server\n\n```bash\n# Standard run\ndeno run --allow-net --allow-read --allow-env server.ts\n\n# Live reload during development\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## 🧬 Runtime Compatibility\n\n| Feature    | Deno       | Bun        | Node.js   |\n| ---------- | ---------- | ---------- | --------- |\n| `.serve()` | ✅ Native   | ✅ Native   | ✅ Adapter |\n| Middleware | ✅ Yes      | ✅ Yes      | ✅ Yes     |\n| WebSocket  | ✅ Built-in | ✅ Built-in | ➖ Custom  |\n\n---\n\n## 💡 Summary\n\n| Feature      | Purpose                                        |\n| ------------ | ---------------------------------------------- |\n| `TezX`       | Main application & runtime-agnostic router     |\n| `use()`      | Register global middleware                     |\n| `when()`     | Register dynamic routes (including ALL-method) |\n| `notFound()` | Custom 404 handler                             |\n| `onError()`  | Global error handling                          |\n| `serve()`    | Entry point for Deno, Bun, or Node.js servers  |\n\n---\n"
            },
            {
              "originalPath": "2. Serve.md",
              "id": 9,
              "name": "Serve",
              "type": "file",
              "path": "api/tezx/serve",
              "content": "# 📡 `app.serve()` — TezX Runtime-Agnostic Request Handler\n\nThe `app.serve()` method is the **core universal handler** for processing HTTP requests in **TezX**. It adapts itself to different JavaScript runtimes by internally delegating requests to the appropriate logic.\n\n---\n\n## 🧠 What It Does\n\n* Accepts a native `Request` object (based on the Fetch API).\n* Optionally accepts runtime-specific arguments like `connInfo` (Deno), `req, res, server` (Node.js), or `server` (Bun).\n* Processes the request using your defined middleware and routes.\n* Returns a `Response` object.\n\nThis method allows you to **integrate TezX into any runtime** with **zero extra configuration**.\n\n---\n\n## ⚙️ How It Works Internally\n\n```ts\npublic async serve(req: Request, ...args: any[]): Promise<Response>\n```\n\n* `req`: A standard `Request` object.\n* `args`: Optional values like response objects, connections, or server instances.\n\n  * Parses the request.\n  * Creates a context.\n  * Executes middleware chain.\n  * Calls route handlers.\n  * Returns a finalized `Response`.\n\n---\n\n## 🖼️ Flow Overview\n\n```mermaid\nsequenceDiagram\n    participant Client as Client (Browser/HTTP)\n    participant TezX as TezX App\n    participant serve as app.serve()\n    participant handle as #handleRequest()\n    participant chain as #chain()\n    participant Middleware as Middlewares[]\n    participant Handler as Handlers[]\n\n    Client->>serve: HTTP Request\n    serve->>handle: Call #handleRequest(req, method, args)\n\n    handle->>handle: Validate Request (instanceof Request)\n    handle->>handle: Extract pathname & method\n    handle->>handle: Create Context(ctx)\n\n    alt Static file exists\n        handle-->>Client: Return static file Response\n    else Route found\n        handle->>handle: Search route in router\n        alt Only 1 handler, no middleware\n            handle->>Handler: Call handler(ctx)\n            Handler-->>handle: Response/ctx.body\n            handle-->>Client: Final Response\n        else Middleware/Handlers chain\n            handle->>chain: Call #chain(ctx, mLen, middlewares, hLen, handlers)\n            loop Dispatch(i)\n                chain->>Middleware: fn(ctx, next)\n                Middleware-->>chain: res / next()\n            end\n            chain->>Handler: fn(ctx, next)\n            Handler-->>chain: Response / ctx.body\n            chain-->>handle: Final ctx.res\n            handle-->>Client: Final Response\n        end\n    else No route match\n        handle-->>Client: 404 Not Found\n    end\n\n    handle->>handle: Catch errors\n    handle-->>Client: Error response (via #errorHandler)\n```\n\n---\n\n## ✅ Usage Examples\n\n### 🔷 Bun\n\n```ts\nimport {wsHandlers} from \"tezx/bun\";\n// Simple usage\napp.serve(req, server);\n\n// Full Bun server with WebSocket support\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: wsHandlers({})\n});\n```\n\n---\n\n### 🟨 Deno\n\n```ts\n// Basic serve function\nimport { serve } from \"https://deno.land/std/http/server.ts\";\n\nserve((req, connInfo) => app.serve(req, connInfo));\n\n// Or using modern API\nDeno.serve({ port: 8080 }, app.serve);\n```\n\n---\n\n### 🟦 Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode,toWebRequest } from \"tezx/node\";\n\n// Simple server mounting\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n\n// OR: manual conversion if needed\nconst response = await app.serve(toWebRequest(req), req, res, server);\n```\n\n---\n\n## 🔄 When to Use `app.serve()`\n\n| Scenario                       | Use `app.serve()`? |\n| ------------------------------ | ------------------ |\n| Bun’s `Bun.serve`              | ✅ Yes              |\n| Deno's `serve` or `Deno.serve` | ✅ Yes              |\n| Node's `http.createServer`     | ✅ Yes              |\n| Edge runtimes (like Vercel)    | ✅ Yes              |\n| Cloudflare Workers             | ✅ Yes              |\n\n---\n\n## 📝 Example\n\n```ts\nconst res = await app.serve(\n  new Request(\"http://localhost/hello\", { method: \"GET\" })\n);\nconsole.log(await res.text()); // → \"Hello TezX!\" (if route is defined)\n```\n\n---\n\n## 🛠 Tip for TypeScript Users\n\nSince `...args: any[]` can vary between environments, you can narrow down types like:\n\n```ts\n// For Deno\napp.serve(req, connInfo as Deno.ServeHandlerInfo);\n// For Node\napp.serve(req, res, server);\n```\n\n---\n\n## 🧪 Debugging Middleware Chain\n\nWant to trace how `app.serve()` is executing?\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Incoming request:\", ctx.method, ctx.url);\n  await next();\n});\n```\n\n---\n\n## 🔚 Summary\n\n* ✅ Cross-runtime request handler\n* 📦 Accepts Fetch API-compatible `Request`\n* 🔁 Handles middleware, routes, and returns `Response`\n* 💡 Plug-and-play with Node, Deno, and Bun\n\n> `app.serve()` is the glue between the **runtime** and your **application logic**.\n\n---\n"
            },
            {
              "originalPath": "3. TezX Error.md",
              "id": 10,
              "name": "TezX Error",
              "type": "file",
              "path": "api/tezx/tezx-error",
              "content": "# 🚨 TezXError\n\n`TezXError` is the **standard error type** used throughout **Tezx**.\nIt extends the native `Error` object and adds:\n\n* An **HTTP status code**\n* Optional **structured details payload** (metadata, validation issues, etc.)\n* Helper **static factories** for common HTTP errors\n\nThis makes it easy to throw consistent, structured errors in middleware, services, and route handlers.\n\n---\n\n## 📦 Import\n\n```ts\nimport { TezXError } from \"tezx\";\n```\n\n---\n\n## 🛠️ Constructor\n\n```ts\nnew TezXError(message: string, statusCode?: number, details?: any)\n```\n\n| Parameter    | Type     | Default     | Description                                      |\n| ------------ | -------- | ----------- | ------------------------------------------------ |\n| `message`    | `string` | —           | Human-readable error message.                    |\n| `statusCode` | `number` | `500`       | HTTP status code.                                |\n| `details`    | `any`    | `undefined` | Extra payload (e.g. validation errors, context). |\n\n---\n\n## ⚡ Static Helpers\n\nInstead of calling `new TezXError(...)` directly, you can use the built-in static methods for common error types:\n\n```ts\nTezXError.badRequest(message?, details?)\nTezXError.unauthorized(message?, details?)\nTezXError.forbidden(message?, details?)\nTezXError.notFound(message?, details?)\nTezXError.conflict(message?, details?)\nTezXError.internal(message?, details?)\n```\n\n### Example\n\n```ts\nthrow TezXError.notFound(\"User not found\", { userId: 42 });\n```\n\n---\n\n## 🔄 JSON Serialization\n\nEvery `TezXError` can be safely serialized to JSON using `.toJSON()` — useful for HTTP responses or logging.\n\n```ts\nconst err = TezXError.badRequest(\"Invalid email\", { field: \"email\" });\n\nconsole.log(err.toJSON());\n```\n\n#### Output\n\n```json\n{\n  \"error\": true,\n  \"message\": \"Invalid email\",\n  \"statusCode\": 400,\n  \"details\": { \"field\": \"email\" }\n}\n```\n\n---\n\n## ✅ Usage Examples\n\n### 1. Throw a Standard Error\n\n```ts\napp.get(\"/user/:id\", async (ctx) => {\n  const user = await db.findUser(ctx.params.id);\n  if (!user) throw TezXError.notFound(\"User not found\");\n  return ctx.json(user);\n});\n```\n\n---\n\n### 2. Custom Status Error\n\n```ts\nthrow new TezXError(\"Bad Gateway\", 502);\n```\n\n---\n\n### 3. Attach Validation Details\n\n```ts\nif (!email.includes(\"@\")) {\n  throw TezXError.badRequest(\"Invalid email format\", { field: \"email\" });\n}\n```\n\n---\n\n## 🧑‍💻 Developer Notes\n\n* Always throw `TezXError` instead of plain `Error` when working inside Tezx routes/middleware.\n* `details` is optional but very useful for structured API responses (e.g., validation errors, resource IDs).\n* Default fallback is `500 Internal Server Error`.\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "2. Context",
          "name": "Context",
          "path": "api/2-context",
          "type": "folder",
          "children": [
            {
              "originalPath": "2. Context.md",
              "id": 11,
              "name": "Context",
              "type": "file",
              "path": "api/context/context",
              "content": "# Context Wrapper\n\nThe `Context` class is the central abstraction for handling requests and responses in TezX. It wraps a request, manages headers, status codes, body, and provides helper methods for sending different types of responses including text, HTML, JSON, XML, files, and redirects.\n\n## Context lifecycle\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Runtime\n    participant TezXApp as TezX.app\n    participant Context as Context\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n\n    Client->>Runtime: HTTP request\n    Runtime->>TezXApp: app.serve(req, ...)\n    TezXApp->>Context: new Context(req, pathname, method, env, args)\n    TezXApp->>Middleware: run middlewares with ctx\n    Middleware-->>TezXApp: control returns\n    TezXApp->>Handler: call route handler(ctx)\n    Handler-->>TezXApp: sets ctx.body / returns value\n    TezXApp->>Runtime: finalize Response from ctx (headers, status, body)\n    Runtime-->>Client: HTTP response sent\n\n```\n\n---\n\n## **1. Properties**\n\n### 1. **`url: string`**\n\n```ts\nconsole.log(ctx.url); // \"https://example.com/listings?page=2\"\n// Purpose: Access the full request URL including query string\n```\n\n### 2. **`pathname: string`**\n\n```ts\nconsole.log(ctx.pathname); // \"/listings\"\n// Purpose: Get the pathname part of the URL without query parameters\n```\n\n### 3. **`method: string`**\n\n```ts\nif (ctx.method === \"POST\") { /* handle post */ }\n// Purpose: Check the HTTP method of the incoming request\n```\n\n### 4. **`env: T & Record<string, any>`**\n\n```ts\nctx.env.db = dbClient;\n// Purpose: Store and access environment-specific variables, like database clients\n```\n\n### 5. **`req: TezXRequest<Path>`**\n\n```ts\nconst body = await ctx.req.json();\n// Purpose: Access and parse the request body as JSON\n```\n\n### 6. **`headers: Headers`**\n\n```ts\nctx.headers.set(\"X-Custom\", \"value\");\nconsole.log(ctx.headers.get(\"content-type\"));\n// Purpose: Get or set headers for the request/response\n```\n\n### 7. **`body: any`**\n\n```ts\nctx.body = \"<h1>Hello</h1>\"; // Response body (get/set)\nconsole.log(ctx.body);\n// Purpose: Directly set or read the response body\n```\n\n### 8. **`status(code: number): this`**\n\n```ts\nctx.status(404).text(\"Not Found\"); \n// Purpose: Set the HTTP status code and chain response methods\n```\n\n### 9. **`setHeader(key, value, options?)`**\n\n```ts\nctx.setHeader(\"X-Powered-By\", \"tezx\");\nctx.setHeader(\"Set-Cookie\", \"id=1; Path=/; HttpOnly\", { append: true });\nctx.setHeader(\"Set-Cookie\", \"token=abcd; Path=/; HttpOnly\", { append: true });\nreturn ctx.text(\"headers set\");\n// Purpose: Add or append a single header to the response\n```\n\n---\n\n## **2. Methods for Responses**\n\n```ts\n// Plain text\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX 🚀\"));\n// Purpose: Send a simple text response\n\n// JSON API\napp.get(\"/status\", (ctx) => ctx.json({ ok: true, uptime: process.uptime() }));\n// Purpose: Send a JSON response, useful for APIs\n\n// HTML page\napp.get(\"/hello\", (ctx) => ctx.html`<h1>Hello, ${ctx.env.username ?? \"Guest\"}!</h1>`);\n// Purpose: Send HTML content with template literals\n\n// XML response\napp.get(\"/feed\", (ctx) => ctx.xml`<rss><channel><title>TezX Feed</title></channel></rss>`);\n// Purpose: Send XML responses for feeds or APIs\n```\n\n---\n\n## **2. Dynamic Params & Queries**\n\n```ts\n// Route parameter\napp.get(\"/user/:id\", (ctx) => {\n  return ctx.json({ userId: ctx.req.params.id });\n});\n// Purpose: Extract dynamic route parameters\n\n// Query string\napp.get(\"/search\", (ctx) => {\n  return ctx.json({ q: ctx.req.query.q || \"nothing\" });\n});\n// Purpose: Access query parameters from the URL\n```\n\n---\n\n## **3. Form Data / File Upload**\n\n```ts\n// Handle multipart form upload\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const file = form.get(\"file\"); // File | null\n  const username = form.get(\"username\");\n  \n  return ctx.json({ uploadedBy: username, hasFile: !!file });\n});\n// Purpose: Parse form data including file uploads\n```\n\n**HTML for testing:**\n\n```html\n<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"username\" placeholder=\"Your Name\" />\n  <input type=\"file\" name=\"file\" />\n  <button type=\"submit\">Upload</button>\n</form>\n```\n\n---\n\n## **4. Headers & Status**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  ctx.status(401)\n     .setHeader(\"WWW-Authenticate\", \"Bearer\")\n     .json({ error: \"Unauthorized\" });\n});\n// Purpose: Send a response with custom status and header\n\n// Multiple cookies\napp.get(\"/cookies\", (ctx) => {\n  ctx.setHeader(\"Set-Cookie\", \"id=1; Path=/; HttpOnly\", { append: true });\n  ctx.setHeader(\"Set-Cookie\", \"token=abc; Path=/; HttpOnly\", { append: true });\n  return ctx.text(\"Cookies set\");\n});\n// Purpose: Set multiple cookies in a response\n```\n\n---\n\n## **5. Redirects**\n\n```ts\napp.get(\"/old\", (ctx) => ctx.redirect(\"/new\"));          \n// Purpose: Temporary redirect (HTTP 302)\n\napp.get(\"/permanent\", (ctx) => ctx.redirect(\"/new\", 301)); \n// Purpose: Permanent redirect (HTTP 301)\n```\n\n---\n\n## **6. File Responses**\n\n```ts\n// Download as attachment\napp.get(\"/download\", (ctx) => ctx.download(\"./files/report.pdf\", \"report-2025.pdf\"));\n// Purpose: Force file download with a custom filename\n\n// Serve file inline (streaming)\napp.get(\"/video\", (ctx) => ctx.sendFile(\"./media/video.mp4\"));\n// Purpose: Stream a file for inline viewing\n\n// Serve with custom download filename\napp.get(\"/image\", (ctx) => ctx.sendFile(\"./media/pic.png\", { filename: \"photo.png\" }));\n// Purpose: Serve a file while specifying a download filename\n```\n\n---\n\n## **7. Chainable Response**\n\n```ts\napp.post(\"/create\", async (ctx) => {\n  const body = await ctx.req.json();\n  return ctx\n    .status(201)\n    .setHeader(\"x-resource-id\", \"42\")\n    .json({ message: \"Created\", data: body });\n});\n// Purpose: Demonstrate chaining of status, headers, and JSON response\n```\n\n---\n"
            },
            {
              "originalPath": "3. Context Propagation.md",
              "id": 12,
              "name": "Context Propagation",
              "type": "file",
              "path": "api/context/context-propagation",
              "content": "\n# 🧩 Context Propagation in TezX\n\nContext propagation allows **type-safe, request-scoped state sharing** across middleware and route handlers. Built on TypeScript, it enables:\n\n* Fine-grained control over request data\n* Modular architecture\n* Developer productivity with strict typing and tooling support\n\n---\n\n## **1. Conceptual Overview**\n\n1. Type-safe context shape\n2. Scoped to individual requests\n3. Mutable across middleware\n4. Extended through type composition\n\n---\n\n## **2. Defining a Typed Context**\n\nCreate a strongly-typed interface to define your request context structure:\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string;                    // Required unique identifier per request\n}\n```\n\n---\n\n## **3. Typed Router / App Instantiation**\n\nPass the context type to Router or TezX for strict type enforcement:\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX<CustomContext>();\n```\n\n---\n\n## **4. Injecting Data via Middleware**\n\nUse middleware to enrich the context during the request lifecycle:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.user = await authenticate(ctx.req);\n  return next();\n});\n\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n## **5. Typed Context Access in Handlers**\n\nAccess your context properties safely with full TypeScript support:\n\n```ts\napp.get(\"/me\", (ctx) => {\n  return ctx.json({\n    requestId: ctx.requestId,\n    email: ctx.user?.email ?? \"Anonymous\",\n  });\n});\n```\n\n---\n\n## **6. Context Composition**\n\nScale context by composing smaller domain-specific types:\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface MetricsContext {\n  logger: Logger;\n  startTime: number;\n}\n\ntype AppContext = AuthContext & MetricsContext;\n\nconst app = new TezX<AppContext>();\n```\n\n---\n\n## **7. Validation Middleware**\n\nEnsure critical fields are present at runtime:\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing request ID\");\n  return next();\n});\n```\n\n---\n\n## **8. Type Safety Guards**\n\nTypeScript prevents invalid usage:\n\n```ts\n// ❌ Property 'newProp' does not exist\nctx.newProp = \"value\";\n\n// ❌ Type mismatch\nctx.requestId = 123; // should be a string\n```\n\n---\n\n## **9. Optional Properties Handling**\n\nUse safe access patterns for optional context data:\n\n```ts\napp.get(\"/dashboard\", (ctx) => {\n  if (!ctx.user) return ctx.status(401).json({ error: \"Unauthorized\" });\n\n  return ctx.json({ email: ctx.user.email });\n});\n```\n\n---\n\n## **10. Best Practices**\n\n1. **Order Matters**\n   Set required context early and validate immediately:\n\n   ```ts\n   app.use((ctx, next) => {\n     ctx.requestId = crypto.randomUUID();\n     return next();\n   });\n\n   app.use((ctx, next) => {\n     if (!ctx.requestId) throw new Error(\"Missing ID\");\n     return next();\n   });\n   ```\n\n2. **Immutability**\n   Prefer immutable patterns when modifying nested objects:\n\n   ```ts\n   ctx.user = { ...ctx.user, email: \"updated@example.com\" };\n   ```\n\n3. **Testing with Mock Context**\n   Test logic in isolation with mock context:\n\n   ```ts\n   const mockCtx: CustomContext = {\n     requestId: \"req-test-001\",\n     user: { id: 1, email: \"test@example.com\" },\n   };\n\n   const response = await handler(mockCtx);\n   ```\n\n---\n\n## **11. Context Lifecycle Overview**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Incoming Request\n  Server->>Middleware A: Inject requestId\n  Middleware A->>Middleware B: Attach user\n  Middleware B->>Handler: Execute route\n  Handler->>Server: Prepare response\n  Server->>Client: Send response\n```\n\n---\n\n## **12. Why Context Propagation?**\n\n| Benefit            | Description                                                            |\n| ------------------ | ---------------------------------------------------------------------- |\n| 🔐 Type Safety     | Compile-time validation prevents access errors and invalid mutations   |\n| 🧩 Modularity      | Enables context slicing and extension across layers                    |\n| ⚙️ Maintainability | Clear structure for evolving app concerns like auth, logging, sessions |\n| 🚀 Scalability     | Composable and predictable patterns for large applications             |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Middleware",
          "name": "Middleware",
          "path": "api/3-middleware",
          "type": "folder",
          "children": [
            {
              "originalPath": "0. Merging Middlewares.md",
              "id": 13,
              "name": "Merging Middlewares",
              "type": "file",
              "path": "api/middleware/merging-middlewares",
              "content": "# ✅ Middleware Merging Strategy\n\nThis outlines how two router trees with nested middlewares are **intelligently merged** to preserve execution order and structure.\n\n---\n\n## 🔹 **Before Merging**\n\n### 🧭 **Root Router Tree (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n└── \"/test\"                             # path\n    ├── middlewares: [m1]              # existing middleware\n    └── children:\n        └── \"/test/1\"\n            ├── middlewares: [m2]\n```\n\n* `/test`: Contains middleware `[m1]`.\n* `/test/1`: A subroute with its own middleware `[m2]`.\n\n---\n\n## 🔹 **New Router Tree to Merge (`RouterMiddlewares`)**\n\n### 🌱 **Incoming Subrouter**\n\n```plaintext\nRouterMiddlewares\n└── \"/test\"\n    ├── middlewares: [m3]              # additional middleware to merge\n    └── children:\n        └── \"/test/2\"\n            ├── middlewares: [m4]\n```\n\n* `/test`: New middleware `[m3]` for same path.\n* `/test/2`: New child route under `/test`.\n\n---\n\n## 🔁 **After Merging (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n└── \"/test\"\n    ├── middlewares: [m1, m3]          # merged middlewares\n    └── children:\n        ├── \"/test/1\"\n        │   ├── middlewares: [m2]\n        └── \"/test/2\"\n            ├── middlewares: [m4]      # newly added\n```\n\n* Middleware arrays are **merged**: `[m1] + [m3] → [m1, m3]`.\n* All existing children remain untouched (`/test/1`).\n* New children are **appended** (`/test/2`).\n\n---\n\n## 🧠 **Mermaid Diagram: Middleware Merge Flow**\n\n```mermaid\nflowchart TD\n    A[\"/test (m1)\"] --> B[\"/test/1 (m2)\"]\n    A --> C[\"/test/2 (m4)\"]\n    A --- D[\"Merged Middlewares: m1 + m3\"]\n```\n\n* Shows how `/test` merges middlewares (`m1 + m3`) and retains all children.\n\n---\n\n## 🔧 **`when` API**\n\n```ts\n/**\n * Registers a route or middleware stack for a specific HTTP method.\n *\n * @param method - HTTP method (e.g., \"GET\", \"POST\", \"ALL\" for middleware).\n * @param path - Path to match (e.g., \"/api\", \"/test\").\n * @param handlers - Array of middleware or route handler functions.\n */\nwhen(method: HttpMethod | HttpMethod[], path: string, handlers: Handler[]): void;\n```\n\n* `method = \"ALL\"` → **middleware applied to all HTTP methods**.\n* Used internally when adding reusable or nested routers.\n\n---\n\n## 🧱 **Automatic Middleware Registration Logic**\n\nWhen merging routes via a registry:\n\n```ts\nif (middlewares?.length) {\n  this.#addRoute(\"ALL\", path, middlewares);\n}\n```\n\n* Ensures **all middleware layers** from incoming routers are preserved.\n* Middleware at the same path is **concatenated, not replaced**.\n\n---\n"
            },
            {
              "originalPath": "2. Middleware.md",
              "id": 14,
              "name": "Middleware",
              "type": "file",
              "path": "api/middleware/middleware",
              "content": "# 🧩 `use()` – Register Middlewares or Routers\n\nThe `use()` method in `TezX.Router` is a powerful, flexible API for registering middlewares and sub-routers — either globally or scoped to a specific path.\n\n## Sequence Diagram – Middleware / Router Chain\n\n```mermaid\nsequenceDiagram\n    participant App as TezX.App\n    participant Router as Router\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n    participant SubRouter as Sub-Router\n\n    App->>Router: use(path?, middlewares?, callback?/subRouter?)\n    Router->>Middleware: register middlewares\n    Router->>SubRouter: mount sub-router (if any)\n    \n    Note over Middleware, Handler: Marge Router\n\n    Client->>App: HTTP Request\n    App->>Router: match path + method\n    Router->>Middleware: execute each middleware(ctx, next)\n    Middleware-->>Router: await next()\n    Router->>Handler: call route handler(ctx)\n    Handler-->>Router: sets ctx.body / returns Response\n    Router-->>App: finalized response\n    App-->>Client: send Response\n```\n\n---\n\n## 📚 **Function Signature**\n\n```ts\nuse(...args: any[]): this;\n```\n\nSupports overloads like:\n\n```ts\n// Global middleware\nuse(middleware);\nuse([middleware1, middleware2]);\n\n// Scoped middleware\nuse(\"/path\", middleware);\nuse(\"/path\", [middleware1, middleware2]);\n\n// Middleware + handler or router\nuse(\"/path\", middleware, callback);\nuse(\"/path\", [middleware1], subRouter);\nuse(middleware, callback);\nuse([middleware], subRouter);\n```\n\n---\n\n## 📦 **Middleware Type**\n\n```ts\ntype Middleware<T = {}, Path extends string = any> = (\n  ctx: Ctx<T, Path>,\n  next: () => Promise<void>\n) => Response | Promise<Response | void>;\n```\n\n* Receives a request context (`ctx`) and a `next()` callback.\n* Can **modify `ctx`**, **short-circuit**, or **continue** the chain with `await next()`.\n\n---\n\n## 🧪 **Usage Examples**\n\n### 1. **Global Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Request started\");\n  await next();\n  console.log(\"Request ended\");\n});\n```\n\n### 2. **Multiple Global Middlewares**\n\n```ts\napp.use([\n  loggerMiddleware,\n  requestIDMiddleware,\n  timingMiddleware\n]);\n```\n\n### 3. **Scoped Middleware by Path**\n\n```ts\napp.use(\"/admin/:section?\", async (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    return ctx.status(403).text(\"Forbidden\");\n  }\n  return next();\n});\n```\n\n---\n\n### 4. **Scoped Middleware with Sub-Router**\n\n```ts\nconst authRouter = new Router();\n\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login page\"));\n\napp.use(\"/auth/:provider?\", authMiddleware, authRouter);\n```\n\n---\n\n## 🧠 **How It Works Internally**\n\nThe `use()` function:\n\n* Normalizes arguments into `path`, `middlewares`, and optional `router`.\n* Registers middlewares using:\n\n```ts\nthis.#addRoute(\"ALL\", path, middlewares);\n```\n\n* If a `Router` is passed, it’s mounted using:\n\n```ts\nthis.addRouter(path, router);\n```\n\n* Middleware paths support **all route param syntaxes** (`:id`, `:id?`, `*wildcard`).\n\n---\n\n## 🔁 **Middleware Chaining**\n\nAll middleware functions follow a **chainable model** via `next()`:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.startTime = Date.now();\n  await next();\n  const ms = Date.now() - ctx.startTime;\n  console.log(`${ctx.method} ${ctx.pathname} - ${ms}ms`);\n});\n```\n\n* Each middleware may perform actions **before or after** the next one.\n* If `next()` is not called, the chain stops.\n\n---\n\n## 🧱 **Router Composition**\n\n```ts\nconst v1 = new Router();\nv1.use(\"/users\", authMiddleware, userRouter);\n\nconst v2 = new Router();\nv2.use(\"/products\", productRouter);\n\napp.use(\"/api\", [loggerMiddleware], v1);\napp.use(\"/api\", v2);\n```\n\n---\n\n## 🛡️ **Best Practices**\n\n| Tip                           | Description                                        |\n| ----------------------------- | -------------------------------------------------- |\n| ✅ Use scoped middleware       | For route-specific logic like authentication       |\n| ✅ Keep global middleware pure | Logging, CORS, rate limiting, etc.                 |\n| ✅ Chain with `next()`         | Enables layered composition                        |\n| ✅ Compose routers             | Modularize APIs or feature groups                  |\n| ✅ Handle errors               | Wrap logic in try/catch or global error middleware |\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "4. Router",
          "name": "Router",
          "path": "api/4-router",
          "type": "folder",
          "children": [
            {
              "originalPath": "3. Router.md",
              "id": 15,
              "name": "Router",
              "type": "file",
              "path": "api/router/router",
              "content": "# 🚀 TezX Router\n\n**TezX Router** is the core of the **tezx** web framework. It offers a **high-performance, flexible, and modern** way to handle:\n\n* HTTP routing\n* Middleware chaining\n* Static assets\n* Sub-routers\n* Server-Sent Events (SSE)\n\nWhether you’re building small APIs or large modular applications, TezX Router provides the structure and tools you need.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Client as HTTP Client\n    participant ParentRouter as Parent Router<T>\n    participant SubRouter as Sub-Router<T>\n    participant Static as Static File Handler\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n\n    note over ParentRouter, SubRouter: Step 0: Merge sub-router routes into parent\n    ParentRouter->>SubRouter: Read routes & staticFile map\n    SubRouter-->>ParentRouter: Copy routes & staticFile entries\n\n    Client->>ParentRouter: HTTP Request (method + path)\n    \n    alt Static file match\n        ParentRouter->>Static: check staticFile map for \"METHOD path\"\n        Static-->>ParentRouter: return file response\n        ParentRouter-->>Client: send static response\n    else Route match\n        ParentRouter->>Middleware: execute global middlewares(ctx, next)\n        Middleware-->>ParentRouter: await next()\n        \n        alt Sub-router route (merged into parent)\n            ParentRouter->>Handler: execute sub-router's handler(ctx)\n            Handler-->>ParentRouter: return ctx.body / Response\n        else Direct route\n            ParentRouter->>Handler: execute parent route handler(ctx)\n            Handler-->>ParentRouter: return ctx.body / Response\n        end\n\n        ParentRouter-->>Client: send response\n    end\n```\n\n---\n\n## 1. Installation & Initialization\n\n```ts\nimport { Router } from \"tezx\";\n\n// Create a new Router instance\nconst app = new Router({\n  basePath: \"/\",            // Base path for all routes (default: \"/\")\n  env: { NODE_ENV: \"prod\" } // Environment variables accessible in middleware\n});\n```\n\n### Router Configuration Options\n\n```ts\nexport type RouterConfig = {\n  /** Custom route registry used internally */\n  routeRegistry?: RouteRegistry;\n\n  /** Optional segments handling (ignored by RadixRouter internally) */\n  optionalSegments?: {\n    expand?: boolean;           // Always true internally\n    maxExpansion?: number;      // Maximum number of optional segment permutations (default: 6)\n  };\n\n  /** Environment variables for this router instance */\n  env?: Record<string, string | number>;\n\n  /** Base path prefix for all routes (e.g., \"/api/v1\") */\n  basePath?: string;\n};\n```\n\n**Notes:**\n\n* Optional segments (`?`) expand internally into all permutations.\n* Use `basePath` to mount routers under a sub-path.\n\n---\n\n## 2. Core Concepts\n\nTezX Router revolves around a few key ideas:\n\n1. **Route registration** — Define endpoints with HTTP verbs (`GET`, `POST`, etc.).\n2. **Middleware chaining** — Reusable pre-processing or validation logic.\n3. **Route grouping** — Organize routes under common prefixes.\n4. **Sub-routers** — Modularize large APIs by mounting routers on paths.\n5. **Static file serving** — Serve assets like images, CSS, and JS.\n\n---\n\n## 3. Defining Routes\n\n### 3.1 Basic Route\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  ctx.body = \"Hello from TezX!\";\n});\n```\n\n* `ctx` contains request info, parameters, and response methods.\n* Set responses using `ctx.body`, `ctx.text()`, or `ctx.json()`.\n\n---\n\n### 3.2 Route with Middleware\n\n```ts\nconst auth = async (ctx, next) => {\n  if (!ctx.user) {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  await next();\n};\n\napp.get(\"/profile\", auth, (ctx) => {\n  return ctx.json({ user: ctx.user });\n});\n```\n\n* Middleware is a function `(ctx, next)` that can halt or continue the request chain.\n* Call `await next()` to proceed to the next middleware or handler.\n\n---\n\n### 3.3 Multiple Middlewares\n\n```ts\nconst log = (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  return next();\n};\n\nconst adminOnly = (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    ctx.setStatus = 403;\n    return ctx.text(\"Forbidden\");\n  }\n  return next();\n};\n\napp.get(\"/admin/dashboard\", [auth, log, adminOnly], (ctx) => {\n  return { body: \"Admin Dashboard\" };\n});\n```\n\n* Middleware can be applied as an array for **chained execution**.\n* Allows reusable, composable logic like logging, authentication, or authorization.\n\n---\n\n## 4. HTTP Methods\n\nTezX Router supports standard HTTP verbs:\n\n```ts\napp.get(\"/path\", ...middlewares, handler)\napp.post(\"/path\", ...middlewares, handler)\napp.put(\"/path\", ...middlewares, handler)\napp.patch(\"/path\", ...middlewares, handler)\napp.delete(\"/path\", ...middlewares, handler)\napp.options(\"/path\", ...middlewares, handler)\napp.all(\"/path\", ...middlewares, handler);\n```\n\nExample:\n\n```ts\napp.post(\"/submit\", (ctx) => {\n  const data = ctx.request.body;\n  return ctx.json({ received: data });\n});\n```\n\n```ts\napp.all(\"/path\", ...middlewares, handler);\n```\n\n**Explanation:**\n\n* `app.all()` is primarily used to **register middleware** that should run for **all HTTP methods** (GET, POST, PUT, DELETE, etc.) for a given path.\n* Middleware functions in `...middlewares` are executed **in order** before the final `handler`.\n* **Optional route parameters are not supported** in `app.all()` — the path must be **explicit and exact**.\n* Use it to apply global or reusable middleware logic on a specific path.\n\n**Example:**\n\n```ts\n// Middleware that runs for all methods on \"/dashboard\"\napp.all(\"/dashboard\", authMiddleware, logMiddleware, (ctx) => {\n  return ctx.text(\"Dashboard accessed!\");\n});\n```\n\n> **Note:** `.all()` is mainly used for middleware or global handlers, not optional parameters.\n\n---\n\n## 5. Serving Static Files\n\n```ts\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n\napp.static(serveStatic(\"/assets\", \"./public/assets\"));  // Serve under route\napp.static(serveStatic(\"./public\"));                     // Serve at root\n```\n\n* Use for images, CSS, JS, or any public assets.\n\n---\n\n## 6. Grouping Routes\n\n```ts\napp.group(\"/api/v1\", (router) => {\n  router.get(\"/users\", (ctx) => { /*...*/ });\n  router.post(\"/users\", (ctx) => { /*...*/ });\n});\n```\n\n* Groups create **scoped sub-routers** for modular organization.\n* You can attach middlewares to the group.\n\n---\n\n## 7. Mounting Sub-Routers\n\n```ts\nconst adminRouter = new Router();\nadminRouter.use(auth); // Auth applies to all admin routes\n\nadminRouter.get(\"/dashboard\", (ctx) => ctx.text(\"Welcome, admin!\"));\n\napp.addRouter(\"/admin\", adminRouter);\n```\n\n* Sub-routers can have their own middlewares, groups, and routes.\n* `addRouter()` mounts the sub-router at a base path.\n\n---\n\n## 8. Middleware Usage Tips\n\n* Middleware signature: `async (ctx, next) => { ... }`\n* Always call `await next()` unless you want to **short-circuit**.\n* Attach data to `ctx` (e.g., `ctx.user = {...}`).\n* Arrays of middlewares can be applied to routes, groups, or routers.\n\n---\n\n## 9. Full Example Mini App\n\n```ts\nimport { Router } from \"tezx\";\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n\nconst app = new Router();\n\nconst logger = async (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  await next();\n};\n\nconst auth = async (ctx, next) => {\n  const token = ctx.headers[\"authorization\"];\n  if (token !== \"secret-token\") {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  ctx.user = { name: \"Alice\" };\n  await next();\n};\n\napp.use(logger);\n\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX Router!\"));\n\napp.group(\"/api\", (api) => {\n  api.get(\"/public\", (ctx) => ctx.text(\"Public API data\"));\n  api.get(\"/private\", auth, (ctx) =>\n    ctx.text(`Hello ${ctx.user.name}, this is private data.`)\n  );\n});\n\napp.static(serveStatic(\"/static\", \"./public\"));\n\nexport default app;\n```\n\n---\n\n## Troubleshooting & Gotchas\n\n* **Optional param expansion:** RadixRouter internally expands optional segments. Overuse can create many permutations; tune `maxExpansion`.\n* **Order matters:** Middleware order (global → group → route) determines execution order. Register global middleware early.\n* **Group parameter collisions:** Avoid consecutive unnamed optional params — prefer a fixed segment between them.\n"
            },
            {
              "originalPath": "4. Router Merging.md",
              "id": 16,
              "name": "Router Merging",
              "type": "file",
              "path": "api/router/router-merging",
              "content": "# 🔀 **TezX Router Merging**\n\n## 📘 Overview\n\nTezX allows merging multiple routers into a **parent app**, enabling modular route management. This ensures:\n\n* **Non-destructive merges** — existing routes remain intact.\n* **Hierarchical route structure** — sub-routers can maintain their own nested routes.\n* **Safe middleware scoping** — each router can define its own middlewares.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant ParentRouter\n    participant SubRouter\n    participant RouteRegistry\n\n    Note over ParentRouter, SubRouter: Merge process begins\n    ParentRouter->>SubRouter: addRouter(\"/prefix\", subRouter)\n    SubRouter->>RouteRegistry: Iterate all sub-router routes\n    RouteRegistry-->>ParentRouter: Return each route (method, pattern, handlers)\n    ParentRouter->>RouteRegistry: Add each route to parent registry\n    Note over ParentRouter: ParentRouter now contains:\\n- its original routes\\n- all sub-router routes\n```\n\n---\n\n## 🧭 Terminology\n\n| Term              | Meaning                                                                   |\n| ----------------- | ------------------------------------------------------------------------- |\n| **Parent Router** | The main `TezX` instance or a Router that aggregates multiple sub-routers |\n| **Sub-Router**    | A router that contains its own routes & middleware                        |\n| **Merged Router** | The result of merging sub-routers into the parent router                  |\n\n---\n\n## 📂 Pre-Merge Example\n\nParent router before adding any sub-router:\n\n```bash\nParent Router:\n├── /test\n│   ├── GET → handler1\n│   └── /1\n│       ├── GET → handler2\n```\n\n---\n\n## ➕ Adding a Sub-Router\n\nSub-router structure:\n\n```bash\nSub-Router:\n├── /products\n│   └── /2\n│       ├── GET → handler3\n```\n\n---\n\n## ✅ After Merge\n\nMerged router structure:\n\n```bash\nMerged Router:\n├── /test\n│   ├── GET → handler1\n│   └── /1\n│       ├── GET → handler2\n├── /products\n│   └── /2\n│       ├── GET → handler3\n```\n\n> All routes remain intact and merge **non-destructively**.\n\n---\n\n## 🧪 Code Example\n\n```ts\nimport { TezX, Router } from \"tezx\";\n\n// Parent router\nconst app = new TezX();\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// Sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge the routers into parent\napp.use(\"/\", productRouter);\n```\n\n---\n\n## 🧑‍💻 Best Practices\n\n### 1. **Use Unique Prefixes**\n\nPrevent conflicts by using distinct prefixes:\n\n```ts\nconst authRouter = new Router();\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login\"));\n\napp.use(\"/auth\", authRouter);\n// Resulting route: /auth/login\n```\n\n---\n\n### 2. **Middleware Hygiene**\n\nEach router can define its own middlewares:\n\n```ts\nconst api = new Router();\n\napi.use((ctx, next) => {\n  ctx.setHeader(\"x-api\", \"v1\");\n  return next();\n});\n\napi.get(\"/status\", (ctx) => ctx.json({ ok: true }));\n\napp.use(\"/api\", api);\n```\n\n> Requests to `/api/status` automatically pass through the API middleware.\n\n---\n\n### 3. **Inspect Route Tree**\n\nLogging can help debug route structure:\n\n```ts\nconsole.log(app.routes);\n// Outputs a tree-like structure for verification\n```\n\n---\n\n### 4. **Safe Re-Merge Patterns**\n\nAvoid defining the same path across multiple routers:\n\n```ts\n// ❌ Avoid\nrouter1.get(\"/ping\", ...);\nrouter2.get(\"/ping\", ...);\n\n// ✅ Use prefixes\napp.use(\"/api\", router1);\napp.use(\"/public\", router2);\n```\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "5. Request",
          "name": "Request",
          "path": "api/5-request",
          "type": "folder",
          "children": [
            {
              "originalPath": "1. Request.md",
              "id": 17,
              "name": "Request",
              "type": "file",
              "path": "api/request/request",
              "content": "# 📦 TezXRequest — Request Wrapper\n\n`TezXRequest` is a thin wrapper around the native `Request` object.\nIt makes working with **query params, route params, headers, body parsing, and file uploads** straightforward.\n\n---\n\n```mermaid\nflowchart TD\n    A[Incoming HTTP Request] --> B[TezXRequest Wrapper]\n\n    B --> C1[URL]\n    B --> C2[Method]\n    B --> C3[Pathname]\n    B --> C4[Params]\n    B --> C5[Query]\n    B --> C6[Headers]\n    B --> C7[Body Parsing]\n\n    C7 --> D1[Raw Text]\n    C7 --> D2[JSON]\n    C7 --> D3[FormData]\n    D3 --> D4[Files]\n```\n\n**Explanation:**\n\n* Request comes in → wrapped by `TezXRequest`\n* You can directly access **URL, method, pathname, params, query, headers**\n* For the body → you can parse as **text, JSON, or FormData** (with file support)\n\n---\n\n## 🔹 Properties\n\n### `url: string`\n\nFull request URL.\n\n```ts\nctx.req.url; \n// \"https://example.com/api/user?id=5\"\n```\n\n---\n\n### `method: HTTPMethod`\n\nHTTP method (GET, POST, PUT, etc).\n\n```ts\nctx.req.method; \n// \"POST\"\n```\n\n---\n\n### `pathname: string`\n\nURL path without query string.\n\n```ts\nctx.req.pathname; \n// \"/api/user\"\n```\n\n---\n\n### `params: Record<string, string>`\n\nRoute parameters extracted from the router.\n\n```ts\n// Route: /user/:id\nctx.req.params.id; \n// \"123\"\n```\n\n---\n\n### `query: Record<string, string>`\n\nQuery string parsed into a plain object.\n\n```ts\n// URL: /search?q=js&page=2\nctx.req.query.q;    // \"js\"\nctx.req.query.page; // \"2\"\n```\n\n---\n\n## 🔸 Methods\n\n### `header(): Record<string, string>`\n\nGet all request headers.\n\n```ts\nconst headers = ctx.req.header();\nconsole.log(headers[\"content-type\"]); \n// \"application/json\"\n```\n\n---\n\n### `header(name: string): string | undefined`\n\nGet a specific header (case-insensitive).\n\n```ts\nconst type = ctx.req.header(\"content-type\");\n// \"application/json\"\n```\n\n---\n\n### `text(): Promise<string>`\n\nRead raw body as a string.\n\n```ts\nconst body = await ctx.req.text();\nconsole.log(body); \n// '{\"username\":\"rakib\"}'\n```\n\n---\n\n### `json<T = any>(): Promise<T>`\n\nParse body as JSON. Returns `{}` if content-type isn’t JSON or parsing fails.\n\n```ts\nconst data = await ctx.req.json<{ username: string }>();\nconsole.log(data.username); \n// \"rakib\"\n```\n\n---\n\n### `formData(): Promise<FormData>`\n\nParse body as `FormData`. Supports:\n\n* `application/x-www-form-urlencoded`\n* `multipart/form-data` (with file uploads)\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.get(\"name\")); \n// \"Rakib\"\n\nconsole.log(form.getAll(\"skills\")); \n// [\"js\", \"ts\"]\n```\n\n---\n\n### ✅ `useFormData<T>()`\n\nType-safe helper for form parsing.\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nconst data = await useFormData<{ name: string; file: File }>(ctx);\n\nconsole.log(data.name); // \"Rakib\"\nconsole.log(data.file); // File object\n```\n\n---\n\n## 🛠 Developer Tips\n\n* Use `params` for **dynamic routes**\n* Use `query` for **URL query strings**\n* Use `header(\"content-type\")` before parsing body\n* Use `useFormData` if you need **typed + file-safe** handling\n* Always `await` parsing methods (`text()`, `json()`, `formData()`)\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "6. Response.md",
          "id": 18,
          "name": "Response",
          "type": "file",
          "path": "api/response",
          "content": "# 🔁 Response Handling in TezX\n\nThe **TezX** framework provides a **rich response system** via the `ctx` object.\nThis system makes it easy to return **JSON, HTML, text, XML, files, redirects, and custom responses** with a clean API.\n\n---\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Handler as Route Handler\n    participant Ctx as ctx\n    participant Runtime as Runtime\n    participant Client as HTTP Client\n\n    Handler->>Ctx: ctx.json({..}) / ctx.html(..) / ctx.text(..) / ctx.xml(..) / ctx.send(..)\n    Ctx->>Runtime: prepare Response object\n    Runtime-->>Client: HTTP Response (with proper headers, status, body)\n```\n\n## 🧩 Core Type Definitions\n\n```ts\nexport type NextCallback = () => Promise<void>; // continue middleware chain\n\nexport type HttpBaseResponse = Response | Promise<Response>;\n\nexport type Ctx<T extends Record<string, any> = {}, Path extends string = any> =\n  Context<T, Path> & T & Record<string, any>;\n\nexport type Callback<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>) => HttpBaseResponse;\n\nexport type Middleware<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>, next: NextCallback) =>\n    HttpBaseResponse | Promise<HttpBaseResponse | void> | NextCallback;\n\nexport type ErrorHandler<T = {}> =\n  (err: Error, ctx: Ctx<T>) => HttpBaseResponse;\n```\n\n---\n\n## ✅ Native Response\n\nFor full control, return a native `Response`:\n\n```ts\napp.get(\"/data\", (ctx) => {\n  ctx.setHeader(\"Content-Type\", \"text/plain\" )\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: ctx.header(),\n  });\n});\n```\n\n---\n\n## 🚀 Response Utilities on `ctx`\n\n### `ctx.json(body, status?, headers?)`\n\nSend JSON.\n\n```ts\napp.get(\"/json\", (ctx) => ctx.json({ success: true }, 200));\n```\n\n* **Content-Type**: `application/json`\n\n---\n\n### `ctx.html(html, status?, headers?)`\n\nSend HTML.\n\n```ts\napp.get(\"/html\", (ctx) => ctx.html(\"<h1>Welcome</h1>\"));\n```\n\n* **Content-Type**: `text/html`\n\n---\n\n### `ctx.text(text, status?, headers?)`\n\nSend plain text.\n\n```ts\napp.get(\"/plain\", (ctx) => ctx.text(\"Just text\"));\n```\n\n* **Content-Type**: `text/plain`\n\n---\n\n### `ctx.xml(xml, status?, headers?)`\n\nSend XML.\n\n```ts\napp.get(\"/xml\", (ctx) => ctx.xml(\"<note><msg>Hi</msg></note>\"));\n```\n\n* **Content-Type**: `application/xml`\n\n---\n\n### `ctx.send(body, status?, headers?)`\n\nSmart responder (auto-detects type).\n\n```ts\napp.get(\"/send\", (ctx) => ctx.send({ user: \"admin\" }));\n```\n\n* `object` → JSON\n* `string` → plain text\n* `Buffer`/`Uint8Array` → binary\n\n---\n\n### `ctx.redirect(url, status?, headers?)`\n\nRedirect user.\n\n```ts\napp.get(\"/go\", (ctx) => ctx.redirect(\"https://example.com\"));\n```\n\n* **Default Status**: `302`\n* **Header**: `Location`\n\n---\n\n### `ctx.download(filePath, fileName)`\n\nTrigger file download.\n\n```ts\napp.get(\"/download\", (ctx) => \n  ctx.download(\"/files/report.pdf\", \"Monthly-Report.pdf\")\n);\n```\n\n* **Header**: `Content-Disposition: attachment`\n\n---\n\n### `ctx.sendFile(filePath, fileName?)`\n\nServe static file.\n\n```ts\napp.get(\"/image\", (ctx) => ctx.sendFile(\"/assets/banner.jpg\"));\n```\n\n* Auto sets `Content-Type`\n* Streams file efficiently\n\n---\n\n## 🛠 Best Practices\n\n| Use Case               | Recommended Method |\n| ---------------------- | ------------------ |\n| JSON API response      | `ctx.json()`       |\n| HTML rendering         | `ctx.html()`       |\n| Plain text output      | `ctx.text()`       |\n| XML feeds / APIs       | `ctx.xml()`        |\n| Dynamic content (auto) | `ctx.send()`       |\n| External redirects     | `ctx.redirect()`   |\n| Secure file download   | `ctx.download()`   |\n| Static asset serving   | `ctx.sendFile()`   |\n| Full manual control    | Native `Response`  |\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "5.Route Registry",
      "name": "Route Registry",
      "path": "route-registry",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Radix Router.md",
          "id": 19,
          "name": "Radix Router",
          "type": "file",
          "path": "route-registry/radix-router",
          "content": "# 📦 RadixRouter\n\n`RadixRouter` is a **high-performance HTTP router** using a radix tree for **fast, memory-efficient route matching**. It supports static, dynamic, optional, and wildcard routes, with middleware stacking and router composition for modular applications.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Client as 🧑‍💻 HTTP Client\n    participant Router as 🧭 RadixRouter\n    Note over Router: Match priority → **Static → Dynamic → Optional → Wildcard**\n\n    Client->>Router: Incoming Request (method + path)\n\n    alt Static Segment Match\n        Router-->>Client: Return Handlers\n    else Dynamic Segment Match\n        Router-->>Client: Return Handlers + Params\n    else Optional Segment Match\n        Router-->>Client: Return Handlers (Param or null)\n    else Wildcard Segment Match\n        Router-->>Client: Return Handlers (remaining path)\n    else No Match\n        Router-->>Client: 404 Not Found\n    end\n```\n\n---\n\n## 🔍 Key Features\n\n* **Static Routes:** `/users`\n* **Dynamic Parameters:** `/users/:id`\n* **Optional Parameters:** `/users/:id?`\n* **Wildcards:** `/files/*path`\n* **Middleware Stacking:** Global & route-specific\n* **Router Composition:** Merge sub-routers for maintainability\n\n---\n\n## 📄 Usage\n\n### Initialize Router\n\n```ts\nimport { RadixRouter } from \"tezx/registry\";\n\nconst router = new RadixRouter();\n```\n\n---\n\n### Add Routes\n\n```ts\nrouter.addRoute(\"GET\", \"/hello\", [(ctx) => ctx.text(\"Hello World\")]);\n\nrouter.addRoute(\"GET\", \"/user/:id?\", [\n  (ctx) => ctx.text(`User ID: ${ctx.params.id ?? \"Guest\"}`),\n]);\n\nrouter.addRoute(\"GET\", \"/files/*path\", [serveFileHandler]);\n```\n\n*Supports static, dynamic (`:id`), optional (`:id?`), and wildcard (`*path`) segments.*\n\n---\n\n### Search Routes\n\n```ts\nconst match = router.search(\"GET\", \"/user/123\");\nawait match.handlers[0](ctx); // Executes matched handler\n```\n\n**Return Structure:**\n\n```ts\n{\n  method: \"GET\",\n  params: { id: \"123\" },\n  middlewares: [...],\n  handlers: [...],\n}\n```\n\n---\n\n## ⚡ Matching Priority\n\n1. **Static segments** (`/users`)\n2. **Dynamic segments** (`/users/:id`)\n3. **Optional segments** (`/users/:id?`)\n4. **Wildcard segments** (`/files/*path`)\n\nBacktracking ensures optional segments fallback gracefully.\n\n---\n\n## 🧩 Internal: `parsePattern`\n\nSegments are parsed into:\n\n```ts\ntype Segment = {\n  type: \"static\" | \"dynamic\" | \"wildcard\";\n  value?: string;\n  paramName?: string;\n  isOptional?: boolean;\n};\n```\n\nUsed internally for **efficient radix tree insertion & matching**.\n\n---\n\n## 📊 Performance (Updated Benchmark)\n\n```text\nRadixRouter.search()\nTotal ops:       1,200,000\nTotal time:      170.72 ms\nAvg per op:      142.26 ns (0.142 µs)\nThroughput:      7,029,244 ops/sec\n```\n\n> Extremely fast and suitable for **high-traffic, low-latency applications**.\n\n---\n\n## 🛠 Types\n\n```ts\ntype RouteMatchResult<T> = {\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>[];\n  params: Record<string, string | null | undefined>;\n};\n\ninterface RouteRegistry {\n  name: string;\n  addRoute<T>(method: HTTPMethod, path: string, handler: HandlerType<T>): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult<T>;\n}\n```\n\n---\n"
        },
        {
          "originalPath": "99. Custom Router.md",
          "id": 20,
          "name": "Custom Router",
          "type": "file",
          "path": "route-registry/custom-router",
          "content": "# TezX Route Registry\n\n## Quick overview\n\nTezX uses a `RouteRegistry` to store and match routes. A `Router` (or the top-level `TezX` server) delegates route registration and lookup to a `RouteRegistry` implementation. You can provide the built-in registry or implement your own `CustomRouter` if you need different behavior (radix tree, trie, high-performance matcher, custom param parsing, etc.).\n\nThis doc assumes basic TypeScript knowledge.\n\n---\n\n## Install & import\n\n```ts\n// package name: tezx\nimport { TezX, Router, Middleware, Callback, HTTPMethod } from \"tezx\";\n```\n\n---\n\n## Core types & interfaces (simplified)\n\n```ts\nexport type RouteMatchResult<T extends Record<string, any> = any> = {\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>;\n  params: Record<string, string | null | undefined>;\n};\n\nexport type HandlerType<T extends Record<string, any> = any> = (\n  | Callback<T>\n  | Middleware<T>\n)[];\n\nexport interface RouteRegistry {\n  name: string;\n  addRoute<T extends Record<string, any> = any>(\n    method: HTTPMethod,\n    path: string,\n    handler: HandlerType<T>,\n  ): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult;\n}\n```\n\n> Short note: `ALL` is conventionally used for \"attach to all methods\" (common for middlewares).\n\n---\n\n## What you’ll implement in a `CustomRouter`\n\nMinimal responsibilities:\n\n1. store registered routes and their handlers/middlewares\n2. match an incoming `method` + `path` and return a `RouteMatchResult`\n3. allow wildcard/middleware routes (e.g. `method = \"ALL\"`) and sub-routers (optional)\n\nA high-level `addRoute` + `search` is all TezX needs. The rest is implementation detail.\n\n---\n\n## Example: a simple `CustomRouter` implementation (radix/trie-free but clear)\n\n> This is a **drop-in** example you can expand (add performance, caching, param parsing).\n\n```ts\n// CustomRouter.ts\nimport type { RouteRegistry, RouteMatchResult, HTTPMethod, HandlerType } from \"tezx\";\n\ntype RouteNode = {\n  path: string; // exact or param pattern like \":id\" or \"*\"\n  method: HTTPMethod;\n  handlers: HandlerType;\n};\n\nexport class CustomRouter implements RouteRegistry {\n  name = \"custom-router\";\n  private routes: RouteNode[] = [];\n\n  addRoute(method: HTTPMethod, path: string, handlers: HandlerType) {\n    // normalize path (remove trailing slash except root)\n    const p = path === \"/\" ? \"/\" : path.replace(/\\/$/, \"\");\n    this.routes.push({ path: p, method, handlers });\n  }\n\n  search(method: HTTPMethod, path: string) : RouteMatchResult {\n    const p = path === \"/\" ? \"/\" : path.replace(/\\/$/, \"\");\n\n    // 1) exact match\n    for (const r of this.routes) {\n      if ((r.method === method || r.method === \"ALL\") && r.path === p) {\n        return {\n          method: r.method,\n          middlewares: r.handlers.filter(Boolean) as any,\n          handlers: r.handlers,\n          params: {},\n        } as RouteMatchResult;\n      }\n    }\n\n    // 2) simple param match (e.g. /users/:id)\n    for (const r of this.routes) {\n      if (r.method !== method && r.method !== \"ALL\") continue;\n      const routeParts = r.path.split(\"/\").filter(Boolean);\n      const urlParts = p.split(\"/\").filter(Boolean);\n      if (routeParts.length !== urlParts.length) continue;\n\n      const params: Record<string, string> = {};\n      let matched = true;\n      for (let i = 0; i < routeParts.length; i++) {\n        const rp = routeParts[i];\n        const up = urlParts[i];\n        if (rp.startsWith(\":\")) {\n          params[rp.slice(1)] = decodeURIComponent(up);\n          continue;\n        }\n        if (rp === \"*\") continue;\n        if (rp !== up) {\n          matched = false;\n          break;\n        }\n      }\n\n      if (matched) {\n        return {\n          method: r.method,\n          middlewares: r.handlers.filter(Boolean) as any,\n          handlers: r.handlers,\n          params,\n        } as RouteMatchResult;\n      }\n    }\n\n    // 3) not found — return empty result (TezX may treat as 404)\n    return {\n      method,\n      middlewares: [],\n      handlers: [],\n      params: {},\n    } as RouteMatchResult;\n  }\n}\n```\n\n---\n\n## How TezX uses the registry (sequence diagram)\n\n```mermaid\nsequenceDiagram\n  participant Client\n  participant TezX\n  participant RouteRegistry\n  participant Middlewares\n  participant Handler\n\n  Client->>TezX: HTTP GET /users/42\n  TezX->>RouteRegistry: search(\"GET\", \"/users/42\")\n  RouteRegistry-->>TezX: RouteMatchResult { handlers, middlewares, params }\n  TezX->>Middlewares: run middleware chain (in-order)\n  Middlewares-->>TezX: next()\n  TezX->>Handler: invoke final handler with ctx + params\n  Handler-->>Client: response\n```\n\n---\n\n## Example: register routes & start server\n\n```ts\nimport { TezX, Router } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: new CustomRouter(),\n  env: { /* your env */ },\n});\n\n// Using Router helper (sub-router) — Router will call into the provided routeRegistry\nconst router = new Router({ routeRegistry: new CustomRouter() });\n\n// handlers\nconst authMiddleware: Middleware<any> = async (ctx, next) => {\n  if (!ctx.user) throw new Error(\"unauthenticated\");\n  await next();\n};\n\nconst getUser: Callback<any> = async (ctx) => {\n  const id = ctx.params.id;\n  ctx.res.json({ id, name: \"User\" + id });\n};\n\n// register\napp.get(\"/users/:id\", [authMiddleware, getUser]);\n\n// or via app convenience method (if TezX exposes one)\nrouter.post(\"/users\", [async (ctx) => {/*...*/}]);\n\n\n```\n\n---\n\n## API Reference (cheat-sheet)\n\n* `RouteRegistry.name: string` — identifier.\n* `addRoute(method, path, handler)` — register route or middleware. `method = \"ALL\"` for global.\n* `search(method, path) -> RouteMatchResult` — returns handlers, middlewares and `params`.\n\n---\n\n## Common extensions you might add\n\n* `priority` or `order` for routes so specific routes beat wildcard routes.\n* compiled regex for param routes (`/users/:id(\\\\d+)`).\n* method groups (e.g. `GET|POST`) and versioned routes (`/v1/users`).\n* route metadata (auth roles, rate limits) stored in the route node.\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "6. Middleware",
      "name": "Middleware",
      "path": "middleware",
      "type": "folder",
      "children": [
        {
          "originalPath": "Basic Auth.md",
          "id": 21,
          "name": "Basic Auth",
          "type": "file",
          "path": "middleware/basic-auth",
          "content": "# 🔐 Basic Authentication Middleware (`basicAuth`)\n\nThe `basicAuth` middleware enforces **HTTP Basic Authentication** on incoming requests.\nIt verifies the `Authorization: Basic ...` header, validates credentials, and rejects unauthorized clients.\n\n---\n\n## ✅ When to Use\n\n* Protect admin routes (e.g., `/admin`, `/dashboard`).\n* Secure APIs during development/testing without setting up OAuth/JWT.\n* Quickly add a login wall for staging servers.\n\n---\n\n## 📦 Import\n\n```ts\nimport {basicAuth} from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type BasicAuthOptions = {\n  /**\n   * Function to validate credentials.\n   */\n  validate: (\n    username: string,\n    password: string,\n    ctx: Context\n  ) => boolean | Promise<boolean>;\n\n  /**\n   * Authentication realm (shown in browser login popup).\n   * @default \"Restricted Area\"\n   */\n  realm?: string;\n\n  /**\n   * Custom handler when authentication fails.\n   * Must return an HttpBaseResponse.\n   */\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n};\n```\n\n---\n\n## 🛠️ Usage Example\n\n### 1. Simple Static Credentials\n\n```ts\nimport {basicAuth} from \"tezx/middleware\";\n\nconst auth = basicAuth({\n  validate: (username, password) =>\n    username === \"admin\" && password === \"secret\",\n});\n```\n\n```ts\n// Use in your route\napp.use(\"/admin\", auth, (ctx) => {\n  ctx.json({ message: \"Welcome, admin!\" });\n});\n```\n\n---\n\n### 2. Async Validation (e.g., Database)\n\n```ts\nconst auth = basicAuth({\n  validate: async (username, password, ctx) => {\n    const user = await db.users.findOne({ username });\n    return user && user.passwordHash === hash(password);\n  },\n});\n```\n\n---\n\n### 3. Custom Unauthorized Handler\n\n```ts\nconst auth = basicAuth({\n  validate: (u, p) => u === \"demo\" && p === \"demo\",\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    return ctx.json({ error: \"Access denied\", reason: error?.message });\n  },\n});\n```\n\n---\n\n## 🔄 How It Works\n\n1. Reads the `Authorization` header.\n2. Ensures it starts with `Basic`.\n3. Decodes the Base64 credentials into `username:password`.\n4. Calls your `validate(username, password, ctx)`.\n5. * ✅ If valid → attaches `ctx.user = { username }` and continues.\n   * ❌ If invalid → calls `onUnauthorized` and ends the request.\n\n---\n\n## 🧑‍💻 Accessing Authenticated User\n\n```ts\napp.get(\"/profile\", auth, (ctx) => {\n  const user = (ctx as any).user;\n  return ctx.json({ message: `Hello ${user.username}` });\n});\n```\n\n---\n\n## ⚠️ Notes\n\n* Credentials are sent **on every request** in Base64 (not secure unless using HTTPS).\n* For production, prefer JWT, OAuth2, or session-based auth.\n* `realm` value appears in the browser’s login popup.\n\n---\n"
        },
        {
          "originalPath": "Bearer Auth.md",
          "id": 22,
          "name": "Bearer Auth",
          "type": "file",
          "path": "middleware/bearer-auth",
          "content": "# Bearer Authentication Middleware (`bearerAuth`)\n\nMiddleware to protect routes using **Bearer tokens** (commonly used for JWTs, opaque API tokens, etc.).\nIt extracts the token from the `Authorization` header, delegates validation to your code, and either continues the pipeline or returns an unauthorized response.\n\n---\n\n## Import\n\n```ts\nimport { bearerAuth } from \"tezx/middleware\";\n```\n\n---\n\n## Purpose\n\n* Enforce presence of `Authorization: Bearer <token>` header.\n* Call user-provided `validate` function to determine token validity.\n* Provide a hook to return a custom `HttpBaseResponse` on failure.\n* Attach token (or user info) to `ctx` for downstream handlers.\n\n---\n\n## API / Options\n\n```ts\nexport type BearerAuthOptions = {\n  /**\n   * Validate function. Return `true` (or a truthy value) if token is valid.\n   * Can be synchronous or async.\n   */\n  validate: (token: string, ctx: Context) => boolean | Promise<boolean>;\n\n  /**\n   * Realm shown in `WWW-Authenticate` header. Defaults to \"API\".\n   */\n  realm?: string;\n\n  /**\n   * Handler invoked on unauthorized access.\n   * Must return an `HttpBaseResponse`.\n   */\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n};\n```\n\n**Default behavior** (when `onUnauthorized` not provided):\n\n* Sets `ctx.setStatus = 401`\n* Sets header `WWW-Authenticate: Bearer realm=\"<realm>\"`\n* Returns `ctx.json({ error: \"<message>\" })`\n\n---\n\n## Behavior / Flow\n\n1. Read `authorization` header via `ctx.req.header(\"authorization\")`.\n2. If missing or not `Bearer` → call `onUnauthorized` with error `Bearer token required`.\n3. Extract token (`auth.slice(7).trim()`).\n4. If token empty → `onUnauthorized` with `Empty token`.\n5. Call `await validate(token, ctx)`.\n\n   * If false → `onUnauthorized` with `Invalid or expired token`.\n   * If true → attach `(ctx as any).token = token` and call `next()`.\n\nErrors thrown inside `validate` are caught and passed to `onUnauthorized`.\n\n---\n\n## Examples\n\n### 1) Simple synchronous token check\n\n```ts\nconst auth = bearerAuth({\n  validate: (token) => token === \"dev-secret-token\"\n});\n\napp.use(\"/protected\", auth, (ctx) => {\n  ctx.json({ ok: true });\n});\n```\n\n### 2) Async check (DB / cache)\n\n```ts\nconst auth = bearerAuth({\n  validate: async (token) => {\n    const record = await db.tokens.findOne({ token });\n    return !!record && !record.revoked && record.expiresAt > Date.now();\n  }\n});\n```\n\n### 3) JWT verification example\n\n```ts\nimport jwt from \"jsonwebtoken\";\n\nconst auth = bearerAuth({\n  validate: async (token, ctx) => {\n    try {\n      const payload = jwt.verify(token, process.env.JWT_SECRET);\n      // attach decoded user for downstream handlers\n      (ctx as any).user = payload;\n      return true;\n    } catch {\n      return false;\n    }\n  },\n});\n```\n\n### 4) Custom `onUnauthorized`\n\n```ts\nconst auth = bearerAuth({\n  validate: async (t) => verifyTokenSomehow(t),\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    ctx.setHeader(\"WWW-Authenticate\", `Bearer realm=\"API\"`);\n    // Return a custom HttpBaseResponse (or ctx.json)\n    return ctx.json({ error: \"Auth failed\", reason: error?.message });\n  }\n});\n```\n\n---\n\n## How to access validated token / user\n\nDownstream handlers can read the token (or attached user info):\n\n```ts\napp.get(\"/me\", auth, (ctx) => {\n  const token = (ctx as any).token; // raw token string\n  const user = (ctx as any).user;   // if you attached user in validate()\n  ctx.json({ token, user });\n});\n```\n\n---\n\n## Security Notes\n\n* **Always use HTTPS** — Bearer tokens sent in plaintext over HTTP are vulnerable.\n* Tokens are sent on every request; prefer short-lived tokens + refresh strategy or signed tokens (JWT).\n* Don’t log full tokens in production.\n* If validating JWTs, verify signature, issuer, audience, and expiry.\n\n---\n\n## Edge Cases & Recommendations\n\n* Header casing: `ctx.req.header(\"authorization\")` should handle typical casing; if not, fallback to `Authorization`.\n* Multiple auth schemes: if you support Basic/API-Key, ensure middleware ordering or combine into a flexible auth middleware.\n* If `validate` attaches heavy objects to `ctx`, prefer a sanitized `ctx.user` structure.\n* For streaming responses, nothing special is needed; this middleware runs before response generation.\n\n---\n\n## Testing Tips\n\n* Unit test both success and failure flows:\n\n  * Missing header\n  * `Authorization: Bearer` (empty token)\n  * Invalid token\n  * `validate` throwing an error\n  * Valid token attaches `token` / `user` and calls `next()`\n* Mock `ctx.req.header` and `ctx.json` when testing in isolation.\n* Integration tests: issue HTTP requests with `Authorization` header to protected endpoints.\n\n---\n\n## Example: Full usage with Express-like pseudo-app\n\n```ts\nconst auth = bearerAuth({\n  validate: async (token, ctx) => {\n    // Example: decode jwt + attach user\n    try {\n      const payload = jwt.verify(token, process.env.JWT_SECRET);\n      (ctx as any).user = payload;\n      return true;\n    } catch {\n      return false;\n    }\n  },\n});\n\napp.use(\"/api\", auth);\n\napp.get(\"/api/profile\", (ctx) => {\n  const user = (ctx as any).user;\n  return ctx.json({ user });\n});\n```\n\n---\n\n## Troubleshooting\n\n* If requests always fail: ensure the `Authorization` header is present and not stripped by proxies. Check `Authorization` vs `authorization` handling.\n* If `validate` never runs: confirm the middleware is registered for the correct route and that other middleware isn’t short-circuiting.\n* If `onUnauthorized` returns unexpected shape: ensure it returns the `HttpBaseResponse` expected by your framework or uses `ctx.json()`.\n\n---\n"
        },
        {
          "originalPath": "CORS.md",
          "id": 23,
          "name": "CORS",
          "type": "file",
          "path": "middleware/cors",
          "content": "\n# CORS Middleware (`cors`)\n\nMiddleware for handling **Cross-Origin Resource Sharing (CORS)** in your TezX server. It allows you to configure which origins, methods, headers, and credentials are allowed.\n\n## Import\n\n```ts\nimport { cors } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`CorsOptions`)\n\n```ts\nexport type CorsOptions = {\n  /** Allowed origins for CORS.\n   * Can be:\n   * - A string: e.g. \"https://example.com\"\n   * - An array of strings: e.g. [\"https://example.com\", \"https://foo.com\"]\n   * - A function: (reqOrigin: string) => boolean\n   */\n  origin?: string | string[] | ((reqOrigin: string) => boolean);\n\n  /** Allowed HTTP methods for CORS requests.\n   * Defaults to [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n   */\n  methods?: string[];\n\n  /** Allowed headers for CORS requests.\n   * Defaults to [\"Content-Type\", \"Authorization\"]\n   */\n  allowedHeaders?: string[];\n\n  /** Headers exposed to the browser */\n  exposedHeaders?: string[];\n\n  /** Indicates whether credentials (cookies/auth headers) are allowed */\n  credentials?: boolean;\n\n  /** Preflight cache duration (in seconds) */\n  maxAge?: number;\n};\n```\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\napp.use(\n  cors({\n    origin: \"*\", // allow all origins\n  })\n);\n```\n\n### Restrict to a Single Origin\n\n```ts\napp.use(\n  cors({\n    origin: \"https://example.com\",\n  })\n);\n```\n\n### Restrict to Multiple Origins\n\n```ts\napp.use(\n  cors({\n    origin: [\"https://example.com\", \"https://foo.com\"],\n  })\n);\n```\n\n### Dynamic Origin Check\n\n```ts\napp.use(\n  cors({\n    origin: (reqOrigin) => {\n      // allow only origins ending with 'mydomain.com'\n      return reqOrigin.endsWith(\"mydomain.com\");\n    },\n  })\n);\n```\n\n### Custom Methods and Headers\n\n```ts\napp.use(\n  cors({\n    methods: [\"GET\", \"POST\", \"PATCH\"],\n    allowedHeaders: [\"Content-Type\", \"Authorization\", \"X-Custom-Header\"],\n    exposedHeaders: [\"X-Custom-Header\"],\n  })\n);\n```\n\n### Enable Credentials and Preflight Cache\n\n```ts\napp.use(\n  cors({\n    credentials: true,\n    maxAge: 86400, // 1 day\n  })\n);\n```\n\n---\n\n## Behavior\n\n* Sets the following response headers automatically:\n\n```text\nAccess-Control-Allow-Origin\nAccess-Control-Allow-Methods\nAccess-Control-Allow-Headers\nAccess-Control-Expose-Headers (optional)\nAccess-Control-Allow-Credentials (optional)\nAccess-Control-Max-Age (optional)\n```\n\n* Automatically responds to **OPTIONS preflight requests** with status `204` (No Content) and does **not call the next middleware**.\n\n---\n\n## Middleware Type\n\n```ts\nfunction cors<T extends Record<string, any> = {}, Path extends string = any>(\n  option: CorsOptions = {}\n): Middleware<T, Path>\n```\n\n* `T` – custom context type (optional)\n* `Path` – route path type (optional)\n* Returns a `Middleware` function compatible with TezX.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport { router } from \"tezx\";\nimport cors from \"tezx/middleware\";\n\nrouter.get(\"/api/data\", cors(), async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\nrouter.post(\n  \"/api/secure\",\n  cors({\n    origin: \"https://example.com\",\n    credentials: true,\n  }),\n  async (ctx) => {\n    return ctx.json({ message: \"Secure POST request\" });\n  }\n);\n```\n\n---\n\n### Notes\n\n* If `origin` is not provided, defaults to `\"*\"` (allow all origins).\n* `methods` and `allowedHeaders` default to standard HTTP methods and headers.\n* Preflight requests (`OPTIONS`) are handled automatically and will not call downstream middleware.\n\n---\n"
        },
        {
          "originalPath": "Cache Control.md",
          "id": 24,
          "name": "Cache Control",
          "type": "file",
          "path": "middleware/cache-control",
          "content": "# ⚡ `cacheControl` Middleware\n\nA **super-lightweight, zero-overhead HTTP caching middleware** for your custom web framework.\nIt automatically adds proper `Cache-Control`, `Expires`, and optional `Vary` headers — dynamically, based on flexible caching rules.\n\n---\n\n## 🚀 Features\n\n✅ Ultra-fast — optimized for V8 hot path (manual loop, no .find, no closures).\n✅ Zero dependencies — pure TypeScript, ~1KB runtime footprint.\n✅ Rule-based — apply dynamic caching based on request conditions.\n✅ Fully safe — errors wrapped in `TezXError`, never crash the app.\n✅ Works seamlessly with your existing `Context` and `Middleware` interfaces.\n\n---\n\n## 📦 Installation\n\nIf this middleware is part of your internal framework, just import directly:\n\n```ts\nimport { cacheControl } from \"tezx/middleware\";\n```\n\n---\n\n## 🧠 Usage Example\n\n```ts\nimport { cacheControl } from \"tezx/middleware\";\n\napp.use(\n  cacheControl({\n    defaultSettings: {\n      maxAge: 3600, // 1 hour\n      scope: \"public\",\n    },\n    rules: [\n      {\n        condition: (ctx) => ctx.url.startsWith(\"/api/private\"),\n        maxAge: 0,\n        scope: \"private\",\n      },\n      {\n        condition: (ctx) => ctx.url.includes(\"/images/\"),\n        maxAge: 86400, // 1 day\n        scope: \"public\",\n        vary: [\"Accept-Encoding\"],\n      },\n    ],\n    onError: (error, ctx) => {\n      ctx.setStatus = error.statusCode ?? 500;\n      return ctx.json(error?.message)\n    },\n  })\n);\n```\n\n---\n\n## ⚙️ API Reference\n\n### `cacheControl(options: CacheOptions): Middleware`\n\nCreates and returns a new caching middleware function.\n\n#### Parameters\n\n| Name              | Type                                                                | Description                                                         |\n| ----------------- | ------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings`                                                     | Default caching policy applied when no rule matches.                |\n| `rules`           | `CacheRule[]` *(optional)*                                          | Custom cache rules evaluated per request. First matching rule wins. |\n| `onError`         | `(error: TezXError, ctx: Context) => HttpBaseResponse` *(optional)* | Custom error handler for middleware-level exceptions.               |\n\n---\n\n## 🧩 Type Definitions\n\n```ts\nexport interface CacheRule {\n  /** 🎯 Condition to determine if this rule applies */\n  condition: (ctx: Context) => boolean;\n  /** ⏳ Max age (in seconds) */\n  maxAge: number;\n  /** 🌐 Cache scope */\n  scope: \"public\" | \"private\";\n  /** 🏷️ Optional vary header */\n  vary?: string[];\n}\n\nexport interface CacheSettings\n  extends Pick<CacheRule, \"maxAge\" | \"scope\" | \"vary\"> {}\n\nexport interface CacheOptions {\n  defaultSettings: CacheSettings;\n  rules?: readonly CacheRule[];\n  onError?: (error: TezXError, ctx: Context) => HttpBaseResponse;\n}\n```\n\n---\n\n## 🧮 How It Works\n\n1. Middleware runs **only** for `GET` and `HEAD` requests (no effect on POST/PUT).\n2. It checks the provided `rules` sequentially.\n3. The **first matching rule** determines the caching policy.\n4. If no rules match, the `defaultSettings` are applied.\n5. The following headers are set:\n\n   * `Cache-Control: public, max-age=3600`\n   * `Expires: <UTC datetime>`\n   * `Vary: Accept-Encoding, ...` *(if specified)*\n\n---\n\n## 🧩 Error Handling\n\nIf an exception occurs inside your route handler or cache logic:\n\n* The error is wrapped in `TezXError`.\n* The middleware invokes `onError(error, ctx)` (if provided).\n* Default behavior sets status `500` and a JSON body `{ error: \"Cache middleware failed\" }`.\n\n---\n\n## 🧭 Recommended Patterns\n\n| Scenario            | Recommended Setting                             |\n| ------------------- | ----------------------------------------------- |\n| Static assets       | `{ scope: \"public\", maxAge: 86400 }`            |\n| Authenticated API   | `{ scope: \"private\", maxAge: 0 }`               |\n| Dynamic pages       | `{ scope: \"public\", maxAge: 60 }`               |\n| Sensitive user data | Disable cache (`maxAge: 0`, `scope: \"private\"`) |\n\n---\n\n## 🧱 Example Integration with Router\n\n```ts\napp.use(\"/products\", cacheControl({\n  defaultSettings: { maxAge: 600, scope: \"public\" },\n}));\n```\n\n---\n"
        },
        {
          "originalPath": "Detact Bot.md",
          "id": 25,
          "name": "Detact Bot",
          "type": "file",
          "path": "middleware/detact-bot",
          "content": "# 🧠 `detectBot` Middleware\n\nDetect and block automated or malicious requests using advanced heuristics — combining **User-Agent analysis**, **IP blacklists**, **rate limiting**, and **custom detection logic**.\nBuilt for **high performance** on **Bun**, **Node.js**, and **Deno** runtimes.\n\n---\n\n## 📦 Import\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\n```\n\n---\n\n## 🚀 Quick Start\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    botUserAgents: [\"bot\", \"crawler\", \"indexer\"],\n    onBotDetected: (ctx, reason) =>\n      ctx.status(403).json({ error: `Bot detected: ${reason}` }),\n  })\n);\n```\n\n✅ The middleware automatically:\n\n* Detects common bots by analyzing the **User-Agent** header\n* Blocks requests from **blacklisted IPs**\n* Throttles suspicious traffic via **rate limiting**\n* Allows your own **custom detection rules**\n\n---\n\n## ⚙️ Configuration\n\n### `DetectBotOptions`\n\n| Option                 | Type                                                 | Default                               | Description                                                      |\n| ---------------------- | ---------------------------------------------------- | ------------------------------------- | ---------------------------------------------------------------- |\n| **botUserAgents**      | `string[]`                                           | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]` | List of User-Agent substrings that indicate bot traffic.         |\n| **enableRateLimiting** | `boolean`                                            | `false`                               | Enable rate-limit based bot detection.                           |\n| **maxRequests**        | `number`                                             | `30`                                  | Maximum allowed requests per IP within the window.               |\n| **windowMs**           | `number`                                             | `60000`                               | Duration of rate-limit window (in milliseconds).                 |\n| **storage**            | `object`                                             | `In-memory Map`                       | Custom storage for rate-limit tracking (Redis, Memcached, etc.). |\n| **isBlacklisted**      | `(ctx: Context) => boolean \\| Promise<boolean>`      | `() => false`                         | Function to check if IP is blacklisted.                          |\n| **customBotDetector**  | `(ctx: Context) => boolean \\| Promise<boolean>`      | `undefined`                           | Custom logic for detecting bots (headers, params, etc.).         |\n| **onBotDetected**      | `(ctx: Context, reason: string) => HttpBaseResponse` | Returns `403 JSON`                    | Callback executed when a bot is detected.                        |\n\n---\n\n## 🧩 Example — Custom Setup\n\n### 1. Detect by custom header or query\n\n```ts\ndetectBot({\n  customBotDetector: (ctx) => ctx.query?.token === \"fake-token\",\n  onBotDetected: (ctx, reason) => ctx.status(403).json({ error: `Blocked by custom rule: ${reason}` }),\n});\n```\n\n### 2. Block a specific IP\n\n```ts\ndetectBot({\n  isBlacklisted: (ctx) => ctx.req.remoteAddress.address === \"192.168.0.42\",\n});\n```\n\n### 3. Redis-based rate-limit storage\n\n```ts\ndetectBot({\n  enableRateLimiting: true,\n  storage: {\n    get: (key) => myRedis.get(key),\n    set: (key, value) => myRedis.set(key, JSON.stringify(value)),\n    clearExpired: () => {},\n  },\n});\n```\n\n---\n\n## ⚡ Performance\n\nTezX automatically optimizes detection depending on the runtime:\n\n| Runtime            | Detection Method                      | Performance Note                     |\n| ------------------ | ------------------------------------- | ------------------------------------ |\n| **Bun**            | Precompiled RegExp                    | 🧠 Fastest; uses native regex engine |\n| **Node.js / Deno** | Manual `for..of` + `.includes()` loop | ⚙️ Optimized for V8                  |\n\n---\n\n## 🔍 Detection Flow\n\nThe middleware executes in the following order:\n\n1. **User-Agent Check**\n   Scans for known bot keywords in the User-Agent string.\n2. **IP Blacklist Check**\n   Executes your custom `isBlacklisted` callback.\n3. **Rate-Limiting Check** *(optional)*\n   Detects excessive requests per IP using `getConnInfo()`.\n4. **Custom Detection**\n   Executes your `customBotDetector` callback.\n5. **Pass-through**\n   Calls `next()` if no suspicious behavior is detected.\n\n---\n\n## ⚙️ Rate-Limiting Requirements\n\nTo use rate limiting, you must import `getConnInfo()` from your runtime adapter:\n\n```ts\n// Bun runtime\nimport { getConnInfo } from \"tezx/bun\";\n\n// Node.js runtime\nimport { getConnInfo } from \"tezx/node\";\n\n// Deno runtime\nimport { getConnInfo } from \"tezx/deno\";\n```\n\nEnsure the middleware has access to `ctx.req.remoteAddress`.\n\n---\n\n## 💡 Example Responses\n\n| Scenario            | Default Response                                              |\n| ------------------- | ------------------------------------------------------------- |\n| Bot by User-Agent   | `{ \"error\": \"Bot detected: User-Agent\" }`                     |\n| Rate-limit exceeded | `{ \"error\": \"Rate limit exceeded. Retry after 45 seconds.\" }` |\n| Blacklisted IP      | `{ \"error\": \"Bot detected: Blacklisted IP\" }`                 |\n\nYou can fully customize this behavior using `onBotDetected`.\n\n---\n\n## 🧰 Advanced Integration\n\nCombine `detectBot` with other TezX middlewares for a layered defense:\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\nimport { cors } from \"tezx/middleware\";\n\napp.use(cors());\napp.use(detectBot({ enableRateLimiting: true }));\n```\n\n---\n\n## 🧾 Type Definitions\n\n```ts\ntype DetectBotOptions = {\n  botUserAgents?: string[];\n  enableRateLimiting?: boolean;\n  maxRequests?: number;\n  windowMs?: number;\n  storage?: RateLimitStorage;\n  isBlacklisted?: (ctx: Context) => boolean | Promise<boolean>;\n  customBotDetector?: (ctx: Context) => boolean | Promise<boolean>;\n  onBotDetected?: (ctx: Context, reason: string) => HttpBaseResponse;\n};\n```\n\n---\n\n## 🧩 Summary\n\n| Feature                | Description                                    |\n| ---------------------- | ---------------------------------------------- |\n| ✅ User-Agent detection | Detects bots via known patterns                |\n| 🚫 IP Blacklisting     | Blocks known or suspicious IPs                 |\n| ⚡ Rate Limiting        | Detects aggressive bot-like activity           |\n| 🧠 Custom Heuristics   | Flexible detection logic per project           |\n| 🛡️ Lightweight & Fast | Built for high-performance frameworks like Bun |\n| 🔄 Pluggable Storage   | Works with Redis, Memory, or custom stores     |\n\n---\n"
        },
        {
          "originalPath": "Logger.md",
          "id": 26,
          "name": "Logger",
          "type": "file",
          "path": "middleware/logger",
          "content": "# Logger Middleware (`logger`)\n\nMiddleware for logging incoming HTTP requests and responses. Logs the **method**, **pathname**, **status code**, and **execution time** for each request. Useful for debugging and monitoring your TezX server.\n\n---\n\n## Import\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`LoggerOptions`)\n\n```ts\nexport interface LoggerOptions {\n  /** Enable or disable logging. Default: true */\n  enabled?: boolean;\n}\n```\n\n* `enabled` – Boolean flag to enable or disable logging.\n\n  * `true` – logs requests (default)\n  * `false` – disables logging for silent operation\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { logger } from \"tezx/middleware\";\n\n\napp.use(logger()); // logging enabled by default\n\napp.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n```\n\n### Disable Logging\n\n```ts\napp.use(logger({ enabled: false }));\n```\n\n---\n\n## Behavior\n\n1. **Logs Incoming Request**\n   When a request comes in, it logs:\n\n```bash\n<-- METHOD /pathname\n```\n\nExample:\n\n```bash\n<-- GET /api/data\n```\n\n2. **Measures Execution Time**\n   The middleware measures how long the downstream middleware or handler takes to complete.\n\n3. **Logs Response**\n   After the request is processed, it logs:\n\n```bash\n--> METHOD /pathname STATUS_CODE TIME\n```\n\nExample:\n\n```bash\n--> GET /api/data 200 3.45ms\n```\n\n4. **Error Logging**\n   If an error occurs during request processing, it logs the stack trace:\n\n```bash\nError: <stack trace>\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction logger(options?: LoggerOptions): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used globally or per-route.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport logger from \"tezx/middleware\";\n\n// Enable logger globally\napp.use(logger());\n\n// Sample route\napp.get(\"/api/users\", async (ctx) => {\n  return ctx.json({ users: [] });\n});\n\n// Disable logger for a specific route\napp.post(\"/api/secret\", logger({ enabled: false }), async (ctx) => {\n  return ctx.json({ secret: \"hidden\" });\n});\n```\n\n---\n\n## Console Output Example\n\n```text\n<-- GET /api/users\n--> GET /api/users 200 2.14ms\n\n<-- POST /api/secret\n--> POST /api/secret 200 1.07ms\n```\n\n* `<--` indicates **incoming request**\n* `-->` indicates **response completed**\n* Execution time shows **performance of route handler**\n\n---\n"
        },
        {
          "originalPath": "Pagination Handler.md",
          "id": 27,
          "name": "Pagination Handler",
          "type": "file",
          "path": "middleware/pagination-handler",
          "content": "# 📘 Pagination Middleware (`paginationHandler`)\n\nThe `paginationHandler` middleware provides **automatic pagination handling** for API endpoints.\nIt simplifies extracting pagination parameters, calculating offsets, generating metadata, and optionally integrates with a **dynamic data source** (e.g., database, ORM).\n\n---\n\n## 📦 Import\n\n```ts\n// Standard import\nimport { paginationHandler } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type PaginationOptions<\n  DataKey extends string = \"data\",\n  CountKey extends string = \"total\",\n  Item = any\n> = {\n  defaultPage?: number;       // Default page if not specified (default: 1)\n  defaultLimit?: number;      // Default items per page (default: 10)\n  maxLimit?: number;          // Maximum items per page (default: 100)\n  queryKeyPage?: string;      // Query parameter for page (default: \"page\")\n  queryKeyLimit?: string;     // Query parameter for limit (default: \"limit\")\n  countKey?: CountKey;        // Key for total count (default: \"total\")\n  dataKey?: DataKey;          // Key for data array (default: \"data\")\n\n  getDataSource?: <T extends Record<string, any> = {}>(\n    ctx: Context<T>,\n    pagination: { page: number; limit: number; offset: number }\n  ) => Promise<\n    { [K in DataKey]: Item[] } & { [K in CountKey]: number }\n  >;\n};\n```\n\n---\n\n## 📊 Pagination Metadata\n\nWhen pagination is applied, the following structure is available in `ctx.pagination` and response body:\n\n```ts\ntype PaginationBodyType = {\n  [x: string]: any;\n  pagination: {\n    page: number;          // Current page number\n    limit: number;         // Items per page\n    offset: number;        // Calculated offset\n    totalItems: number;    // Total number of items\n    totalPages: number;    // Total number of pages\n    hasNextPage: boolean;  // Whether next page exists\n    hasPrevPage: boolean;  // Whether previous page exists\n    nextPage: number|null; // Next page number (or null)\n    prevPage: number|null; // Previous page number (or null)\n  };\n};\n```\n\n---\n\n## 🚀 Usage Examples\n\n### 1. Basic Setup (No Data Source)\n\nOnly extracts pagination parameters and makes them available via `ctx.pagination`.\n\n```ts\nimport { paginationHandler } from \"tezx/middleware\";\n\napp.get(\"/users\", paginationHandler(), async (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  ctx.json({ page, limit, offset });\n});\n\n// GET /users?page=2&limit=5\n// → { \"page\": 2, \"limit\": 5, \"offset\": 5 }\n```\n\n---\n\n### 2. With Dynamic Data Source (Database Integration)\n\nAutomatically fetches data and total count from your database and returns a **structured response**.\n\n```ts\napp.get(\n  \"/products\",\n  paginationHandler({\n    getDataSource: async (ctx, { page, limit, offset }) => {\n      // Example using Sequelize\n      const { rows, count } = await Product.findAndCountAll({\n        offset,\n        limit,\n      });\n      return { data: rows, total: count };\n    },\n  })\n);\n\n// GET /products?page=2&limit=10\n// → {\n//   \"data\": [ ... 10 products ... ],\n//   \"total\": 53,\n//   \"pagination\": {\n//     \"page\": 2,\n//     \"limit\": 10,\n//     \"offset\": 10,\n//     \"totalItems\": 53,\n//     \"totalPages\": 6,\n//     \"hasNextPage\": true,\n//     \"hasPrevPage\": true,\n//     \"nextPage\": 3,\n//     \"prevPage\": 1\n//   }\n// }\n```\n\n---\n\n### 3. Custom Query Keys\n\nUse different query parameter names for pagination.\n\n```ts\napp.get(\n  \"/articles\",\n  paginationHandler({\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n  }),\n  async (ctx) => {\n    const { page, limit } = ctx.pagination;\n    ctx.json({ page, limit });\n  }\n);\n\n// GET /articles?p=3&size=20\n// → { \"page\": 3, \"limit\": 20 }\n```\n\n---\n\n### 4. Custom Data and Count Keys\n\nReturn custom response keys for compatibility with frontend clients.\n\n```ts\napp.get(\n  \"/comments\",\n  paginationHandler({\n    dataKey: \"items\",\n    countKey: \"totalCount\",\n    getDataSource: async (ctx, { offset, limit }) => {\n      const { rows, count } = await Comment.findAndCountAll({ offset, limit });\n      return { items: rows, totalCount: count };\n    },\n  })\n);\n\n// GET /comments?page=1&limit=5\n// → {\n//   \"items\": [ ... 5 comments ... ],\n//   \"totalCount\": 42,\n//   \"pagination\": { ... }\n// }\n```\n\n---\n\n### 5. Strict Maximum Limit\n\nProtect your API by enforcing a **hard max limit**.\n\n```ts\napp.get(\n  \"/logs\",\n  paginationHandler({\n    defaultLimit: 20,\n    maxLimit: 50, // Clients cannot request more than 50\n  }),\n  async (ctx) => {\n    ctx.json({ limit: ctx.pagination.limit });\n  }\n);\n\n// GET /logs?limit=500\n// → limit will be capped at 50\n```\n\n---\n\n## 🔒 Best Practices\n\n* **Always enforce `maxLimit`** to prevent abuse (e.g., denial-of-service by requesting huge datasets).\n* **Use `whitelist` query keys** (`queryKeyPage`, `queryKeyLimit`) for consistency across APIs.\n* **Custom response keys (`dataKey`, `countKey`)** make integration smoother with frontend expectations.\n* Place `paginationHandler` **before your route handler** so that `ctx.pagination` is available when querying your DB.\n* If using `getDataSource`, the middleware automatically sets the response body — otherwise, you can manually use `ctx.pagination`.\n\n---\n"
        },
        {
          "originalPath": "Powered By.md",
          "id": 28,
          "name": "Powered By",
          "type": "file",
          "path": "middleware/powered-by",
          "content": "# PoweredBy Middleware (`poweredBy`)\n\nMiddleware for adding an **`X-Powered-By`** header to HTTP responses. This is commonly used to indicate the server or framework powering the application.\n\n---\n\n## Import\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n---\n\n## Parameters\n\n```ts\nconst poweredBy = (serverName?: string): Middleware => { ... }\n```\n\n* `serverName` (optional) – A custom server name to use in the header.\n\n  * Default: `\"TezX\"`\n\n---\n\n## Usage\n\n### Basic Usage\n\nAdds the default `X-Powered-By` header with value `\"TezX\"`:\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\napp.use(poweredBy());\n```\n\n* Response Header Example:\n\n```bash\nX-Powered-By: TezX\n```\n\n### Custom Server Name\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n* Response Header Example:\n\n```bash\nX-Powered-By: MyServer\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction poweredBy(serverName?: string): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used **globally** or **per route**.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport poweredBy from \"tezx/middleware/poweredBy\";\n\n// Set global X-Powered-By header\napp.use(poweredBy());\n\n// Sample route\napp.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\n// Override with custom server name for a specific route\napp.get(\"/api/custom\", poweredBy(\"CustomServer\"), async (ctx) => {\n  return ctx.json({ message: \"Custom Header Applied\" });\n});\n```\n\n* `/api/data` response header: `X-Powered-By: TezX`\n* `/api/custom` response header: `X-Powered-By: CustomServer`\n\n---\n"
        },
        {
          "originalPath": "Rate Limiter.md",
          "id": 29,
          "name": "Rate Limiter",
          "type": "file",
          "path": "middleware/rate-limiter",
          "content": "# 🚦 Rate Limiter Middleware (`rateLimiter`)\n\nThe `rateLimiter` middleware **limits the number of requests per client** over a configurable time window. It is ideal for **preventing abuse, brute-force attacks, or accidental API overload**.\n\nIt supports **custom client identification**, **custom storage**, and **custom error handling**.\n\n---\n\n## 📦 Import\n\n```ts\n// Standard import\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type RateLimiterOptions = {\n  maxRequests: number;         // Maximum requests per window\n  windowMs: number;            // Time window in milliseconds\n\n  keyGenerator?: (ctx: Context) => string;\n  // Generate a unique client key\n  // default: use IP address from x-forwarded-for / client-ip / remoteAddress\n\n  storage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    clearExpired: () => void;\n  };\n  // Custom storage for tracking rate limits (e.g., Map, Redis)\n\n  onError?: (\n    ctx: Context,\n    retryAfter: number,\n    error: Error\n  ) => HttpBaseResponse;\n  // Custom callback when rate limit is exceeded\n};\n```\n\n---\n\n## 🧩 Behavior\n\n* Each client is identified by a **key** (IP by default, or custom via `keyGenerator`).\n* Requests are counted per **time window (`windowMs`)**.\n* Response headers provided:\n\n  * `X-RateLimit-Limit`: maximum requests allowed.\n  * `X-RateLimit-Remaining`: requests remaining in current window.\n  * `X-RateLimit-Reset`: timestamp (ms) when window resets.\n  * `Retry-After`: seconds until the window resets (only sent when limit exceeded).\n* If the client exceeds `maxRequests`, the `onError` callback is invoked (default: throw `429 Too Many Requests`).\n\n---\n\n## ✅ Default Behavior\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000, // 1 minute\n  })\n);\n```\n\n* Limits each client to **100 requests per minute**.\n* Sends standard rate-limit headers.\n* Returns `429` when exceeded.\n\n---\n\n## 🔑 Custom Client Key Example\n\nUse authenticated user IDs or tokens instead of IP addresses.\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000, // 10 seconds\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  })\n);\n```\n\n* Useful for APIs behind proxies or load balancers.\n* Ensures rate limiting is per **user** instead of per IP.\n\n---\n\n## 🗄️ Custom Storage (Redis Example)\n\nYou can replace the default in-memory store with Redis:\n\n```ts\nimport { redisClient } from \"./redisClient\";\n\nconst redisStorage = {\n  get: async (key: string) => {\n    const val = await redisClient.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key: string, value: { count: number; resetTime: number }) => {\n    await redisClient.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {}, // Redis automatically expires keys\n};\n\napp.use(\n  rateLimiter({\n    maxRequests: 50,\n    windowMs: 60_000,\n    storage: redisStorage,\n  })\n);\n```\n\n---\n\n## ⚠️ Custom Error Handler\n\nYou can customize the response when the client exceeds the limit:\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.setStatus = 429;\n      return ctx.json({\n        success: false,\n        message: `Too many requests. Try again in ${retryAfter} seconds.`,\n      });\n    },\n  })\n);\n```\n\n* Allows sending JSON, HTML, or custom formatted responses.\n* Still receives `Retry-After` header automatically.\n\n---\n\n## 🧾 Headers Sent by Middleware\n\n| Header                  | Description                                      |\n| ----------------------- | ------------------------------------------------ |\n| `X-RateLimit-Limit`     | Maximum requests per window                      |\n| `X-RateLimit-Remaining` | Requests left in the current window              |\n| `X-RateLimit-Reset`     | Timestamp (ms) when the window resets            |\n| `Retry-After`           | Seconds until next allowed request (only on 429) |\n\n---\n\n## 💡 Best Practices\n\n* Always use **`maxRequests` + `windowMs`** appropriate for your API traffic.\n* Use **custom keyGenerator** for user-based rate limiting.\n* Use **Redis or other distributed store** if deploying behind multiple servers.\n* Always include the `Retry-After` header for clients.\n* Combine with other middleware like `logger` or `cors` for robust APIs.\n\n---\n\n## Example: Full Stack Integration\n\n```ts\nimport { app } from \"tezx\";\nimport rateLimiter from \"tezx/middleware/rateLimiter\";\nimport logger from \"tezx/middleware/logger\";\nimport cors from \"tezx/middleware/cors\";\n\napp.use(cors());\napp.use(logger());\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  })\n);\n\napp.get(\"/api/data\", async (ctx) => {\n  ctx.json({ success: true, data: [\"item1\", \"item2\"] });\n});\n```\n\n---\n"
        },
        {
          "originalPath": "Request ID.md",
          "id": 30,
          "name": "Request ID",
          "type": "file",
          "path": "middleware/request-id",
          "content": "# Request ID Middleware (`requestID`)\n\nMiddleware for assigning a **unique request ID** to every incoming HTTP request. Useful for **request tracking**, **logging**, and **debugging**.\n\n---\n\n## Import\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n---\n\n## Parameters\n\n```ts\nconst requestID = (\n  headerName: string = \"X-Request-ID\",\n  contextKey: string = \"requestID\",\n): Middleware => { ... }\n```\n\n| Parameter    | Type     | Default          | Description                                              |\n| ------------ | -------- | ---------------- | -------------------------------------------------------- |\n| `headerName` | `string` | `\"X-Request-ID\"` | The HTTP header to store the request ID.                 |\n| `contextKey` | `string` | `\"requestID\"`    | Key to store the request ID in the TezX context (`ctx`). |\n\n---\n\n## Behavior\n\n1. Checks if the incoming request already has the request ID header.\n2. If not present, generates a new unique ID using `generateUUID()`.\n3. Sets the request ID in:\n\n   * **HTTP header** (`ctx.headers.set(headerName, requestId)`)\n   * **TezX context** (`ctx[contextKey] = requestId`)\n4. Can be accessed by downstream middleware or handlers using `ctx[contextKey]`.\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n\napp.use(requestID());\n\n// Access request ID in a route\nrouter.get(\"/api/data\", async (ctx) => {\n  console.log(\"Request ID:\", ctx.requestID);\n  return ctx.json({ requestID: ctx.requestID });\n});\n```\n\n* Adds header:\n\n```bash\nX-Request-ID: req-<unique-id>\n```\n\n---\n\n### Custom Header Name\n\n```ts\napp.use(requestID(\"X-Custom-Request-ID\"));\n```\n\n* Sets the request ID in `X-Custom-Request-ID` header and context key `requestID`:\n\n```ts\nctx.requestID // contains the generated ID\n```\n\n---\n\n### Custom Context Key\n\n```ts\napp.use(requestID(\"X-Request-ID\", \"reqId\"));\n\n// Access in route\nrouter.get(\"/api/data\", async (ctx) => {\n  console.log(ctx.reqId); // custom context key\n  return ctx.json({ reqId: ctx.reqId });\n});\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction requestID(headerName?: string, contextKey?: string): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used **globally** or **per-route**.\n\n---\n\n## Example with Logger Integration\n\n```ts\nimport {requestID,logger} from \"tezx/middleware\";\n\napp.use(requestID()); // assign request ID\napp.use(logger());    // log requests including request ID\n\napp.get(\"/api/users\", async (ctx) => {\n  return ctx.json({ requestID: ctx.requestID });\n});\n```\n\n* Each log can include the unique request ID for traceability.\n\n---\n"
        },
        {
          "originalPath": "Sanitize Headers.md",
          "id": 31,
          "name": "Sanitize Headers",
          "type": "file",
          "path": "middleware/sanitize-headers",
          "content": "# SanitizeHeaders Middleware (`sanitizeHeaders`)\n\nMiddleware for **sanitizing HTTP headers** to enhance security and compliance. It allows you to **whitelist** allowed headers, **blacklist** disallowed headers, and removes dangerous or unnecessary headers to prevent **information leakage** or **header injection attacks**.\n\n---\n\n## Import\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`SanitizeHeadersOptions`)\n\n```ts\nexport type SanitizeHeadersOptions = {\n  /**\n   * 🟢 Whitelist of allowed headers (case-insensitive)\n   * @default [] (allow all headers if empty)\n   */\n  whitelist?: string[];\n\n  /**\n   * 🔴 Blacklist of disallowed headers (case-insensitive)\n   * @default [] (block none if empty)\n   */\n  blacklist?: string[];\n};\n```\n\n* `whitelist` – Only headers in this list are **kept**; all others are removed.\n* `blacklist` – Headers in this list are **removed** regardless of whitelist.\n* Header names are **case-insensitive**.\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\napp.use(sanitizeHeaders());\n```\n\n* With defaults, all headers are allowed unless explicitly removed elsewhere.\n\n---\n\n### Whitelist Only\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\"],\n  })\n);\n```\n\n* Keeps only `Content-Type` and `Authorization` headers; all others are removed.\n\n---\n\n### Blacklist Only\n\n```ts\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\"],\n  })\n);\n```\n\n* Removes `X-Powered-By` and `Server` headers, while keeping all others.\n\n---\n\n### Combined Whitelist & Blacklist\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\", \"accept\"],\n    blacklist: [\"x-powered-by\"],\n  })\n);\n```\n\n* Keeps only headers in whitelist, except those in blacklist (`X-Powered-By` is removed even if present in whitelist).\n\n---\n\n## Middleware Type\n\n```ts\nfunction sanitizeHeaders(options?: SanitizeHeadersOptions): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Should be applied **before sending response** to ensure headers are sanitized.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport { router } from \"tezx\";\nimport sanitizeHeaders from \"tezx/middleware/sanitizeHeaders\";\n\nrouter.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n  })\n);\n\nrouter.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Headers sanitized!\" });\n});\n```\n\n* Ensures that only allowed headers are present in the response.\n\n---\n"
        },
        {
          "originalPath": "Secure Headers.md",
          "id": 32,
          "name": "Secure Headers",
          "type": "file",
          "path": "middleware/secure-headers",
          "content": "\n# **`secureHeaders` Middleware**\n\n`secureHeaders` is a TezX-compatible middleware for adding **HTTP security headers** like HSTS, CSP, X-Frame-Options, and more. It supports presets, custom configurations, and optional per-request CSP nonces. Optimized for both **production** and **development**.\n\n---\n\n## **Installation**\n\n```ts\nimport { secureHeaders } from 'tezx/middleware';\n```\n\n---\n\n## **Usage Example**\n\n```ts\napp.use(secureHeaders({\n  preset: 'strict',       // strong defaults\n  cspUseNonce: true,      // generate per-request nonce for inline scripts\n}));\n```\n\n---\n\n## **Preset Options**\n\n| Preset     | Description                                                                                      |\n| ---------- | ------------------------------------------------------------------------------------------------ |\n| `strict`   | Strongest security for production: HSTS 2yrs, CSP enforcement, frame-guard DENY, XSS & sniffing. |\n| `balanced` | Default preset for most apps: reasonable headers, CSP report-only.                               |\n| `dev`      | Development mode: permissive headers, allows localhost, unsafe-inline scripts.                   |\n\n---\n\n## **SecureHeadersOptions & What Each Option Does**\n\n```ts\nexport type SecureHeadersOptions = {\n    preset?: \"strict\" | \"balanced\" | \"dev\";\n    hsts?: HstsOptions;\n    frameGuard?: \"DENY\" | \"SAMEORIGIN\" | string;\n    noSniff?: boolean;\n    xssProtection?: boolean;\n    referrerPolicy?: string;\n    permissionsPolicy?: string;\n    csp?: string | Record<string, string | string[]>;\n    cspReportOnly?: boolean;\n    cspUseNonce?: boolean;\n    ultraFastMode?: boolean;\n};\n```\n\n---\n\n### 1. **preset**\n\n* Chooses a pre-configured security set.\n* Default: `\"balanced\"`\n* **Use Case:** Quick setup without manual configuration.\n* **Example:** `'strict'` for production, `'dev'` for local development.\n\n---\n\n### 2. **hsts** (HTTP Strict Transport Security)\n\n* Adds `Strict-Transport-Security` header.\n* Forces HTTPS and optionally applies to subdomains.\n* **Example:**\n\n```ts\n{\n  maxAge: 31536000,          // 1 year\n  includeSubDomains: true,   // apply to all subdomains\n  preload: true,             // for browser preload list\n  hstsOnlyOnHttps: true,     // only on HTTPS requests\n}\n```\n\n* **Use Case:** Prevent man-in-the-middle attacks over HTTP.\n* **Tip:** Only use `preload` if you are confident about HTTPS everywhere.\n\n---\n\n### 3. **frameGuard**\n\n* Sets `X-Frame-Options` header to prevent clickjacking.\n* **Values:**\n\n  * `'DENY'` → never allow framing\n  * `'SAMEORIGIN'` → allow only same-origin\n  * custom string allowed\n* **Default:** `'SAMEORIGIN'`\n* **Use Case:** Prevent your site being embedded in iframes to avoid UI redress attacks.\n\n---\n\n### 4. **noSniff**\n\n* Sets `X-Content-Type-Options: nosniff`.\n* Prevents browsers from MIME type sniffing.\n* **Default:** true for strict/balanced presets.\n* **Use Case:** Stops content misinterpretation vulnerabilities.\n\n---\n\n### 5. **xssProtection**\n\n* Sets `X-XSS-Protection: 1; mode=block`.\n* Legacy protection for older browsers.\n* **Default:** true for strict/balanced presets.\n* **Use Case:** Extra protection in legacy browsers; modern browsers rely on CSP.\n\n---\n\n### 6. **referrerPolicy**\n\n* Sets `Referrer-Policy` header.\n* **Examples:** `\"no-referrer\"`, `\"strict-origin-when-cross-origin\"`.\n* **Use Case:** Control what referrer info browsers send, improves privacy/security.\n* **Default:** preset-dependent.\n\n---\n\n### 7. **permissionsPolicy**\n\n* Sets `Permissions-Policy` header (formerly Feature-Policy).\n* **Controls:** access to features like geolocation, microphone, camera.\n* **Example:** `'geolocation=(), microphone=()'`\n* **Use Case:** Limit access to sensitive APIs to reduce attack surface.\n\n---\n\n### 8. **csp** (Content Security Policy)\n\n* Prevents XSS, data injection, and unsafe script execution.\n* Can be a **string** or an **object map** of directives:\n\n```ts\n{\n  \"default-src\": [\"'self'\"],\n  \"script-src\": [\"'self'\", \"https://cdn.example.com\"],\n  \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n}\n```\n\n* **Use Case:** Strict CSP prevents malicious script execution.\n* **Tip:** Use object to precompute string at middleware init for performance.\n\n---\n\n### 9. **cspReportOnly**\n\n* Sends `Content-Security-Policy-Report-Only` instead of enforcement.\n* **Use Case:** Test CSP without blocking scripts.\n\n---\n\n### 10. **cspUseNonce**\n\n* Generates **per-request nonce** for inline scripts.\n* Injected as `'nonce-<value>'` in `script-src`.\n* Inline scripts must use same nonce:\n\n```html\n<script nonce=\"ctx.cspNonce\">\n  console.log(\"Allowed inline script\");\n</script>\n```\n\n* **Use Case:** Allows safe inline scripts without `'unsafe-inline'`.\n\n---\n\n### 11. **ultraFastMode**\n\n* Disables per-request allocations (like nonce generation).\n* Useful for **high-QPS APIs**.\n* **Use Case:** Skip nonce if inline scripts are not needed.\n\n---\n\n## **HSTS Options (HstsOptions)**\n\n```ts\nexport interface HstsOptions {\n    maxAge?: number;             // in seconds\n    includeSubDomains?: boolean; // apply to all subdomains\n    preload?: boolean;           // add to browser preload list\n    hstsOnlyOnHttps?: boolean;   // only apply on HTTPS\n}\n```\n\n---\n\n## **Middleware Flow**\n\n1. Checks protocol (HSTS only on HTTPS if configured)\n2. Sets core headers:\n\n   * `X-Frame-Options`\n   * `X-Content-Type-Options`\n   * `X-XSS-Protection`\n   * `Referrer-Policy`\n   * `Permissions-Policy`\n3. Sets CSP headers:\n\n   * `Content-Security-Policy` or `Content-Security-Policy-Report-Only`\n   * Optionally includes per-request nonce\n4. Passes context to `next()` middleware.\n\n---\n\n## **Example with Inline Scripts (Nonce)**\n\n```ts\napp.use(secureHeaders({ cspUseNonce: true }));\n\n// Template:\n<script nonce=\"<%= ctx.cspNonce %>\">\n  console.log(\"This inline script is allowed!\");\n</script>\n```\n\n---\n\n## **Developer Notes / Tips**\n\n* **Strict preset:** production-ready, enforce all headers.\n* **Balanced preset:** good for initial deployment; CSP report-only.\n* **Dev preset:** permissive for local dev; allows unsafe-inline.\n* **UltraFastMode:** skip nonce generation for high-QPS APIs.\n* Always use **HTTPS** when HSTS is enabled.\n* **Nonce values** are per-request and cryptographically random (if using `generateRandomBase64`).\n\n---\n\n## **Quick Reference: What each header does**\n\n| Header                                | Purpose                                                                    |\n| ------------------------------------- | -------------------------------------------------------------------------- |\n| `Strict-Transport-Security`           | Forces HTTPS, prevents MITM, optional preload                              |\n| `X-Frame-Options`                     | Prevent clickjacking (DENY / SAMEORIGIN)                                   |\n| `X-Content-Type-Options`              | Stops MIME sniffing (`nosniff`)                                            |\n| `X-XSS-Protection`                    | Legacy XSS protection in older browsers                                    |\n| `Referrer-Policy`                     | Controls which referrer info browsers send                                 |\n| `Permissions-Policy`                  | Controls access to sensitive browser APIs                                  |\n| `Content-Security-Policy`             | Controls scripts, styles, images, etc., prevents XSS and injection attacks |\n| `Content-Security-Policy-Report-Only` | Test-only CSP enforcement without blocking scripts                         |\n\n## **Full Example:**\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\n// Use secureHeaders middleware\napp.use(\n  secureHeaders({\n    preset: \"strict\",        // strongest security\n    cspUseNonce: true,       // generate nonce per request\n    ultraFastMode: false,    // allow nonce generation\n  })\n);\n\n// Example route\napp.get(\"/\", (ctx) => {\n  // If cspUseNonce is enabled, nonce is available in ctx.cspNonce\n  const nonce = ctx.cspNonce || \"fallback-nonce\";\n  return ctx.html(`\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <title>Secure Headers Example</title>\n        <script nonce=\"${nonce}\">\n          console.log(\"This inline script is allowed by CSP nonce!\");\n        </script>\n      </head>\n      <body>\n        <h1>Hello Secure World!</h1>\n      </body>\n    </html>\n  `);\n});\n\n```\n\n---\n"
        },
        {
          "originalPath": "XSS Protection.md",
          "id": 33,
          "name": "XSS Protection",
          "type": "file",
          "path": "middleware/xss-protection",
          "content": "# 🛡️ XSS Protection Middleware (`xssProtection`)\n\nThe `xssProtection` middleware **adds HTTP headers to protect against Cross-Site Scripting (XSS) attacks**. It sets the `X-XSS-Protection` header and optionally a fallback `Content-Security-Policy` (CSP) for enhanced security.\n\nThis middleware is lightweight and ideal for **web apps, APIs, or any server-rendered content**.\n\n---\n\n## 📦 Import\n\n```ts\n// Named import\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type XSSProtectionOptions = {\n  enabled?: boolean | ((ctx: Context) => boolean);\n  // Whether XSS protection is enabled\n  // Default: true\n  // Can also be a function to enable/disable dynamically per request\n\n  mode?: \"block\" | \"filter\";\n  // Protection mode\n  // Default: \"block\"\n  // \"block\": Prevent page rendering if XSS detected\n  // \"filter\": Attempt to sanitize content\n\n  fallbackCSP?: string;\n  // Fallback Content-Security-Policy header\n  // Default: \"default-src 'self'; script-src 'self';\"\n  // Can be customized to allow trusted CDNs or stricter policies\n};\n```\n\n---\n\n## 🧩 Behavior\n\n1. Determines if protection is **enabled**.\n\n   * Can be static (`true`/`false`) or dynamic using a callback function.\n2. Sets the `X-XSS-Protection` header:\n\n   * `1; mode=block` → blocks rendering on XSS detection.\n   * `1` → filters the XSS content without blocking.\n3. Sets a **fallback CSP header** (`Content-Security-Policy`) if none is present.\n4. Calls the **next middleware** in the chain.\n\n---\n\n## ✅ Default Usage\n\n```ts\nimport {xssProtection} from \"tezx/middleware\";\n\napp.use(xssProtection());\n```\n\n* Enables XSS protection in **block mode**.\n* Adds default fallback CSP:\n  `default-src 'self'; script-src 'self';`\n* Works for all incoming requests.\n\n---\n\n## ⚙️ Custom Configuration\n\n```ts\napp.use(\n  xssProtection({\n    mode: \"filter\", // sanitize instead of blocking\n    fallbackCSP: \"default-src 'self'; script-src 'self' https://trusted.cdn.com\",\n  })\n);\n```\n\n* Filters XSS content instead of blocking.\n* Allows scripts from trusted CDNs via CSP.\n\n---\n\n## 🔄 Dynamic Enabling per Request\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n  })\n);\n```\n\n* Enables XSS protection **only for non-admin routes**.\n* Dynamic decision can be based on user role, path, headers, or any context property.\n\n---\n\n## 🧩 Headers Set by Middleware\n\n| Header                    | Description                                                        |\n| ------------------------- | ------------------------------------------------------------------ |\n| `X-XSS-Protection`        | Activates browser XSS filtering (`1` or `1; mode=block`)           |\n| `Content-Security-Policy` | Fallback CSP policy if none is set, provides additional mitigation |\n\n---\n\n## 💡 Best Practices\n\n* Always enable XSS protection for **public-facing routes**.\n* Use **block mode** (`mode: \"block\"`) in production for strong security.\n* Add a **fallback CSP** to prevent script injection from untrusted sources.\n* Use **dynamic `enabled`** to disable for trusted internal routes if needed.\n* Combine with other middlewares like `cors` or `logger` for full-stack security.\n\n---\n\n## 🔧 Full Example: Web App Integration\n\n```ts\nimport xssProtection from \"tezx/middleware/xssProtection\";\nimport logger from \"tezx/middleware/logger\";\nimport cors from \"tezx/middleware/cors\";\n\napp.use(cors());\napp.use(logger());\napp.use(\n  xssProtection({\n    mode: \"block\",\n    fallbackCSP: \"default-src 'self'; script-src 'self' https://cdn.example.com\",\n    enabled: (ctx) => !ctx.user?.isAdmin, // Skip admin panel\n  })\n);\n\napp.get(\"/\", (ctx) => {\n  ctx.send(\"<h1>Hello, World!</h1>\");\n});\n```\n\n* **Public pages** have full XSS protection.\n* **Admin panel** can disable blocking for convenience.\n* CSP ensures scripts are loaded only from trusted sources.\n\n---\n"
        },
        {
          "originalPath": "i18.md",
          "id": 34,
          "name": "i18",
          "type": "file",
          "path": "middleware/i18",
          "content": "# 🌍 TezX i18n Middleware\n\n## Overview\n\n`i18n` middleware adds **multi-language (internationalization)** support to TezX applications.\nIt automatically detects the user's preferred language, loads translation files, caches them (in-memory or via custom adapter), and provides a simple translation function (`ctx.t`) inside every request.\n\n---\n\n## ⚙️ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/middleware\";\n\napp.use(\n  i18n({\n    loadTranslations: async (lang) => import(`./locales/${lang}.json`),\n    detectLanguage: (ctx) => ctx.req.query.lang || \"en\",\n    defaultLanguage: \"en\",\n  })\n);\n```\n\nNow every request will have:\n\n```ts\nctx.t(\"greeting.hello\"); // returns \"Hello\"\nctx.t(\"user.welcome\", { name: \"Rakibul\" }); // interpolates variables\n```\n\n---\n\n## 🧠 How It Works\n\n| Step | Description                                                                |\n| ---- | -------------------------------------------------------------------------- |\n| 1️⃣  | Detects the preferred language using `detectLanguage(ctx)`                 |\n| 2️⃣  | Loads translations dynamically via `loadTranslations(language)`            |\n| 3️⃣  | Optionally caches translations in memory or a custom adapter (e.g., Redis) |\n| 4️⃣  | Attaches a translation helper (`ctx.t`) to the context                     |\n| 5️⃣  | Interpolates variables in messages like `{{name}}`                         |\n| 6️⃣  | Fallbacks to `defaultLanguage` if translation missing                      |\n\n---\n\n## 🧩 Example — Simple Setup\n\n### Directory structure\n\n```bash\n/locales\n  ├── en.json\n  └── bn.json\n```\n\n### en.json\n\n```json\n{\n  \"greeting\": {\n    \"hello\": \"Hello\",\n    \"welcome\": \"Welcome, {{name}}!\"\n  }\n}\n```\n\n### Middleware setup\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => import(`./locales/${lang}.json`),\n    detectLanguage: (ctx) => ctx.req.query.lang || \"en\",\n    defaultLanguage: \"en\"\n  })\n);\n```\n\n### Usage in route\n\n```ts\nrouter.get(\"/hi\", (ctx) => {\n  return ctx.t(\"greeting.welcome\", { name: \"Rakibul\" });\n});\n```\n\n✅ Output:\nIf `?lang=en` → `\"Welcome, Rakibul!\"`\nIf `?lang=bn` → `\"স্বাগতম, Rakibul!\"`\n\n---\n\n## ⚡ Caching\n\nThe middleware supports **translation caching** to improve performance.\n\n### 🧠 In-memory cache (default)\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true, // enables Map-based local cache\n  })\n);\n```\n\n### 💾 External cache (Redis, Memcached, etc.)\n\nYou can implement your own cache adapter by extending `I18nCacheAdapter`.\n\n```ts\nconst redisCache = {\n  async get(lang) {\n    const data = await redis.get(`i18n:${lang}`);\n    return data ? JSON.parse(data) : null;\n  },\n  async set(lang, data) {\n    await redis.set(`i18n:${lang}`, JSON.stringify(data), \"PX\", data.expiresAt - Date.now());\n  },\n  async delete(lang) {\n    await redis.del(`i18n:${lang}`);\n  },\n};\n\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true,\n    cacheStorage: redisCache,\n  })\n);\n```\n\n---\n\n## 🧩 Options Reference (Full)\n\n| Option                       | Type                                        | Default                | Description                                                     |\n| ---------------------------- | ------------------------------------------- | ---------------------- | --------------------------------------------------------------- |\n| **`loadTranslations`**       | `(lang: string) => Promise<TranslationMap>` | —                      | Function to load translations dynamically (from JSON, DB, etc.) |\n| **`detectLanguage`**         | `(ctx: Context) => string`                  | —                      | Determines which language to use for the request                |\n| **`defaultLanguage`**        | `string`                                    | `\"en\"`                 | Fallback language if requested language unavailable             |\n| **`defaultCacheDuration`**   | `number`                                    | `3600000` (1 hour)     | How long cached translations stay valid                         |\n| **`translationFunctionKey`** | `string`                                    | `\"t\"`                  | Property name for translator function attached to `ctx`         |\n| **`formatMessage`**          | `(msg, vars) => string`                     | Interpolates `{{var}}` | Custom variable interpolation logic                             |\n| **`isCacheValid`**           | `(cached, lang) => boolean`                 | Expiry check           | Determines if cache entry is still valid                        |\n| **`cacheTranslations`**      | `boolean`                                   | `false`                | Enables or disables caching                                     |\n| **`cacheStorage`**           | `I18nCacheAdapter`                          | `null`                 | Custom cache (e.g., Redis, file system, DB)                     |\n\n---\n\n## 🧩 Example — Custom Format Function\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    formatMessage: (msg, vars) =>  msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars?.[k] ?? \"\"),\n  })\n);\n```\n\n✅ `\"Hello {name}\" → \"Hello Rakibul\"`\n\n---\n\n## 🧩 Example — Custom Language Detection\n\nYou can detect language from:\n\n* Query params (`?lang=bn`)\n* Headers (`Accept-Language`)\n* Cookies (`ctx.cookies.get('lang')`)\n\n```ts\ndetectLanguage: (ctx) =>\n  ctx.req.query.lang || ctx.cookies.get(\"lang\") || ctx.req.headers[\"accept-language\"]?.split(\",\")[0] || \"en\"\n```\n\n---\n\n## 🧩 Example — File-based Cache Adapter\n\nFor servers without Redis:\n\n```ts\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nconst fileCache = {\n  async get(lang) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    try {\n      const content = JSON.parse(await fs.readFile(file, \"utf-8\"));\n      return content;\n    } catch {\n      return null;\n    }\n  },\n  async set(lang, data) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    await fs.mkdir(\"./cache\", { recursive: true });\n    await fs.writeFile(file, JSON.stringify(data), \"utf-8\");\n  },\n  async delete(lang) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    await fs.unlink(file).catch(() => {});\n  },\n};\n```\n\nThen plug it in:\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true,\n    cacheStorage: fileCache,\n  })\n);\n```\n\n---\n\n## 🧩 Example — Custom Cache Validation\n\n```ts\nisCacheValid: (cached, lang) => {\n  // Reload if file modified recently\n  const file = `./locales/${lang}.json`;\n  const lastModified = fs.statSync(file).mtimeMs;\n  return cached.expiresAt > Date.now() && cached.expiresAt > lastModified;\n}\n```\n\n---\n\n## 🧩 Error Handling\n\nIf any error occurs during translation loading, caching, or formatting,\nthe middleware throws a structured `TezXError`:\n\n```ts\ntry {\n  await next();\n} catch (err) {\n  if (err instanceof TezXError) {\n    console.error(\"i18n failed:\", err.message);\n  }\n}\n```\n\n---\n\n## 🧩 Example — Using Translations in Templates or API\n\n```ts\nrouter.get(\"/about\", (ctx) => {\n  return {\n    title: ctx.t(\"page.about.title\"),\n    description: ctx.t(\"page.about.description\"),\n  };\n});\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "7. Helpers",
      "name": "Helpers",
      "path": "helpers",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Cookie.md",
          "id": 35,
          "name": "Cookie",
          "type": "file",
          "path": "helpers/cookie",
          "content": "\n# 🍪 Cookie Utilities – TezX Helper\n\nA utility module for managing HTTP cookies within TezX applications. This includes reading, setting, parsing, and deleting cookies in a type-safe and consistent manner.\n\n---\n\n## 📦 Import\n\n```ts\nimport {\n  getCookie,\n  allCookies,\n  setCookie,\n  deleteCookie,\n  serializeOptions,\n} from \"tezx/helper\";\n```\n\n---\n\n## 🧰 API Reference\n\n### 🔍 `getCookie(ctx: Context, name: string): string | undefined`\n\nRetrieve the value of a specific cookie from the incoming HTTP request.\n\n#### **Parameters for `getCookie`**\n\n* `ctx`: The request context.\n* `name`: The name of the cookie.\n\n#### **Returns**\n\n* The decoded cookie value if found, otherwise `undefined`.\n\n#### **Example**\n\n```ts\nconst session = getCookie(ctx, \"session_id\")\nif (session) {\n  console.log(\"Active session:\", session);\n}\n```\n\n---\n\n### 📋 `allCookies(ctx: Context): Record<string, string>`\n\nParse all cookies from the request and return them as an object.\n\n#### **Parameters**\n\n* `ctx`: The request context.\n\n#### **Returns**\n\n* A key-value map of all cookies.\n\n#### **Example**\n\n```ts\nconst cookies = allCookies(ctx);\nconsole.log(\"Cookies:\", cookies);\n```\n\n---\n\n### ➕ `setCookie(ctx: Context, name: string, value: string, options?: CookieOptions): void`\n\nSet a cookie on the response using optional attributes.\n\n#### **Parameters for `setCookie`**\n\n* `ctx`: The response context.\n* `name`: The name of the cookie.\n* `value`: The value to store.\n* `options` *(optional)*: Configuration like expiration, security flags, etc.\n\n#### **Example**\n\n```ts\nsetCookie(ctx, \"session_id\", \"abc123\", {\n  httpOnly: true,\n  secure: true,\n  maxAge: 3600,\n  path: \"/\",\n});\n```\n\n---\n\n### ❌ `deleteCookie(ctx: Context, name: string, options?: CookieOptions): void`\n\nDelete a cookie by expiring it immediately.\n\n#### **Parameters for `deleteCookie`**\n\n* `ctx`: The response context.\n* `name`: The cookie to remove.\n* `options` *(optional)*: Must match original cookie attributes (e.g., `path`, `domain`) to ensure deletion.\n\n#### **Example**\n\n```ts\ndeleteCookie(ctx, \"session_id\", { path: \"/\" });\n```\n\n---\n\n### 🛠️ `serializeOptions(options: CookieOptions): string`\n\nSerialize a cookie options object into a valid `Set-Cookie` string fragment.\n\n> Used internally, but available for custom header construction if needed.\n\n#### **Parameters for `serializeOptions`**\n\n* `options`: An object describing cookie settings.\n\n#### **Returns**\n\n* A string representation suitable for HTTP headers.\n\n#### **Example**\n\n```ts\nconst header = serializeOptions({ maxAge: 3600, httpOnly: true });\n// Output: \"Max-Age=3600; HttpOnly\"\n```\n\n---\n\n## 📑 `CookieOptions` Interface\n\nUse this interface to configure cookie behavior:\n\n| Property   | Type                              | Description                                              |\n| ---------- | --------------------------------- | -------------------------------------------------------- |\n| `maxAge`   | `number`                          | Lifetime of the cookie (in seconds).                     |\n| `expires`  | `Date`                            | Absolute expiry timestamp.                               |\n| `path`     | `string`                          | Path scope of the cookie.                                |\n| `domain`   | `string`                          | Domain scope of the cookie.                              |\n| `secure`   | `boolean`                         | Send only over HTTPS.                                    |\n| `httpOnly` | `boolean`                         | Restrict access from JavaScript.                         |\n| `sameSite` | `'Strict'` \\| `'Lax'` \\| `'None'` | Restrict cross-site cookie behavior for CSRF protection. |\n\n---\n\n## ✅ Best Practices\n\n* Always use `httpOnly` and `secure` for sensitive cookies.\n* Use `path` and `domain` to avoid scope conflicts.\n* Set `sameSite: 'Strict'` or `'Lax'` for CSRF mitigation.\n* Call `deleteCookie()` with matching `path` and `domain` for successful removal.\n\n---\n"
        },
        {
          "originalPath": "2. useFormData.md",
          "id": 36,
          "name": "useFormData",
          "type": "file",
          "path": "helpers/useformdata",
          "content": "\n# 🚀 `useFormData` — Multipart Form & File Upload Handler\n\n`useFormData` is a powerful helper designed for efficient parsing, validation, and management of **multipart/form-data** HTTP requests in TezX applications. It simplifies handling complex file uploads combined with form fields while enforcing strict limits to protect your server from overload and security risks.\n\n```mermaid\nsequenceDiagram\n  participant Client\n  participant TezX\n  participant useFormData\n  participant Validators\n  participant FileProcessor\n\n\n  Client->>TezX: POST /upload (multipart/form-data)\n  TezX->>useFormData: useFormData(ctx, options)\n  useFormData->>Validators: Validate text fields & limits\n  useFormData->>FileProcessor: Validate & process files\n  FileProcessor-->>useFormData: processed files\n  Validators-->>useFormData: validated text fields\n  useFormData-->>TezX: { fieldName: value | File | Array }\n  TezX-->>Client: response\n```\n\n---\n\n## 🔧 Function Signature\n\n```ts\nimport { Context,FormDataOptions } from \"tezx\";\n\nexport async function useFormData(\n  ctx: Context,\n  options?: FormDataOptions\n): Promise<Record<string, string | File | (string | File)[]>>;\n```\n\n---\n\n## 🔥 Core Features\n\n* **Full multipart/form-data parsing** for text fields and file uploads\n* **Automatic merging** of repeated fields into arrays\n* **File validation:**\n\n  * MIME type whitelist\n  * Max file size per file\n  * Max number of files per field\n  * Max total upload size (combined all files)\n* **Text field validation:**\n\n  * Max size per text field (bytes/characters)\n  * Optional sanitization (trimming, escaping)\n* **Streaming-aware file processing** for large uploads (configurable)\n* Detailed **error handling** with descriptive messages\n* Easily **extensible** to add custom file processors or virus scanners\n\n---\n\n## 🔹 Parameters\n\n| Name      | Type              | Description                                                         |\n| --------- | ----------------- | ------------------------------------------------------------------- |\n| `ctx`     | `Context`         | TezX request context with the incoming multipart HTTP request       |\n| `options` | `FormDataOptions` | Optional configuration object to control validations and processing |\n\n---\n\n## 🔸 Returns\n\nPromise resolving to an object mapping field names to:\n\n* **string** — for text form fields\n* **File** — for single uploaded files\n* **Array\\<string | File>** — for repeated fields (multiple values/files)\n\n---\n\n## ⚙️ FormDataOptions Interface\n\n| Property       | Type       | Description                                                                     |\n| -------------- | ---------- | ------------------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | Enables sanitization of text inputs (trimming, escaping, etc.)                  |\n| `allowedTypes` | `string[]` | MIME types allowed for file uploads (e.g., `[\"image/jpeg\", \"application/pdf\"]`) |\n| `maxSize`      | `number`   | Maximum size (in bytes) allowed per individual file                             |\n| `maxFiles`     | `number`   | Maximum number of files accepted per single field                               |\n| `maxTotalSize` | `number`   | Maximum combined size (in bytes) allowed for all files in the request           |\n| `maxFieldSize` | `number`   | Maximum allowed length (characters or bytes) for text fields                    |\n\n---\n\n## 🔍 Detailed Behavior\n\n### 1. **Multipart Form Parsing**\n\nThe function calls `ctx.req.formData()` internally to parse the multipart form. It then iterates over all fields and files, applying the configured validations.\n\n### 2. **File Handling**\n\n* **File Size:** Each file is checked against the `maxSize` option. Files exceeding this size are rejected immediately.\n* **File Count:** Enforces a strict maximum number of files per field via `maxFiles`.\n* **MIME Type Validation:** If `allowedTypes` is specified, files not matching allowed MIME types are rejected.\n* **Total Upload Size:** Keeps a running total of all uploaded file bytes and throws if the `maxTotalSize` is exceeded.\n* **Extensible Processing:** Internally calls a customizable `processFile` function for potential streaming, virus scanning, or on-the-fly compression.\n\n### 3. **Text Field Handling**\n\n* Checks each string field against `maxFieldSize` for length.\n* Optionally sanitizes text fields when `sanitized` is enabled (trimming whitespace, escaping dangerous chars).\n\n### 4. **Duplicate Field Names**\n\nFields with the same name are grouped into arrays, supporting inputs like:\n\n```html\n<input type=\"file\" name=\"photos\" multiple>\n<input type=\"text\" name=\"tags\">\n<input type=\"text\" name=\"tags\">\n```\n\n---\n\n## 🛡️ Error Handling & Security\n\n* Throws clear, actionable errors on exceeding any configured limits (size, count, type).\n* Prevents large unexpected uploads from exhausting memory or disk space.\n* Supports input sanitization to prevent injection or XSS attacks from text fields.\n* Encourages defining strict `allowedTypes` and `maxSize` to avoid malicious uploads.\n\n---\n\n## ⚡ Example Usage (Robust File Upload)\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nasync function uploadHandler(ctx: Context) {\n  try {\n    const form = await useFormData(ctx, {\n      allowedTypes: [\"image/jpeg\", \"image/png\", \"application/pdf\"],\n      maxSize: 10 * 1024 * 1024,       // 10MB max per file\n      maxFiles: 5,                     // Max 5 files per field\n      maxTotalSize: 50 * 1024 * 1024, // 50MB combined limit\n      maxFieldSize: 2000,              // Max 2000 chars for text fields\n      sanitized: true,                 // Trim & sanitize text inputs\n    });\n\n    // Access text fields and files\n    const username = form[\"username\"];\n    const profilePics = form[\"photos\"]; // Array of File objects\n\n    // Process or store files\n    for (const file of Array.isArray(profilePics) ? profilePics : [profilePics]) {\n      // e.g. save to disk, cloud storage, virus scan, etc.\n      console.log(`Uploading file: ${file.name} (${file.size} bytes)`);\n    }\n\n    return ctx.text(\"Upload successful!\");\n  } catch (err) {\n    // Handle validation errors\n    return ctx.status(400).text(err.message);\n  }\n}\n```\n\n---\n"
        },
        {
          "originalPath": "3. Load Environment.md",
          "id": 37,
          "name": "Load Environment",
          "type": "file",
          "path": "helpers/load-environment",
          "content": "\n---\n\n# `loadEnv(basePath?: string)`\n\n**Purpose:** Load `.env` files into `process.env` (Node/Bun) or `Deno.env` and get a **typed object** for safe access.\n\n**Supported `.env` Files (Priority):**\n\n```bash\n.env → .env.local → .env.[mode] → .env.[mode].local\n```\n\n**Return Type:**\n\n```ts\ntype EnvVariables = {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n};\n```\n\n**Usage:**\n\n```ts\nimport { loadEnv } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\"\n\nconst env = loadEnv(\"./config\");\nconst port = env.PORT || process.env.PORT || \"3000\";\n```\n\n---\n\n# Custom Context\n\n**Purpose:** Extend TezX’s `Context` with your own properties (e.g., user info, request metadata).\n\n**Example:**\n\n```ts\ninterface CustomContext {\n  user?: { id: string; roles: string[] };\n  requestId: string;\n}\n\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return next();\n});\n\napp.get(\"/me\", (ctx) => ctx.json(ctx.user));\n```\n\n---\n\n# Server Initialization with Env & Custom Context\n\n```ts\nconst env = loadEnv();\n\nconst app = new TezX<CustomContext>({ env });\n\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n**Options Table:**\n\n| Option | Type           | Description                    |\n| ------ | -------------- | ------------------------------ |\n| `env`  | `EnvVariables` | Injected environment variables |\n\nAccess via `ctx.env` safely in middleware/routes.\n\n---\n\n# Best Practices\n\n* **.env per mode:**\n\n```bash\n.env.development\n.env.production\n.env.production.local\n```\n\n* **Git ignore sensitive files:**\n\n```bash\n.env.local\n.env.*.local\n```\n\n* **Feature flags:**\n\n```ts\nif (env.FEATURE_X === \"enabled\") enableExperimentalFeature();\n```\n\n---\n\n# Advanced Context Usage\n\n```ts\ninterface AppContext {\n  user?: User;\n  analytics: Tracker;\n}\n\napp.use((ctx, next) => {\n  ctx.analytics = new Tracker(ctx.env.TRACKING_ID);\n  return next();\n});\n```\n\n---\n"
        },
        {
          "originalPath": "4. JWT.md",
          "id": 38,
          "name": "JWT",
          "type": "file",
          "path": "helpers/jwt",
          "content": "# TezX JWT Module – Developer Documentation\n\n## Overview\n\n`tezx/jwt` is a **lightweight, dependency-free JSON Web Token (JWT) module** designed for the TezX framework. It provides **signing, verification, and expiration management** for JWTs using either:\n\n- **Node.js crypto** (for server-side)\n- **WebCrypto API** (for modern runtimes: browser, Deno, Bun)\n\nKey Features:\n\n- ✅ Pure implementation (no external dependencies)\n- ⚡ Supports `HS256` and `HS512` algorithms\n- ⏱ Flexible expiration format (`\"1h\"`, `\"2d\"`, `\"30m\"`, numeric seconds)\n- 🔒 Safe Base64URL encoding/decoding (RFC 7515)\n- 🧩 Works in **Node.js**, **Bun**, **Deno**, or TezX server environment\n- 📦 Easy to integrate as a middleware or standalone utility\n\n---\n\n## Installation\n\n```bash\n# if using npm/yarn\nnpm install tezx\n# or\nyarn add tezx\n```\n\n---\n\n## Importing\n\n```ts\nimport { sign, verify } from \"tezx/jwt/web\"; // For WebCrypto-compatible runtimes\n// or\nimport { sign, verify } from \"tezx/jwt/node\"; // Node.js-compatible\n```\n\n- `sign` – generate JWT token\n- `verify` – decode & verify JWT token\n\n---\n\n## Functions\n\n### 1. `sign(payload, options)`\n\nGenerates a signed JWT token.\n\n**Parameters**:\n\n| Parameter           | Type                  | Description                                                                         |                                          |\n| ------------------- | --------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------- |\n| `payload`           | `Record<string, any>` | The data or claims to include in the token                                          |                                          |\n| `options`           | `Object`              | Optional configuration                                                              |                                          |\n| `options.secret`    | `string`              | Secret key to sign the token (default: `process.env.JWT_SECRET` or `\"tezx_secret\"`) |                                          |\n| `options.algorithm` | `\"HS256\"              | \"HS512\"`                                                                            | Hash algorithm to use (default: `HS256`) |\n| `options.expiresIn` | `string \\| number`    | Token expiration, e.g., `\"2h\"`, `\"7d\"`, `3600` (seconds)                            |                                          |\n\n**Returns**: `string` – signed JWT token in format `header.payload.signature`\n\n**Example**:\n\n```ts\nimport { sign } from \"tezx/jwt/node\";\n\nconst token = sign(\n  { userId: 101, role: \"trainer\" },\n  { secret: \"5435345\", algorithm: \"HS512\", expiresIn: \"2h\" },\n);\n\nconsole.log(\"JWT:\", token);\n```\n\n> ⚡ **WebCrypto version** returns a `Promise<string>`.\n\n---\n\n### 2. `verify(token, secret)`\n\nVerifies a JWT token and returns the payload if valid.\n\n**Parameters**:\n\n| Parameter | Type     | Description                                                                              |\n| --------- | -------- | ---------------------------------------------------------------------------------------- |\n| `token`   | `string` | The JWT string to verify                                                                 |\n| `secret`  | `string` | Secret key used to sign the token (default: `process.env.JWT_SECRET` or `\"tezx_secret\"`) |\n\n**Returns**:\n\n- `Record<string, any>` – decoded payload if token is valid and not expired\n- `null` – if invalid or expired\n\n**Example**:\n\n```ts\nimport { verify } from \"tezx/jwt/node\";\n\nconst decoded = verify(token, \"5435345\");\n\nif (decoded) {\n  console.log(\"User ID:\", decoded.userId);\n} else {\n  console.log(\"Invalid or expired token\");\n}\n```\n\n> ⚡ **WebCrypto version** returns `Promise<Record<string, any> | null>`.\n\n---\n\n## Base64URL Encoding (internal)\n\nThe module automatically encodes and decodes JWT parts using **Base64URL**:\n\n```ts\nimport { sign } from \"tezx/jwt/node\";\n\nconst token = sign({ userId: 1 });\n// Base64URL ensures URL-safe JWT with no padding\n```\n\n> Do **not manually modify** JWT parts unless you follow RFC 7515 rules.\n\n---\n\n## Expiration Handling\n\n- Human-readable string formats:\n  - `\"30m\"` → 30 minutes\n  - `\"2h\"` → 2 hours\n  - `\"1d\"` → 1 day\n\n- Numeric seconds: `3600` → 1 hour\n- Default expiration is **1 day** if not provided\n\n```ts\nconst token = sign({ userId: 1 }, { expiresIn: \"2h\" });\n```\n\n---\n\n## TezX Middleware Example\n\nYou can create a middleware for protected routes:\n\n```ts\nimport { verify } from \"tezx/jwt/node\";\n\nexport function jwtMiddleware({ secret }) {\n  return async (ctx, next) => {\n    const auth = ctx.headers.get(\"authorization\") || \"\";\n    const token = auth.startsWith(\"Bearer \") ? auth.slice(7) : null;\n\n    if (!token) return ctx.status(401).json({ error: \"Missing token\" });\n\n    const payload = verify(token, secret);\n    if (!payload)\n      return ctx.status(401).json({ error: \"Invalid or expired token\" });\n\n    ctx.user = payload; // inject payload into context\n    await next();\n  };\n}\n```\n\n**Usage**:\n\n```ts\nimport { jwtMiddleware } from \"./middleware\";\n\napp.use(jwtMiddleware({ secret: \"5435345\" }));\n\napp.get(\"/dashboard\", async (ctx) => {\n  console.log(ctx.user); // access decoded JWT\n  return ctx.json({ message: \"Welcome to dashboard\" });\n});\n```\n\n---\n"
        }
      ]
    },
    {
      "originalPath": "8. WebSocket.md",
      "id": 39,
      "name": "WebSocket",
      "type": "file",
      "path": "websocket",
      "content": "# 🔌 `upgradeWebSocket` Middleware\n\nEnable **WebSocket support** across **Node.js**, **Deno**, and **Bun** with runtime-specific optimizations.\n\n---\n\n## Prerequisites\n\n| Runtime | Support | Notes                            |\n| ------- | ------- | -------------------------------- |\n| Node.js | ✅ Yes   | Requires `ws` (`npm install ws`) |\n| Deno    | ✅ Yes   | Native                           |\n| Bun     | ✅ Yes   | Native                           |\n\n---\n\n## Import\n\n```ts\n// Node.js\nimport { upgradeWebSocket } from \"tezx/node\";\n// Deno\nimport { upgradeWebSocket } from \"tezx/deno\";\n// Bun\nimport { upgradeWebSocket } from \"tezx/bun\";\n```\n\n---\n\n## Types\n\n```ts\ntype WebSocketEvent = {\n  open?: (ws: WebSocket, ctx?: Context) => void;\n  message?: (ws: WebSocket, data: string | Buffer | ArrayBuffer) => void;\n  close?: (ws: WebSocket, info: { code: number; reason: string }) => void;\n  error?: (ws: WebSocket, err: Error | any) => void;\n  ping?: (ws: WebSocket, data: Buffer) => void;\n  pong?: (ws: WebSocket, data: Buffer) => void;\n  drain?: (ws: WebSocket) => void;\n};\ntype WebSocketCallback = (ctx: Context) => WebSocketEvent;\ntype WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => HttpBaseResponse;\n};\n```\n\n---\n\n## Basic Usage\n\n```ts\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) { console.log(\"Connected\"); },\n    message(ws, data) { ws.send(`Echo: ${data}`); },\n    close(ws, { code, reason }) { console.log(\"Closed\", code, reason); },\n    error(ws, err) { console.error(err); },\n  }))\n);\n```\n\n---\n\n## Runtime Setup\n\n### Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { upgradeWebSocket, mountTezXOnNode } from \"tezx/node\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open: ws => console.log(\"Node client connected\"),\n  message: (ws, msg) => ws.send(\"Node: \" + msg),\n})));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n```\n\n### Deno\n\n```ts\nimport { upgradeWebSocket } from \"tezx/deno\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open(ws) { console.log(\"Deno connected\"); },\n  message(ws, msg) { ws.send(\"Deno: \" + msg); },\n})));\n\nDeno.serve({ port: 3000 }, app.serve);\n```\n\n### Bun\n\n```ts\nimport { upgradeWebSocket, wsHandlers } from \"tezx/bun\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open(ws) { console.log(\"Bun connected\"); },\n  message(ws, msg) { ws.send(\"Bun: \" + msg); },\n})));\n\nBun.serve({ port: 3000, fetch: app.serve, websocket: wsHandlers() });\n```\n\n---\n\n## Upgrade Error Handling\n\n```ts\nupgradeWebSocket(callback, {\n  onUpgradeError: (err, ctx) => ctx.text(\"Upgrade failed: \" + err.message, 400),\n});\n```\n\n---\n\n## Advanced Events\n\n```ts\nmessage(ws, data) { ws.send(\"Hello\"); },\nping(ws, buffer) { console.log(\"Ping:\", buffer); },\npong(ws, buffer) { console.log(\"Pong:\", buffer); },\ndrain(ws) { console.log(\"Backpressure relieved\"); }\n```\n\n---\n\n## Runtime Features Matrix\n\n| Feature         | Node.js | Deno  | Bun   |\n| --------------- | ------- | ----- | ----- |\n| Native Upgrade  | ❌ `ws`  | ✅ Yes | ✅ Yes |\n| `ping` / `pong` | ✅       | ❌     | ✅     |\n| `drain`         | ❌       | ❌     | ✅     |\n| Compression     | ✅       | ❌     | ❌     |\n\n---\n"
    },
    {
      "originalPath": "9. Static File.md",
      "id": 40,
      "name": "Static File",
      "type": "file",
      "path": "static-file",
      "content": "# 📦 Static File\n\nServe static files (HTML, CSS, JS, images, JSON, etc.) via specific routes using `serveStatic`.\n\n**Supported Platforms:** `tezx/bun`, `tezx/node`, `tezx/deno`\n\n---\n\n## ✅ Import\n\n```ts\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n```\n\n---\n\n## 📘 Usage\n\n```ts\napp.static(serveStatic(config));\n```\n\n### Parameters\n\n* **config**: `ServeStatic` — configuration object with files and optional options like headers, cache, and allowed extensions.\n\n---\n\n## 📄 Types\n\n```ts\ntype StaticFileArray = {\n  fileSource: string;  // Absolute path on disk\n  route: string;       // Public URL path\n}[];\n\ntype StaticServeOption = {\n  cacheControl?: string;                 // Cache-Control header\n  headers?: Record<string, string>;     // Custom headers\n  extensions?: string[];                // Allowed file extensions\n};\n\ntype ServeStatic = {\n  files: StaticFileArray;\n  options?: StaticServeOption;\n};\n```\n\n---\n\n## 🧪 Examples\n\n### Bun\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/bun\";\n\nconst app = new TezX();\n\napp.static(serveStatic('/', './public', {\n  extensions: ['html', 'css', 'js'],\n  cacheControl: 'max-age=86400',\n  headers: { 'X-Static-Served-By': 'TezX-Bun' }\n}));\n```\n\n### Node.js\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/node\";\n\napp.static(serveStatic('/', './static-files', {\n  extensions: ['json'],\n  headers: { 'X-Content-Type': 'application/json' }\n}));\n```\n\n### Deno\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/deno\";\n\napp.static(serveStatic('/', './assets', {\n  extensions: ['png', 'jpg'],\n  cacheControl: 'public, max-age=7200'\n}));\n```\n\n---\n\n## 📂 Folder Example\n\n```\nmy-app/\n├── public/\n│   ├── index.html\n│   ├── style.css\n│   └── script.js\n└── server.ts\n```\n\n---\n\n## 📝 Summary\n\n| Feature             | Description                                     |\n| ------------------- | ----------------------------------------------- |\n| 🔍 Extension filter | Serve only allowed file types                   |\n| 🗂️ Route mapping   | Map files to custom URL routes                  |\n| 🧠 Headers          | Add custom headers like `Cache-Control`, `ETag` |\n| ⚡ Performance       | Fast static file serving                        |\n| ✅ Multi-env support | Works with Bun, Node.js, Deno                   |\n\n---\n\n## 🚀 Tips\n\n* Validate folder paths — `serveStatic()` resolves them internally.\n* Use extension filters to prevent accidental exposure of sensitive files.\n* Combine `static()` with dynamic routes for hybrid apps.\n\n---\n\n💡 **Reference:** [MDN – Cache-Control Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n\n---\n"
    },
    {
      "originalPath": "98.Toolkit",
      "name": "Toolkit",
      "path": "toolkit",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Middlewares",
          "name": "Middlewares",
          "path": "toolkit/1-middlewares",
          "type": "folder",
          "children": [
            {
              "originalPath": "Github Oauth2.md",
              "id": 41,
              "name": "Github Oauth2",
              "type": "file",
              "path": "toolkit/middlewares/github-oauth2",
              "content": "\n# 📦 `@tezx/github-oauth2`\n\nGitHub OAuth2.0 middleware for the [TezX](https://github.com/tezxjs/TezX) web framework. Securely authenticate users via GitHub, and define custom sign-in, session, and token handling logic.\n\n---\n\n## ✅ Setup GitHub OAuth App\n\nGo to: [https://github.com/settings/developers](https://github.com/settings/developers)\n\n1. Click **\"New OAuth App\"**\n2. Name: `My GitHub Login App`\n3. Homepage URL: `http://localhost:3000`\n4. Authorization callback URL: `http://localhost:3000/auth/github/callback`\n5. Save and copy `Client ID` and `Client Secret`\n\n## 📥 Installation\n\n```bash\nnpm install @tezx/github-oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx@latest github-auth -- --template github-oauth2 --y\n```\n\n---\n\n## 📄 Example Usage\n\n```ts\nimport { TezX } from 'tezx';\nimport {\n  GitHubOauthClient,\n  getGithubOAuthURL,\n  verifyGithubToken\n} from '@tezx/github-oauth2';\n\nconst app = new TezX({\n  debugMode: true\n});\n\n// Initialize OAuth client\nconst client = GitHubOauthClient({\n  clientId: process.env.GITHUB_CLIENT_ID!,\n  clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000'\n});\n\n// Step 1: Redirect user to GitHub login\napp.get('github', getGithubOAuthURL({\n  authClient: client,\n}), (ctx) => {\n  return ctx.redirect(ctx.github.oauth_url);\n});\n\n// Step 2: Verify GitHub token and handle user session\napp.get('/', verifyGithubToken({\n  authClient: client,\n  Callbacks: (ctx) => {\n    return {\n      session: async (session, user) => {\n        console.log('Session:', session);\n        console.log('User:', user);\n        return session;\n      }\n    };\n  }\n}), async (ctx) => {\n  return ctx.json({ success: ctx.github.user });\n});\n```\n\n---\n\n## 🧩 API Reference\n\n### `GitHubOauthClient(config: GithubOauthClient): GitHubAuthClient`\n\nCreates an OAuth client instance.\n\n#### Parameters\n\n| Name         | Type   | Description                    |\n| ------------ | ------ | ------------------------------ |\n| clientId     | string | GitHub OAuth App client ID     |\n| clientSecret | string | GitHub OAuth App client secret |\n| redirectUri  | string | URI GitHub should redirect to  |\n\n---\n\n### `getGithubOAuthURL(options: OAuthURLParams)`\n\nGenerates the GitHub OAuth URL and stores it in `ctx.github.oauth_url`.\n\n#### Parameters\n\n| Name        | Type              | Description                                                      |\n| ----------- | ----------------- | ---------------------------------------------------------------- |\n| authClient  | GitHubOauthClient | The OAuth client instance                                        |\n| scopes      | string\\[]         | (Optional) OAuth scopes (default: `['read:user', 'user:email']`) |\n| state       | string            | (Optional) CSRF protection state value                           |\n| allowSignup | boolean           | (Optional) Allow GitHub signups (default: true)                  |\n\n---\n\n### `verifyGithubToken(options: { authClient: GitHubOauthClient, Callbacks: Callbacks })`\n\nMiddleware to validate the token returned from GitHub and handle user info.\n\n#### Parameters\n\n| Name       | Type                       | Description                  |\n| ---------- | -------------------------- | ---------------------------- |\n| authClient | GitHubOauthClient          | The initialized OAuth client |\n| Callbacks  | `(ctx) => CallbacksReturn` | Optional lifecycle methods   |\n\n---\n\n### 🌀 `CallbacksReturn`\n\n| Method                   | Description                                                       |\n| ------------------------ | ----------------------------------------------------------------- |\n| `signIn(user)`           | Called after user is authenticated. Return `true` to allow login. |\n| `jwt(token, user?)`      | Customize JWT token if applicable.                                |\n| `session(session, user)` | Customize the session object before sending to client.            |\n\n---\n"
            },
            {
              "originalPath": "Google Oauth2.md",
              "id": 42,
              "name": "Google Oauth2",
              "type": "file",
              "path": "toolkit/middlewares/google-oauth2",
              "content": "\n## @tezx/google-oauth2\n\n### **Documentation**\n\n<https://developers.google.com/identity/protocols/oauth2>\n\n### **Configuration**\n\n<https://console.developers.google.com/apis/credentials>\n\nProvides:\n\n* **OAuth2 client initialization**\n* **Auth URL generation**\n* **Token verification middleware**\n* **Full TypeScript support** with JSDoc annotations\n\n---\n\n### 🔧 Installation\n\n```bash\nnpm install @tezx/google-oauth2 @googleapis/oauth2\n```\n\nOr with Yarn:\n\n```bash\nyarn add @tezx/google-oauth2 @googleapis/oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx@latest google-auth -- --template google-oauth2 --y\n```\n\n---\n\n### 🚀 Quick Start\n\n```ts\nimport { TezX } from 'tezx';\nimport { GoogleOauthClient, getGoogleOAuthURL, verifyGoogleToken } from '@tezx/google-oauth2';\n\nconst app = new TezX({\n  debugMode: true,\n});\n\n// 1. Initialize OAuth2 client\nconst client = GoogleOauthClient({\n  clientId: process.env.GOOGLE_CLIENT_ID!,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000/auth/callback',\n});\n\n// 2. Route to start Google login\napp.get('/auth/google', getGoogleOAuthURL({\n  authClient: client,\n  scopes: ['openid','email','profile'],\n}), (ctx) => {\n  return ctx.redirect(ctx.google?.oauth_url);\n});\n\n// 3. Callback route, verify token and establish session\napp.get('/auth/callback', verifyGoogleToken({\n  authClient: client,\n  onError: (err) => {\n    console.error('OAuth Error:', err);\n    // handle error or redirect\n  },\n  onSuccess: (tokens) => {\n    console.log('Tokens:', tokens);\n  },\n  Callbacks: (ctx)=> {\n    return {\n    signIn: async (user) => {\n      // e.g. allow only users from a domain\n      return user.email.endsWith('@yourcompany.com');\n    },\n    jwt: async (token, user) => {\n      // attach roles or custom claims\n      token.role = user.email_verified ? 'member' : 'guest';\n      return token;\n    },\n    session: async (session, user) => {\n      // persist user profile in session\n      session.user = {\n        id: user.sub,\n        email: user.email,\n        name: user.name,\n        picture: user.picture\n      };\n      return session;\n    }\n  }\n  } \n}), async (ctx) => {\n  // Now ctx.session is populated\n  return ctx.json({ success: true });\n});\n\n```\n\n---\n\n## 📚 API Reference\n\n### `GoogleOauthClient(config) → OAuth2Client`\n\nCreate a configured Google OAuth2 client.\n\n```ts\nimport type { OAuth2Client } from 'google-auth-library';\n\ninterface GoogleOauthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\n/**\n * @param config.clientId     Google OAuth Client ID.\n * @param config.clientSecret Google OAuth Client Secret.\n * @param config.redirectUri  Registered redirect URI.\n * @returns OAuth2Client\n */\nexport function GoogleOauthClient(config: GoogleOauthConfig): OAuth2Client;\n```\n\n---\n\n### `getGoogleOAuthURL(params) → Middleware`\n\nGenerate and store the Google authentication URL in `ctx.google?.oauth_url`.\n\n```ts\ninterface OAuthURLParams {\n  authClient: OAuth2Client;\n  scopes?: string[];               // default ['openid','email','profile']\n  loginHint?: string;              // optional, e.g. user email\n  prompt?: string;                 // default 'consent select_account'\n  accessType?: 'online'|'offline'; // default 'offline'\n  includeGrantedScopes?: boolean;  // default true\n}\n\n/**\n * Middleware that adds `state` header, generates auth URL, and redirects.\n * On success: ctx.google?.oauth_url contains the URL.\n */\nexport function getGoogleOAuthURL(params: OAuthURLParams): Middleware<any>;\n```\n\n---\n\n### `verifyGoogleToken(params) → Middleware`\n\nValidate the OAuth callback, exchange the code, verify ID token, and invoke your callbacks.\n\n```ts\nexport type CallbacksReturn = {\n    /**\n     * Callback function called when a user signs in successfully.\n     * \n     * @param {User} user - The user object containing user details such as email, name, etc.\n     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the sign-in is allowed. \n     *         If `false`, the sign-in will be rejected; if `true`, the sign-in will proceed.\n     * \n     * @example\n     * const callbacks = {\n     *     signIn: async (user) => {\n     *         // Check if the user is allowed to sign in\n     *         return user.email.endsWith('@example.com');\n     *     }\n     * };\n     */\n    signIn?: (user: User) => Promise<boolean>;\n\n    /**\n     * Callback function for handling JWT (JSON Web Token) creation or modification.\n     * \n     * @param {any} token - The token object that contains the user's authentication information.\n     * @param {User} [user] - The user object, which may be available depending on the context.\n     * @returns {Promise<any>} - A promise that resolves to a possibly modified token or additional data to be included with the token.\n     * \n     * @example\n     * const callbacks = {\n     *     jwt: async (token, user) => {\n     *         // Add custom data to the token, like user role\n     *         token.role = user?.role || 'guest';\n     *         return token;\n     *     }\n     * };\n     */\n    jwt?: (token: any, user?: User) => Promise<any>;\n\n    /**\n     * Callback function for handling user session management.\n     * \n     * @param {any} session - The session object containing session data.\n     * @param {User} user - The user object containing the authenticated user's information.\n     * @returns {Promise<any>} - A promise that resolves to the modified session data or a session object.\n     * \n     * @example\n     * const callbacks = {\n     *     session: async (session, user) => {\n     *         // Modify session object, e.g., store user roles or permissions in the session\n     *         session.userRole = user?.role || 'guest';\n     *         return session;\n     *     }\n     * };\n     */\n    session?: (session: any, user: User) => Promise<any>;\n};\n\nexport type Callbacks = (ctx: Context) => CallbacksReturn;\n\ninterface VerifyParams {\n  authClient: OAuth2Client;\n  onError?: (error: string) => void;\n  onSuccess?: (tokens: any, response: any) => void;\n  Callbacks: Callbacks;\n}\n\n/**\n * Middleware that:\n * 1. Exchanges `code` for tokens  \n * 2. Validates `id_token` audience  \n * 3. Executes `signIn`, `jwt`, `session` callbacks  \n * 4. Calls onSuccess or onError  \n */\nexport function verifyGoogleToken(params: VerifyParams): Middleware<any>;\n```\n\n---\n\n### 🎓 `User` & `Credentials` Types\n\n```ts\n/** Google user info returned by tokeninfo endpoint */\nexport type GoogleUser = {\n    iss: string;\n    azp: string;\n    aud: string;\n    sub: string;\n    email: string;\n    email_verified: string;\n    at_hash: string;\n    name: string;\n    picture: string;\n    given_name: string;\n    family_name: string;\n    iat: string;\n    exp: string;\n    alg: string;\n    kid: string;\n    typ: string;\n  // ...other standard claims\n};\n\n/** OAuth2 token set returned by getToken() */\nexport interface Credentials {\n  access_token?: string;\n  refresh_token?: string;\n  expiry_date?: number;\n  id_token?: string;\n  token_type?: string;\n  scope?: string;\n}\n```\n\n---\n\n## 🛡 Security & Best Practices\n\n* **State parameter**: Mitigate CSRF by using `state`.\n* **Prompt & access\\_type**: Use `offline` + `prompt='consent'` to receive refresh tokens.\n* **Scope minimization**: Request only the scopes you need.\n* **Token handling**: Securely store `refresh_token` if you need long‑lived access.\n\n---\n"
            },
            {
              "originalPath": "Tezx profiler.md",
              "id": 43,
              "name": "Tezx profiler",
              "type": "file",
              "path": "toolkit/middlewares/tezx-profiler",
              "content": "# @tezx/profiler\n\nA lightweight, extensible profiling middleware for the [TezX](https://www.npmjs.com/package/tezx) framework. This module enables detailed tracking of runtime performance metrics, memory usage, CPU statistics, and supports custom plugins and rotating file storage.\n\n---\n\n## 🚀 Features\n\n- ⏱️ Measure route execution time.\n- 💾 Monitor memory usage in MB.\n- ⚙️ Capture CPU usage in milliseconds.\n- 📊 System stats endpoint (`/__profiler`) with a clean UI.\n- 🔌 Plugin hooks (`beforeProfile`, `afterProfile`).\n- 📁 Rotating file storage for logs.\n- ✅ Written in TypeScript with full type safety.\n- 🌍 Supports Node.js, Deno, and Bun environments.\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/profiler\n```\n\n---\n\n## 🛠️ Usage Example\n\n### Basic Setup\n\n```ts\nimport { TezX } from 'tezx';\nimport { profiler, createRotatingFileStorage } from '@tezx/profiler';\n\nconst app =new TezX();\n\napp.use(\n  profiler({\n    route: '/__profiler',\n    excludePaths: ['/favicon.ico'],\n    metrics: ['time', 'memory', 'cpu'],\n    storage: createRotatingFileStorage('./profiler.log', 1024 * 1024), // Rotate every 1MB\n    plugins: [],\n  })\n);\n\napp.get('/', (ctx) => ctx.json({ message: 'Hello World' }));\n\n```\n\n---\n\n## 🌐 Profiler UI\n\nVisit your app at:\n\n```bash\nhttp://localhost:3000/__profiler\n```\n\nYou'll see:\n\n- ✅ Uptime (seconds)\n- ✅ Timestamp\n- ✅ Memory Usage (rss, heapTotal, heapUsed, etc.) in MB\n- ✅ CPU Usage (user/system) in milliseconds\n\n---\n\n## ⚙️ Profiler Options\n\n| Option           | Type                                        | Default         | Description                             |\n|------------------|---------------------------------------------|-----------------|-----------------------------------------|\n| `route`          | `string`                                    | `/__profiler`   | Path to view system stats               |\n| `excludePaths`   | `string[]`                                  | `[]`            | Paths to ignore                         |\n| `metrics`        | `(\\\"time\\\" \\| \\\"memory\\\" \\| \\\"cpu\\\")[]`     | `['time', 'memory']` | Metrics to collect                |\n| `storage`        | `StorageAdapter`                            | `undefined`     | Save profile results                   |\n| `plugins`        | `ProfilerPlugin[]`                          | `[]`            | Hook into the profiling lifecycle      |\n\n---\n\n## 🔌 Plugins Example\n\n```typescript\nconst myPlugin = {\n  beforeProfile: () => console.log('Starting profiling...'),\n  afterProfile: (result) => console.log('Profile completed:', result),\n};\n\napp.use(profiler({ plugins: [myPlugin] }));\n```\n\n---\n\n## 🗃️ Rotating File Storage Example\n\n```typescript\nconst storage = createRotatingFileStorage('./profiler.log', 1024 * 1024); // 1MB rotation\n\napp.use(profiler({ storage }));\n```\n\n- File automatically rotates when it reaches the configured size.\n- Supports Node.js, Deno, Bun file systems.\n\n---\n\n## 🧑‍💻 Example Profile Output\n\n```json\n{\n  \"name\": \"default\",\n  \"duration\": 6.25,\n  \"timestamp\": \"2025-07-06T19:25:47.753Z\",\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"memoryUsage\": {\n    \"rss\": 10485760,\n    \"heapTotal\": 6291456,\n    \"heapUsed\": 4194304,\n    \"external\": 102400,\n    \"arrayBuffers\": 51200\n  },\n  \"cpuUsage\": {\n    \"user\": 1416,\n    \"system\": 312\n  }\n}\n```\n\n---\n\n## ⚡ System Stats Breakdown\n\n### Memory Usage\n\n- `rss`: Resident Set Size (total memory allocated for the process)\n- `heapTotal`: Total size of allocated heap\n- `heapUsed`: Heap actually used\n- `external`: Memory used by C++ objects bound to JS\n- `arrayBuffers`: Memory allocated for ArrayBuffer\n\n### CPU Usage\n\n- `user`: Time spent in user mode (μs)\n- `system`: Time spent in kernel mode (μs)\n\n---\n\n## 🔐 Environment Support\n\n✔️ Node.js\n✔️ Deno\n✔️ Bun\n\n---\n<!-- \n## 🔎 Future Enhancements\n\n- 🔄 Redis or database storage adapters\n- 📈 Export metrics in Prometheus format\n- 🌐 Remote profiling dashboard -->\n\n---\n\n## 📜 License\n\nMIT © 2025 TezX Team\n"
            }
          ]
        },
        {
          "originalPath": "2. Helpers",
          "name": "Helpers",
          "path": "toolkit/2-helpers",
          "type": "folder",
          "children": [
            {
              "originalPath": "Devtools.md",
              "id": 44,
              "name": "Devtools",
              "type": "file",
              "path": "toolkit/helpers/devtools",
              "content": "\n# 📊 TezX DevTools\n\n> Developer-friendly diagnostics and inspector panel for TezX-based applications. Plug in to see routes, middlewares, env variables, cookies, and add your own custom debug tabs.\n\n---\n\n## ✅ Installation\n\n```bash\nnpm install @tezx/devtools\n```\n\nEnsure you also have:\n\n```bash\nnpm install tezx\n```\n\n---\n\n## 🚀 Quick Usage\n\nIn your TezX app entry (e.g., `server.ts` or `index.ts`):\n\n```ts\nimport { TezX } from \"tezx\";\nimport DevTools from \"@tezx/devtools\";\n\nconst app = new TezX();\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    // Optional\n    // disableTabs: ['cookies', 'routes'],\n    // extraTabs: (ctx) => [ ... ]\n  })\n);\n\n```\n\nNow visit:\n**`http://localhost:3000/devtools`**\nto see a real-time diagnostic dashboard.\n\n---\n\n## 🧩 Built-in Tabs\n\n| Tab           | Description                                              |\n| ------------- | -------------------------------------------------------- |\n| `routes`      | Lists all loaded routes with method, path, and source    |\n| `middlewares` | Displays registered middleware and which routes use them |\n| `cookies`     | Shows request cookies (parsed from `ctx`)                |\n| `.env`        | Displays environment variables loaded via `.env`         |\n\n---\n\n## ⚙️ API: `DevTools(app, options)`\n\n```ts\nDevTools(app: TezX<any>, options?: Options): Callback\n```\n\n### Options\n\n| Option        | Type                                                      | Description             |\n| ------------- | --------------------------------------------------------- | ----------------------- |\n| `extraTabs`   | `(ctx) => TabType \\| Promise<TabType>`                    | Add your own tab panels |\n| `disableTabs` | `Array<'cookies' \\| 'routes' \\| '.env' \\| 'middlewares'>` | Hide built-in tabs      |\n\n---\n\n## 📚 Types\n\n```ts\ntype Tab = \"cookies\" | \"routes\" | \".env\" | \"middlewares\";\n\ntype TabType = {\n  doc_title: string;\n  label: string;\n  tab: Tab | string;\n  content: string; // Rendered HTML content\n}[];\n\ntype Options = {\n  extraTabs?: (ctx: Context) => Promise<TabType> | TabType;\n  disableTabs?: Tab[];\n};\n```\n\n---\n\n## 📁 Directory Example\n\n**Using `tezx/router`**\n\n```bash\nmy-app/\n├── routes/\n│   ├── _middleware.ts\n│   └── ...\n├── public/\n│   └── ...\n├── tezx.config.mjs             ← setup TezX + DevTools here\n├── .env\n├── package.json\n└── tsconfig.json\n```\n\n---\n"
            },
            {
              "originalPath": "TezX localfs.md",
              "id": 45,
              "name": "TezX localfs",
              "type": "file",
              "path": "toolkit/helpers/tezx-localfs",
              "content": "# @tezx/localfs\n\n`@tezx/localfs` is a simple, runtime-agnostic local file storage library that works with Node.js, Deno, and Bun.\n\nIt allows you to:\n\n* Save files to the local disk.\n* Automatically detect file types.\n* Auto-create directories.\n* Validate file size & type.\n* Generate public URLs for serving files.\n* List files (with recursive support).\n\n---\n\n## ✨ Features\n\n* 👍 TypeScript ready\n* ✅ Cross-runtime support (Node.js, Deno, Bun)\n* 📁 Auto-create directories when saving files\n* 🔍 Auto-detect MIME types from file extensions\n* ⚙️ Secure file-type filtering based on allowed MIME types\n* 🔗 Generate public URLs for serving files\n* 🏙️ Public file serving router (TezX Router)\n* 📂 List files recursively or non-recursively\n* 🧩 Built-in TezX Router for serving static files\n\n---\n\n## 📦 Installation\n\n### Node.js / Bun\n\n```bash\nnpm install @tezx/localfs\n# OR\nbun add @tezx/localfs\n```\n\n---\n\n## 🔧 Basic Example (Node.js)\n\n```ts\nimport { LocalFS } from \"@tezx/localfs\";\nimport { readFile } from \"node:fs/promises\";\n\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n\nasync function run() {\n  const buffer = await readFile(\"photo.jpg\");\n\n  const saved = await storage.saveFile(\"photo.jpg\", buffer);\n  console.log(\"File saved:\", saved);\n\n  const files = await storage.listFiles(\"\", true);\n  console.log(\"All files:\", files);\n}\n\nrun();\n```\n\n---\n\n## 🔹 API Reference\n\n### new LocalFS(options)\n\n| Option               | Type       | Default    | Description                    |\n| -------------------- | ---------- | ---------- | ------------------------------ |\n| basePath             | `string`   | `uploads`  | Folder to save files           |\n| publicUrl            | `string`   | `/uploads` | Public path prefix             |\n| allowPublicAccess    | `boolean`  | `true`     | Enable/disable public serving  |\n| autoRenameOnConflict | `boolean`  | `true`     | Rename files if name conflicts |\n| maxFileSize          | `number`   | `5MB`      | Max upload size in bytes       |\n| allowedTypes         | `string[]` | `image/*`  | Allowed MIME types             |\n\n---\n\n### saveFile(fileName, buffer, mimeType?)\n\nSaves a file to the storage.\n\nReturns:\n\n```json\n{\n  \"savedPath\": \"uploads/photo.jpg\",\n  \"fileName\": \"photo.jpg\",\n  \"publicUrl\": \"/uploads/photo.jpg\"\n}\n```\n\n---\n\n### readFile(fileName)\n\nReads file contents as a `Buffer`.\n\n---\n\n### deleteFile(fileName)\n\nDeletes a file from the disk.\n\n---\n\n### listFiles(folder = '', recursive = false)\n\nLists file names from a folder.\n\nExample output:\n\n```json\n[\n  \"photo.jpg\",\n  \"nested/file.pdf\"\n]\n```\n\n---\n\n### getPublicUrl(fileName)\n\nGenerates the public URL for a file.\n\nExample:\n\n```ts\nstorage.getPublicUrl(\"photo.jpg\");\n// \"/uploads/photo.jpg\"\n```\n\n---\n\n### serveFileResponse()\n\nReturns a TezX Router instance to serve static files from your storage folder.\n\nExample:\n\n```ts\napp.use(storage.serveFileResponse());\n```\n\nThen files are available at:\n\n```bash\n/uploads/photo.jpg\n```\n\n---\n\n## 🌐 Example Use with TezX API Router\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files;\n  const buffer = Buffer.from(await file.arrayBuffer());\n  const result = await storage.saveFile(file.name, buffer);\n  return ctx.json(result);\n});\n\napp.use(storage.serveFileResponse());\n```\n\n---\n\n## 🔹 Runtime Support\n\n| Runtime | Supported |\n| ------- | --------- |\n| Node.js | ✅         |\n| Deno    | ✅         |\n| Bun     | ✅         |\n\n---\n\n# LocalFS Usage Docs\n\n## 🔹 Setup\n\n```ts\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n```\n\n## 📂 Saving a File\n\n```ts\nconst buffer = await readFile(\"./logo.png\");\nconst saved = await storage.saveFile(\"logo.png\", buffer);\nconsole.log(saved);\n```\n\n---\n\n## 🔹 Listing Files\n\n```ts\nawait storage.listFiles(); // Non-recursive\nawait storage.listFiles(\"\", true); // Recursive\n```\n\n---\n\n## 🔹 Deleting Files\n\n```ts\nawait storage.deleteFile(\"logo.png\");\n```\n\n---\n\n## 🔹 Reading Files\n\n```ts\nconst content = await storage.readFile(\"logo.png\");\n```\n\n---\n\n## 🔹 Serving Public Files\n\n```ts\napp.use(storage.serveFileResponse());\n\n// Now accessible at: /uploads/logo.png\n```\n\n---\n\n## 🔹 Error Example\n\n```bash\nError: File type application/x-sh is not allowed\n```\n\n---\n"
            },
            {
              "originalPath": "TezX session.md",
              "id": 46,
              "name": "TezX session",
              "type": "file",
              "path": "toolkit/helpers/tezx-session",
              "content": "# ⚡ @tezx/session\n\n### Simple, Secure & Type-Safe Session Middleware for **TezX**\n\nBuild scalable applications with pluggable session storage, secure cookies, and developer-friendly TypeScript APIs.\n\n---\n\n## ✨ Features\n\n* ✅ **Type-Safe** session data (Generics support)\n* 🔐 Secure, HTTP-only cookie session IDs\n* ⚙️ Customizable session storage (Memory, Redis, etc.)\n* 🔄 Simple Middleware: `useSession()`, `createSession()`, `destroySession()`\n* 🌐 CORS-friendly: Supports `credentials: 'include'`\n* 🧩 Extensible for microservices & SSR apps\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/session\n```\n\nOR\n\n```bash\npnpm add @tezx/session\n```\n\n---\n\n## ⚙️ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { SessionManager } from \"@tezx/session\";\n\nconst app = new TezX();\n\nconst sessionManager = new SessionManager({\n  sessionName: \"tezx.sid\",\n  cookie: { maxAge: 1000 * 60 * 30, httpOnly: true, secure: true, sameSite: \"lax\" },\n});\n\n// Load session before routes\napp.use(sessionManager.useSession());\n\n// Login route → create session\napp.post(\"/login\", async (ctx) => {\n  await sessionManager.createSession({ userId: 99, role: \"admin\" }, ctx);\n  return ctx.json({ success: true });\n});\n\n// Protected route → read session\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ session: ctx.session?.data });\n});\n\n// Logout → destroy session\napp.post(\"/logout\", async (ctx) => {\n  await ctx.session?.destroy();\n  return ctx.json({ loggedOut: true });\n});\n```\n\n---\n\n## 🛡️ API Documentation\n\n### 🔑 SessionManager\n\n| Method             | Description                                 |\n| ------------------ | ------------------------------------------- |\n| `createSession()`  | Create and save a session                   |\n| `useSession()`     | Middleware: Load session from cookie        |\n| `destroySession()` | Destroy session from store and clear cookie |\n\n---\n\n### 📄 `createSession(data, ctx)`\n\n* Creates a session.\n* Automatically sets a session cookie in the response.\n* Saves session data to the configured storage.\n\nExample:\n\n```ts\nawait sessionManager.createSession({ userId: 101 }, ctx);\n```\n\n---\n\n### 🔄 `useSession()`\n\nMiddleware for **loading session** on every request:\n\n* Reads session cookie\n* Loads session data from storage\n* Adds `ctx.session` to your context.\n\nExample:\n\n```ts\napp.use(sessionManager.useSession());\n```\n\n---\n\n### ❌ `destroySession()`\n\nDeletes the session from storage and removes the cookie:\n\n```ts\nawait sessionManager.destroySession(sessionId);\n```\n\n---\n\n## 🔧 Configuration Options\n\n```ts\nconst sessionManager = new SessionManager({\n  sessionName: \"my_session\",\n  cookie: {\n    maxAge: 1000 * 60 * 30, // 30 min\n    secure: true,\n    httpOnly: true,\n    sameSite: \"lax\",\n  },\n  storage: new MemoryStore(), // Or your own adapter\n});\n```\n\n| Option          | Type                    | Description                            |\n| --------------- | ----------------------- | -------------------------------------- |\n| sessionName     | `string`                | Name of the cookie key                 |\n| sessionId       | `(ctx) => string`       | Custom session ID generator (optional) |\n| cookie.maxAge   | `number`                | Expiry in ms                           |\n| cookie.secure   | `boolean`               | Only send cookie on HTTPS              |\n| cookie.httpOnly | `boolean`               | Prevent JS access to cookie            |\n| cookie.sameSite | `\"lax\" \\| \"strict\" \\| \"none\"` | SameSite attribute             |\n| storage         | `SessionStorageAdapter` | Custom storage engine                  |\n\n---\n\n## 🧰 Example with Redis Storage\n\n```ts\n\nimport type { SessionStorageAdapter, SessionInstance } from \"@tezx/session\";\nimport type { RedisClientType } from \"redis\";\n\nexport class RedisStore implements SessionStorageAdapter {\n  private redisClient: RedisClientType;\n  private prefix: string;\n\n  /**\n   * Create RedisStore adapter.\n   * @param redisClient - Connected Redis client instance.\n   * @param prefix - Optional key prefix for session keys.\n   */\n  constructor(redisClient: RedisClientType, prefix = \"tezx:session:\") {\n    this.redisClient = redisClient;\n    this.prefix = prefix;\n  }\n\n  private getKey(sessionId: string) {\n    return `${this.prefix}${sessionId}`;\n  }\n\n  async get(sessionId: string): Promise<SessionInstance | undefined> {\n    const key = this.getKey(sessionId);\n    const data = await this.redisClient.get(key);\n    if (!data) return undefined;\n\n    try {\n      const parsed = JSON.parse(data);\n      const redisStore = this;\n      return {\n        sessionId: parsed.sessionId,\n        data: parsed.data,\n        async save() {\n          await redisStore.set(this.sessionId, this);\n        },\n        async destroy() {\n          await redisStore.destroy(this.sessionId);\n        },\n      } as SessionInstance;\n    } catch {\n      return undefined;\n    }\n  }\n\n  async set(sessionId: string, data: SessionInstance, maxAge?: number): Promise<void> {\n    const key = this.getKey(sessionId);\n    const value = JSON.stringify({ sessionId, data: data.data });\n    if (maxAge) {\n      // maxAge in ms, Redis EXPIRE in seconds\n      await this.redisClient.set(key, value, {\n        PX: maxAge,\n      });\n    } else {\n      await this.redisClient.set(key, value);\n    }\n  }\n\n  async destroy(sessionId: string): Promise<void> {\n    const key = this.getKey(sessionId);\n    await this.redisClient.del(key);\n  }\n}\n\nconst redisStore = new RedisStore(redisClient);\n\nconst sessionManager = new SessionManager({\n  storage: redisStore,\n  cookie: { maxAge: 1000 * 60 * 60 }, // 1 hour\n});\n```\n\n---\n\n## ⚠️ CORS & Cookie Notes\n\nFor frontend requests (if CORS enabled):\n\n* Set credentials in the fetch request:\n\n```js\nfetch(\"/profile\", { credentials: \"include\" });\n```\n\n* Server-side: Configure CORS to allow credentials and the origin.\n\n---\n\n## 🔨 Type Safety\n\n```ts\nconst sessionManager = new SessionManager<{ userId: number, role: string }>();\n\nawait sessionManager.createSession({ userId: 1, role: \"admin\" }, ctx);\n```\n\nNow your `ctx.session.data` will always have `userId` and `role`.\n\n---\n\n## 🔮 Advanced Topics\n\n* Redis, MongoDB, File storage adapters\n* Regenerate session IDs on login/logout\n* Auto session expiry + cleanup\n* Session encryption for sensitive data\n* Shared session across subdomains\n\n---\n\n## ✅ License\n\nMIT © TezX\n\n---\n"
            }
          ]
        },
        {
          "originalPath": "3. Utilities",
          "name": "Utilities",
          "path": "toolkit/3-utilities",
          "type": "folder",
          "children": [
            {
              "originalPath": "TezX rbac.md",
              "id": 47,
              "name": "TezX rbac",
              "type": "file",
              "path": "toolkit/utilities/tezx-rbac",
              "content": "# 🔐 @tezx/rbac\n\nA powerful, fully type-safe **Role-Based Access Control (RBAC)** plugin for [TezX](https://www.npmjs.com/package/tezx), designed to help you **control access to routes, APIs, and resources** using simple, template-based permission keys with full IntelliSense support.\n\n---\n\n## 🚀 Highlights\n\n- 🎯 Type-safe permission system (`T extends string[]`)\n- 🧠 IntelliSense-based permission enforcement\n- 🔁 Multi-role support (`ctx.user.role` can be `string | string[]`)\n- ⚙️ Middleware-driven, plug-and-play\n- ❌ Built-in denial handling + custom `onDeny()` support\n- 🧩 Easy integration with auth middlewares (like `authChecker`)\n- 🧪 Battle-tested in production apps\n- 🔑 Use role IDs(Dynamically generated, flexible)\n- 🔍 Clean merge of all permissions (No manual logic needed)\n- 🏷️ Static roles still supported (Easy for default usage)\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/rbac\n````\n\n---\n\n## 🧠 How It Works\n\n```bash\n[Your Middleware]\n    ⬇️ sets ctx.user.role\n[RBAC Plugin]\n    ⬇️ loads permission map\n[Route Guard]\n    ⬇️ checks permission key\n[✓ ALLOW] or [❌ DENY]\n```\n\n---\n\n## ⚠️ Required: `ctx.user.role`\n\nTo work correctly, you **must set** `ctx.user.role` before using RBAC.\n\n✅ Example:\n\n```ts\nctx.user = {\n  id: 'user_001',\n  role: 'admin',  // ✅ Required\n  email: 'rakib@example.com'\n};\n```\n\n✅ If roles can be multiple:\n\n```ts\nctx.user = {\n  role: ['editor', 'viewer']\n};\n```\n\n> 💡 Use `authChecker()` middleware to assign `ctx.user` from token/session.\n\n---\n\n## 🧑‍💻 Usage Example\n\n```ts\n\nimport RBAC from '@tezx/rbac';\ntype Permissions = ['user:create', 'user:delete', 'order:read', 'property:approve'];\n\nconst rbac = new RBAC<Permissions>();\n\napp.use(authChecker()); // ✅ Assigns ctx.user + ctx.user.role\n\napp.use(rbac.plugin({\n  loadPermissions: async () => ({\n    admin: ['user:create', 'user:delete', 'order:read', 'property:approve'],\n    editor: ['order:read'],\n    guest: []\n  })\n}));\n\napp.get('/admin/users', rbac.authorize('user:create'), async (ctx) => {\n  return ctx.text('You can create users.');\n});\n\n```\n\n---\n\n## 📌 RBAC Lifecycle\n\n| Step | Action                                                            |\n| ---- | ----------------------------------------------------------------- |\n| 1️⃣  | `ctx.user.role` assigned by auth middleware                       |\n| 2️⃣  | `rbac.plugin()` loads Role→Permission map                         |\n| 3️⃣  | `rbac.authorize('permission:key')` checks merged role permissions |\n| 4️⃣  | If not allowed → return `403` (with `onDeny` if provided)         |\n\n---\n\n### 🔁 Replace `role` with Unique Role IDs (Advanced)\n\nRBAC system supports mapping **dynamic role identifiers** (like database IDs or UUIDs) instead of hardcoded role names.\n\nThis is helpful when:\n\n- ✅ Roles are created dynamically from a dashboard or DB\n- ✅ You want to map user roles like `\"role_8FaHq1\"` instead of just `\"admin\"`\n- ✅ Permission sets are assigned to these dynamic IDs\n\n#### 🧪 Example\n\n```ts\nctx.user = {\n  id: 'user_xyz',\n  role: 'role_8FaHq1' // ✅ Your actual role ID from database\n};\n```\n\n```ts\n// Load role-permission map based on DB role IDs\nloadPermissions: async () => ({\n  role_8FaHq1: ['user:create', 'order:read'],\n  role_7NbQt55: ['user:delete']\n})\n```\n\n> ✅ Internally, `RBAC` merges all permissions based on the provided `ctx.user.role`, whether it's `string` or `string[]`.\n\n#### ⚠️ Important\n\nMake sure the role ID you assign in `ctx.user.role` **exactly matches** the keys in your permission map.\n\n---\n\n### Bonus: Hybrid Role Support\n\nYou can even mix static roles with dynamic IDs if needed:\n\n```ts\nctx.user = {\n  role: ['admin', 'role_7bXy91']\n};\n\nloadPermissions: async () => ({\n  admin: ['dashboard:access'],\n  role_7bXy91: ['product:create']\n});\n```\n\n---\n\n## 🧩 Plugin API\n\n### `rbac.plugin(config)`\n\nInitializes the permission map.\n\n**Config options:**\n\n| Field             | Type                         | Required | Description           |\n| ----------------- | ---------------------------- | -------- | --------------------- |\n| `loadPermissions` | `(ctx) => RolePermissionMap` | ✅        | Role → permission map |\n| `isAuthorized`    | `(roles, permissions, ctx)`  | ❌        | Custom check hook     |\n| `onDeny`          | `(error, ctx)`               | ❌        | Custom deny response  |\n\n---\n\n### `rbac.authorize('permission:key')`\n\nMiddleware to protect routes.\n\n```ts\napp.post('/orders', rbac.authorize('order:read'), handler);\n```\n\n---\n\n## 💡 IntelliSense with Template Types\n\n```ts\ntype Permissions = ['user:create', 'order:read', 'admin:panel'];\n\nconst rbac = new RBAC<Permissions>();\n```\n\n✅ Now `rbac.authorize(...)` will auto-suggest only those permission keys.\n\n---\n\n## ❌ Custom Deny Example\n\n```ts\nrbac.plugin({\n  loadPermissions: ...,\n  onDeny: (error, ctx) => {\n    return ctx.json({\n      success: false,\n      reason: error.message,\n      permission: error.permission\n    });\n  }\n});\n```\n\n---\n\n## 🔍 Real-World Structure\n\n```ts\nconst permissionMap = {\n  admin: ['user:create', 'user:delete'],\n  editor: ['order:read'],\n  viewer: [],\n};\n```\n\nUser may have:\n\n```ts\nctx.user = {\n  id: 'u-001',\n  role: ['editor', 'viewer']\n};\n```\n\nRBAC will combine permissions from both roles.\n\n---\n\n## 🔥 Debug Tip\n\nTo check permissions being applied at runtime:\n\n```ts\nconsole.log(ctx.user.permissions); // all merged permissions\n```\n\n---\n\n## 📚 Types Summary\n\n```ts\ntype RolePermissionMap<T extends string[]> = Record<string, T[number][]>;\ntype DenyError<T extends string[]> = {\n  error: string;\n  message: string;\n  permission: T[number];\n};\n```\n\n---\n\n## 📦 Exported API\n\n```ts\nimport RBAC, { plugin, authorize } from '@tezx/rbac';\n```\n\n---\n\n## 🧪 Test Route Example\n\n```ts\napp.get('/secure', rbac.authorize('admin:panel'), async (ctx) => {\n  ctx.body = { status: 'Access granted.' };\n});\n```\n\n---\n\n## ✅ Best Practices\n\n- 🔄 Always assign `ctx.user.role` in `authChecker`\n- 🧠 Define permissions centrally as union literal type\n- 🔐 Protect all critical routes using `rbac.authorize()`\n- 🧪 Add logging inside `onDeny` for better traceability\n\n---\n"
            },
            {
              "originalPath": "View Engine.md",
              "id": 48,
              "name": "View Engine",
              "type": "file",
              "path": "toolkit/utilities/view-engine",
              "content": "# @tezx/view-engine\n\nA flexible, powerful, and runtime-aware view engine utility for server-side rendering (SSR) with support for **Node.js**, **Bun**, and **Deno**.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/view-engine.svg)\n\n> 🔧 Supports `ejs`, `pug`, `handlebars`, `nunjucks`, and `mustache` templates out of the box.\n\n---\n\n## ✨ Features\n\n- ✅ Supports multiple template engines\n- 🧠 Built-in caching for improved performance\n- 🪄 Optional file extension overrides\n- 🌐 Cross-runtime support: Node.js, Bun, Deno\n- 📦 Lightweight and framework-agnostic\n- 🔍 Ideal for SSR in Tezx or any TS/JS backend\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/view-engine\n# or\nbun add @tezx/view-engine\n````\n\n### **Template**\n\n```bash\nnpm create tezx view-engine -- --template view-engine --y\n```\n\n### **Require**\n\n```bash\n# EJS\nnpm install ejs\n\n# Pug (formerly Jade)\nnpm install pug\n\n# Handlebars\nnpm install handlebars\n\n# Nunjucks (Jinja2-like templating)\nnpm install nunjucks\n\n# Mustache\nnpm install mustache\n\n```\n\n---\n\n## 🚀 Usage\n\n```ts\nimport { ViewEngine } from \"@tezx/view-engine\";\n\nconst views = new ViewEngine(\"ejs\", \"./views\");\n\nconst html = await views.render(\"home\", {\n  title: \"Welcome!\",\n  user: { name: \"Rakibul\" },\n});\n\n// In your Tezx handler:\nctx.html(html);\n```\n\n---\n\n## 🔧 Constructor\n\n```ts\nnew ViewEngine(engine: TemplateEngine, viewsPath: string, options?: ViewEngineOptions)\n```\n\n### Parameters\n\n| Name        | Type                   | Description                        |\n| ----------- | ---------------------- | ---------------------------------- |\n| `engine`    | `\"ejs\"`, `\"pug\"`, etc. | Template engine to use             |\n| `viewsPath` | `string`               | Path to the views/templates folder |\n| `options`   | `ViewEngineOptions`    | (Optional) Configuration options   |\n\n---\n\n## ⚙️ Options\n\n```ts\ninterface ViewEngineOptions {\n  cache?: boolean; // default: true\n  autoescape?: boolean; // default: true (nunjucks only)\n  extensionOverride?: Partial<Record<TemplateEngine, string>>;\n}\n```\n\n### Example\n\n```ts\nconst views = new ViewEngine(\"ejs\", \"./views\", {\n  cache: true,\n  extensionOverride: {\n    ejs: \".html.ejs\"\n  }\n});\n```\n\n---\n\n## 📚 Supported Engines\n\n| Engine       | Extension   | Notes                       |\n| ------------ | ----------- | --------------------------- |\n| `ejs`        | `.ejs`      | Supports includes/partials  |\n| `pug`        | `.pug`      | Indentation-based templates |\n| `handlebars` | `.hbs`      | Logic-less templates        |\n| `nunjucks`   | `.njk`      | Powerful and Django-like    |\n| `mustache`   | `.mustache` | Minimal and logic-less      |\n\n---\n\n## 🧠 Runtime Compatibility\n\n| Runtime | Supported  | Notes                     |\n| ------- | ---------- | ------------------------- |\n| Node.js | ✅          | Recommended               |\n| Bun     | ✅          | Fully supported           |\n| Deno     | ✅          | Fully supported           |\n\n---\n\n## 📂 Example View Structure\n\n```bash\nviews/\n├── home.ejs\n├── layout.pug\n├── about.hbs\n├── user/\n│   └── profile.mustache\n```\n\n---\n\n## ✅ Also include in your `docs/` folder\n\nYou can save this as:\n\n```bash\n/docs/view-engine.md\n````\n\nor\n\n```bash\nREADME.md → root of helpers/view-engine/\n```\n"
            }
          ]
        }
      ]
    },
    {
      "originalPath": "99. Examples",
      "name": "Examples",
      "path": "examples",
      "type": "folder",
      "children": [
        {
          "originalPath": "1. Uploader.md",
          "id": 49,
          "name": "Uploader",
          "type": "file",
          "path": "examples/uploader",
          "content": "\n# 📤 File Upload Middleware\n\n## Overview\n\nTezX provides first-class support for file uploads via its `useFormData` utility, allowing you to handle file uploads with minimal setup. This example demonstrates how to accept, read, and save a file using native `fs/promises` and `path`.\n\n## Features\n\n* Parses incoming multipart/form-data requests.\n* Supports extracting and saving uploaded files.\n* Handles errors with clear responses.\n* Compatible with modern runtimes like Bun, Node.js, and Deno.\n\n---\n\n## Example Usage\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\nimport { useFormData } from \"tezx/helper\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await useFormData(ctx);\n  const file = formData?.files as File; // Get uploaded file\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Destination path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save to disk\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n---\n\n## 🔍 Notes\n\n* Make sure the `uploads` directory exists or create it before saving.\n* `formData.files` can also be an array if multiple files are submitted.\n* To support multiple files, iterate over `formData.files`:\n\n```ts\nconst files = formData?.files as File[];\nfor (const file of files) {\n  const buffer = await file.arrayBuffer();\n  await writeFile(join(process.cwd(), \"uploads\", file.name), Buffer.from(buffer));\n}\n```\n\n---\n\n## 🧪 Testing with cURL\n\n```bash\ncurl -F \"file=@/path/to/file.png\" http://localhost:3000/data\n```\n\n---\n"
        },
        {
          "originalPath": "2. Swagger UI.md",
          "id": 50,
          "name": "Swagger UI",
          "type": "file",
          "path": "examples/swagger-ui",
          "content": "### [OpenAPI JSON Example](https://petstore3.swagger.io/api/v3/openapi.json)\n\n```typescript\n/**\n * Serves Swagger UI at the specified route using an HTML template.\n * \n * @param jsonPath - The relative or absolute path to the OpenAPI JSON file (default: \"docs.json\").\n * @param swaggerVersion - The Swagger UI distribution version to use (default: \"5.11.0\").\n * @param meta - Optional metadata to customize the Swagger UI HTML page.\n * @param meta.title - The title to display in the browser tab (default: \"SwaggerUI\").\n * @param meta.metaDescription - A short description for the page (used in <meta> tag).\n * \n * @returns A middleware function that returns Swagger UI HTML when invoked with a context object.\n * \n * @example\n * app.get('/docs', swaggerUI('openapi.json'));\n */\nexport function swaggerUI(\n  jsonPath: string = \"docs.json\",\n  swaggerVersion: string = \"5.11.0\",\n  meta?: {\n    title?: string;\n    metaDescription?: string;\n  }\n) {\n  return (ctx: any) => {\n    return ctx.html(`\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>${meta?.title || \"SwaggerUI\"}</title>\n  <meta name=\"description\" content=\"${meta?.metaDescription || \"SwaggerUI Documentation\"}\" />\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui.css\" />\n</head>\n<body>\n  <div id=\"swagger-ui\"></div>\n  <script src=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui-bundle.js\" crossorigin></script>\n  <script src=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui-standalone-preset.js\" crossorigin></script>\n  <script>\n   window.onload = () => {\n      window.ui = SwaggerUIBundle({\n        url: \"${jsonPath}\",\n        dom_id: '#swagger-ui',\n        presets: [\n          SwaggerUIBundle.presets.apis,\n          SwaggerUIStandalonePreset\n        ],\n        layout: \"StandaloneLayout\",\n      });\n    };\n  </script>\n</body>\n</html>\n`);\n  };\n}\n```\n"
        },
        {
          "originalPath": "4. Basic Auth Client.md",
          "id": 51,
          "name": "Basic Auth Client",
          "type": "file",
          "path": "examples/basic-auth-client",
          "content": "# 🔐 Accessing Protected Routes with Basic Authentication\n\nThis guide demonstrates how to access routes secured with HTTP Basic Authentication using various tools and libraries.\n\n---\n\n### **1. Using cURL**\n\n**Option 1: With `-u` flag (recommended)**\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\n**Option 2: Manually set the `Authorization` header**\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\n✅ `-u` automatically encodes credentials using Base64.\n\n---\n\n### **2. Using Postman**\n\n1. Open a new request in Postman.\n2. Navigate to the **Authorization** tab.\n3. Choose **Basic Auth** as the type.\n4. Enter your `username` and `password`.\n5. Click **Send**.\n\nPostman automatically encodes and adds the `Authorization` header.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\n```js\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\n🔍 `btoa()` encodes the credentials in Base64 format.\n\n---\n\n### **4. Using Axios**\n\n```js\nconst axios = require(\"axios\");\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username: \"admin\",\n      password: \"password123\",\n    },\n  })\n  .then((res) => console.log(res.data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\n💡 The `auth` option in Axios handles Base64 encoding internally.\n\n---\n"
        },
        {
          "originalPath": "5. SSE implement.md",
          "id": 52,
          "name": "SSE implement",
          "type": "file",
          "path": "examples/sse-implement",
          "content": "\n# 📡 `sse`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## ✅ Syntax\n\n## 🧠 Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n## 📦 Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## 📋 Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.get(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## 🧪 Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"🔴 Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n"
        },
        {
          "originalPath": "6. Detect Locale.md",
          "id": 53,
          "name": "Detect Locale",
          "type": "file",
          "path": "examples/detect-locale",
          "content": "```ts\nimport { Context, Middleware } from \"tezx\";\nimport { getCookie } from \"tezx/helper\";\n\n/**\n * Options for the detectLocale middleware.\n */\nexport type DetectLocaleOptions = {\n  /**\n   * 🌐 List of allowed locales.\n   * e.g., [\"en\", \"fr\", \"bn\"]\n   */\n  supportedLocales: string[];\n\n  /**\n   * 🏠 Default locale if none is matched from query, cookie, or headers.\n   * @default \"en\"\n   */\n  defaultLocale?: string;\n\n  /**\n   * 🔍 Name of the query parameter to check for locale.\n   * Example: /?lang=fr\n   * @default \"lang\"\n   */\n  queryKeyLocale?: string;\n\n  /**\n   * 🍪 Name of the cookie used to store locale preference.\n   * @default \"locale\"\n   */\n  cookieKeyLocale?: string;\n\n  /**\n   * 🗺️ Key under which the locale will be attached to the context object.\n   * Example: ctx.locale = \"en\"\n   * @default \"locale\"\n   */\n  localeContextKey?: string;\n\n  /**\n   * 🛠️ Optional custom function to programmatically detect locale.\n   * Called last before fallback.\n   * Should return a supported locale or undefined.\n   */\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\n/**\n * 🌍 Middleware that detects and sets the user's preferred locale.\n *\n * Detection order:\n * 1. Query parameter (e.g., ?lang=fr)\n * 2. Cookie value (e.g., locale=fr)\n * 3. Accept-Language HTTP header\n * 4. Custom detector function (if provided)\n * 5. Default locale (fallback)\n *\n * The detected locale is stored in `ctx[localeContextKey]`.\n *\n * @param options - Configuration options for locale detection.\n * @returns Middleware function that attaches locale to the context.\n */\nconst detectLocale = (options: DetectLocaleOptions): Middleware => {\n  const {\n    supportedLocales,\n    defaultLocale = \"en\",\n    queryKeyLocale = \"lang\",\n    cookieKeyLocale = \"locale\",\n    localeContextKey = \"locale\",\n    customLocaleDetector,\n  } = options;\n\n  return async function detectLocale(ctx, next) {\n    let detectedLocale: string | undefined;\n    // Step 1: Check query parameter\n    const queryLocale = ctx.req.query[queryKeyLocale];\n\n    if (queryLocale && supportedLocales.includes(queryLocale)) {\n      detectedLocale = queryLocale;\n    }\n\n    // Step 2: Check cookies\n    if (!detectedLocale) {\n      const cookieLocale = getCookie(ctx, cookieKeyLocale);\n      if (cookieLocale && supportedLocales.includes(cookieLocale)) {\n        detectedLocale = cookieLocale;\n      }\n    }\n\n    // Step 3: Check Accept-Language header\n    if (!detectedLocale) {\n      const acceptLanguage = ctx.req.header(\"accept-language\");\n      if (acceptLanguage) {\n        const preferredLocales = acceptLanguage\n          .split(\",\")\n          .map((lang) => lang.split(\";\")[0].trim())\n          .filter((lang) => supportedLocales.includes(lang));\n        detectedLocale = preferredLocales[0];\n      }\n    }\n\n    // Step 4: Check custom locale detector\n    if (!detectedLocale && customLocaleDetector) {\n      const customLocale = customLocaleDetector(ctx);\n      if (customLocale && supportedLocales.includes(customLocale)) {\n        detectedLocale = customLocale;\n      }\n    }\n\n    // Step 5: Fall back to default locale\n    if (!detectedLocale) {\n      detectedLocale = defaultLocale;\n    }\n    // Attach the detected locale to the context\n    ctx[localeContextKey] = detectedLocale;\n    // Proceed to the next middleware\n    return await next();\n  };\n};\n\nexport { detectLocale as default, detectLocale };\n\n```\n"
        }
      ]
    }
  ],
  "files": [
    {
      "id": 1,
      "path": "benchmarking",
      "name": "Benchmarking",
      "folder": ".",
      "content": "# 🚀 Benchmarking Performance\n\nTezX is built for speed and efficiency, supporting multiple JavaScript runtimes. This section highlights real-world HTTP server benchmarks comparing TezX performance on **Bun**, **Deno**, and **Node.js** using `wrk`, a popular HTTP benchmarking tool.\n\n---\n\n## ⚙️ Test Setup\n\n* **Benchmark Tool:** [wrk](https://github.com/wg/wrk) (v4.1+)\n* **Test Duration:** 10 seconds\n* **Threads:** 12\n* **Concurrent Connections:** 400\n* **Endpoint:** `/` (simple text response)\n* **Ports:** Bun & Deno on `3001`, Node.js on `3000`\n\n---\n\n## 📊 Benchmark Summary\n\n| Runtime     | Requests/sec     | Avg Latency | Transfer Rate |\n| ----------- | ---------------- | ----------- | ------------- |\n| **Bun**     | **69,367 req/s** | 5.66 ms     | 9.59 MB/s     |\n| **Deno**    | 58,061 req/s     | 6.76 ms     | 9.30 MB/s     |\n| **Node.js** | 13,859 req/s     | 28.63 ms    | 2.17 MB/s     |\n\n---\n\n## 🔍 Detailed Output\n\n### 🟢 Bun\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 5.66 ms | Stdev: 663.46 µs | Max: 12.62 ms\nRequests/sec Avg: 5.86k | Max peak: 35.51k\nTotal Requests: 700,594 | Transfer: 96.88 MB\n```\n\n### 🟡 Deno\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3001\n\nLatency     Avg: 6.76 ms | Stdev: 791.19 µs | Max: 13.53 ms\nRequests/sec Avg: 4.91k | Max peak: 62.61k\nTotal Requests: 586,419 | Transfer: 93.95 MB\n```\n\n### 🔴 Node.js\n\n```bash\nwrk -t12 -c400 -d10s http://localhost:3000\n\nLatency     Avg: 28.63 ms | Stdev: 5.89 ms | Max: 120 ms\nRequests/sec Avg: 1.16k | Max peak: 1.38k\nTotal Requests: 138,852 | Transfer: 21.72 MB\n```\n\n---\n\n## 💡 Insights\n\n* **Bun** demonstrates exceptional throughput and low latency, benefiting from its highly optimized JavaScript runtime and native HTTP server.\n* **Deno** performs admirably, striking a balance between speed and robustness with modern runtime features.\n* **Node.js** remains a solid choice but shows higher latency and lower request capacity under heavy concurrency.\n\n---\n\n## 📈 Why Does This Matter?\n\n* **High Throughput:** Enables TezX to handle thousands of requests per second, ideal for real-time apps and APIs.\n* **Low Latency:** Improves user experience by reducing response delays.\n* **Runtime Flexibility:** TezX runs efficiently on multiple platforms — choose the runtime that best fits your deployment needs.\n\n---\n\n## 🔗 Further Reading\n\n* [Bun Official Website](https://bun.sh)\n* [Deno Official Website](https://deno.land)\n* [Node.js Official Website](https://nodejs.org)\n* [wrk Benchmark Tool](https://github.com/wg/wrk)\n"
    },
    {
      "id": 2,
      "path": "getting-started/create-app",
      "name": "Create app",
      "folder": "Getting Started",
      "content": "# ⚡ Create TezX\n\nEasily scaffold a new [TezX](https://github.com/tezxjs/tezx) project using official starter templates. Whether you're building a backend with WebSocket support or a TypeScript-powered server, `create-tezx` gets you started fast.\n\n---\n\n## 🚀 Quick Start\n\nStarter templates are available for common runtimes and package managers. Run one of the following commands:\n\n```bash\n# npm\nnpm create tezx@latest\nnpx create-tezx-app@latest\n# yarn\nyarn create tezx\n\n# pnpm\npnpm create tezx@latest\n\n# bun\nbun create tezx@latest\n\n# deno\ndeno run -A npm:create-tezx@latest\n````\n\nThis will launch an interactive setup. You can also skip prompts using CLI flags.\n\n---\n\n## ⚙️ CLI Options\n\nYou can skip interactive prompts by passing options directly via the command line.\n\n### `-t`, `--template <template>`\n\nUse a specific template by name.\n\n```bash\nnpm create tezx@latest my-app -- --template minimal\n```\n\n---\n\n### `-i`, `--install`\n\nAutomatically install dependencies after project setup.\n\n```bash\nnpm create tezx@latest my-app -- --install\n```\n\n---\n\n### `-p`, `--pm <npm|pnpm|bun|yarn>`\n\nChoose a package manager.\n\n```bash\nnpm create tezx@latest my-app -- --pm bun\n```\n\n---\n\n### `--ts`, `-ts`\n\nEnable TypeScript in the scaffolded project.\n\n```bash\nnpm create tezx@latest my-app -- --ts\n```\n\n---\n\n### `--env`, `--runtime`, `-env`, `-runtime`\n\nSet the runtime environment: `node`, `bun`, or `deno`.\n\n```bash\nnpm create tezx@latest my-app -- --runtime bun\n```\n\n---\n\n### `--y`, `--yes`, `-y`, `-yes`\n\nSkip all prompts using sensible defaults.\n\n```bash\nnpm create tezx@latest my-app -- --yes\n```\n\n---\n\n## 📁 Supported Templates\n\n> ✅ More templates coming soon!\n\n| Template        | Description                     | Flag Example               |\n| --------------- | ------------------------------- | -------------------------- |\n| `minimal`       | Minimal TypeScript setup        | `--template minimal`       |\n<!-- | `ws`            | WebSocket support (Node or Bun) | `--template ws`            | -->\n| `google-oauth2` | Google OAuth2 integration       | `--template google-oauth2` |\n| `github-oauth2` | GitHub OAuth2 integration       | `--template github-oauth2` |\n\n---\n\n## 🧪 Example Usage\n\n```bash\nnpm create tezx@latest my-app -- --template ws --ts --runtime node --install\n```\n\n```bash\nbun create tezx@latest auth-app -- --template google-oauth2 --pm bun --yes\n```\n\n---\n\n## 🧑‍💻 Author\n\nBuilt by [Rakibul Islam](https://github.com/srakib17)\nand [TezX](https://github.com/tezxjs/tezx) contributors.\n\n---\n"
    },
    {
      "id": 3,
      "path": "getting-started/installation",
      "name": "Installation",
      "folder": "Getting Started",
      "content": "# ⚡ TezX — High-Performance Backend Framework\n\n**TezX** is a **modern, ultra-fast, and lightweight JavaScript framework** for **Node.js, Bun, and Deno**.\nIt’s built for **speed, scalability, and developer happiness** — with clean APIs, built-in middleware, and static file serving.\n\n---\n\n## ✨ Why TezX?\n\n* 🚀 **Blazing Fast** — Optimized for concurrency and low-latency\n* ⚙️ **Minimal API** — Learn once, scale everywhere\n* 🛡️ **Secure by Default** — Best practices baked in\n* 🧩 **Powerful Middleware** — Composable and modular\n* 🗂️ **Zero-Config Static Files** — Serve instantly\n* 🌐 **Universal Runtime** — Runs on **Node**, **Bun**, and **Deno**\n\n---\n\n## 🚀 Quick Start\n\n### 1. Setup\n\n```bash\nmkdir my-tezx-app && cd my-tezx-app\nnpm init -y               # or bun init\nnpm install tezx          # or bun add tezx\n```\n\n### 2. Project Structure\n\n```bash\n.\n├── src/\n│   └── index.ts        # App entry\n├── public/             # Static files\n├── .env                # Env variables\n└── tsconfig.json       # TypeScript config\n```\n\n### 3. Create `.env`\n\n```bash\nPORT=3000\nNODE_ENV=development\nSECRET_KEY=super_secret_key\n```\n\n---\n\n## 🖥️ Basic Server (Node.js)\n\n```ts\n// src/index.ts\nimport { TezX } from \"tezx\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { logger } from \"tezx/middleware\";\nimport { createServer } from \"http\";\n\nconst env = loadEnv();\nconst app = new TezX({ env });\n\napp.use(logger());\napp.get(\"/\", (ctx) => ctx.text(\"Hello TezX!\"));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(env.PORT || 3000, () => {\n  console.log(`🚀 Server running → http://localhost:${env.PORT || 3000}`);\n});\n```\n\n---\n\n## ⚙️ Runtime-Specific Setup\n\n### ▶️ Bun\n\n```ts\nimport { wsHandlers } from \"tezx/bun\";\n\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: wsHandlers(),\n});\n```\n\n### ▶️ Deno\n\n```ts\nDeno.serve({ port: 3001 }, (req, connInfo) => app.serve(req, connInfo));\n```\n\n---\n\n## 🛠️ Dev Scripts\n\n### Node (`package.json`)\n\n```json\n\"scripts\": {\n  \"dev\": \"tsx watch src/index.ts\",\n  \"build\": \"tsc\",\n  \"start\": \"node dist/index.js\"\n}\n```\n\n### Bun\n\n```json\n\"scripts\": {\n  \"dev\": \"bun run --hot src/index.ts\"\n}\n```\n\n### Deno\n\n```json\n\"scripts\": {\n  \"dev\": \"deno run --watch --allow-all src/index.ts\"\n}\n```\n\n---\n\n## 🔧 Middleware Examples\n\n### Serve Static Files\n\n```ts\napp.static(serveStatic(\"./public\", {\n  cacheControl: \"public, max-age=31536000\",\n  headers: { \"X-Custom-Header\": \"static\" },\n}));\n```\n\n### Enable CORS\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\napp.use(cors({\n  origin: [\"http://localhost:3000\"],\n  methods: [\"GET\", \"POST\"],\n}));\n```\n\n### Logging\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n});\n```\n\n---\n\n## 📦 TypeScript Setup\n\n### Build\n\n```bash\ntsc\n```\n\n### Example `tsconfig.json`\n\n```json\n{\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"module\": \"nodenext\",\n    \"target\": \"ESNext\",\n    \"moduleResolution\": \"nodenext\",\n    \"skipLibCheck\": true,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"strict\": true\n  },\n  \"include\": [\"src\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}\n```\n\n---\n\n## 🛠️ Troubleshooting\n\n| Problem                     | Solution                           |\n| --------------------------- | ---------------------------------- |\n| `Cannot find module 'tezx'` | Run `npm install` / `bun add tezx` |\n| Port already in use         | Change `PORT` in `.env`            |\n| TypeScript errors           | Review `tsconfig.json`             |\n| `.env not loading`          | Ensure `.env` exists at root       |\n\n---\n\n## 💡 Pro Tip\n\nFor **real-time apps** or **serverless workloads**, run **TezX on Bun** for:\n✅ Faster cold starts\n✅ Lower memory footprint\n✅ High-concurrency handling\n\n---\n\n⚡ **TezX is your go-to framework** when you need speed, flexibility, and a clean developer experience.\n\n---\n"
    },
    {
      "id": 4,
      "path": "getting-started/configuration",
      "name": "Configuration",
      "folder": "Getting Started",
      "content": "# 🚀 TezX Configuration Guide\n\nThe `TezX` framework is **highly configurable**, letting you fine-tune routing, environment handling, middleware, and even plug in your own **custom router**.\n\nThis guide explains every option you can pass to the `TezX` constructor, including **advanced use cases with `routeRegistry`**.\n\n---\n\n## ⚡ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { loadEnv } from \"tezx/bun\";\n\nconst env = loadEnv();\n\nconst app = new TezX({\n  debugMode: true,\n  env,\n  basePath: \"/api\",\n});\n```\n\n---\n\n## 🧠 `TezXConfig` at a Glance\n\nHere’s the configuration shape:\n\n```ts\nexport type TezXConfig = {\n  debugMode?: boolean;\n  onPathResolve?: (pathname: string) => string;\n  routeRegistry?: RouteRegistry; // plug in custom router\n} & RouterConfig;\n\nexport type RouterConfig = {\n  env?: Record<string, string | number>;\n  basePath?: string;\n};\n```\n\n---\n\n## ⚙️ Available Options\n\n### 1. `debugMode`\n\n* **Type**: `boolean`\n* **Default**: `false`\n* **What it does**: Enables verbose request/error logging for development.\n\n```ts\nconst app = new TezX({ debugMode: true });\n```\n\n---\n\n### 2. `env`\n\n* **Type**: `Record<string, string | number>`\n* **What it does**: Inject environment variables into the app.\n\n```ts\nconst env = { PORT: \"3001\", API_KEY: \"secret\" };\nconst app = new TezX({ env });\nconsole.log(process.env.PORT); // \"3001\"\n```\n\n---\n\n### 3. `basePath`\n\n* **Type**: `string`\n* **What it does**: Prefixes all routes with a global path (ideal for **API versioning**).\n\n```ts\nconst app = new TezX({ basePath: \"/v1\" });\n\napp.get(\"/users\", (ctx) => ctx.text(\"v1 Users\"));\n// → accessible at /v1/users\n```\n\n---\n\n### 4. `onPathResolve`\n\n* **Type**: `(pathname: string) => string`\n* **What it does**: Hook to rewrite or normalize request paths before routing.\n\n```ts\nconst app = new TezX({\n  onPathResolve: (path) => path.toLowerCase().replace(/\\/+$/, \"\"),\n});\n```\n\n---\n\n### 5. `routeRegistry`\n\n* **Type**: `RouteRegistry`\n* **What it does**: Supply your own **custom router** implementation.\n* **Why**: Lets you control route resolution, sub-routing, and middleware execution at a lower level.\n\n---\n\n## 🧩 Using a Custom Router (`routeRegistry`)\n\nYou can pass any router implementing the `RouteRegistry` interface to `TezX`.\n\nThis gives you **complete control** over how routes are matched and middleware is executed.\n\n### Example: Plugging in a Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { PowerfulCustomRouter } from \"./PowerfulCustomRouter\";\nconst customRouter = new PowerfulCustomRouter();\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: customRouter,\n});\n```\n\n### How It Works\n\n* `TezX` internally calls `routeRegistry.search(method, path)` to resolve handlers.\n* Middleware registered with `\"ALL\"` runs before method-specific handlers.\n* Supports all HTTP methods + route parameters.\n\n---\n\n## 🛠 Real-World Example: Sub-Routing with Custom Router\n\n```ts\nimport { TezX } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst router = new CustomRouter();\n\nrouter.addRoute(\"GET\", \"/hello\", [\n  async (ctx) => ctx.text(\"Hello from custom router!\"),\n]);\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: router,\n  basePath: \"/api\",\n});\n\napp.use(\"/api\", async (ctx, next) => {\n  console.log(`[Middleware] ${ctx.method} ${ctx.pathname}`);\n  await next();\n});\n\n// Start server with Bun, Deno, or Node.js\n```\n\n---\n\n## 📦 Summary of Options\n\n| Option          | Type                               | Purpose                                  |\n| --------------- | ---------------------------------- | ---------------------------------------- |\n| `debugMode`     | `boolean`                          | Enable verbose request/error logging     |\n| `env`           | `Record<string, string \\| number>` | Inject environment variables             |\n| `basePath`      | `string`                           | Add global prefix to all routes          |\n| `onPathResolve` | `(pathname: string) => string`     | Normalize/transform paths before routing |\n| `routeRegistry` | `RouteRegistry`                    | Use a custom router implementation       |\n\n---\n\n## ✅ Best Practices\n\n* Use **`basePath`** for API versioning (e.g., `/v1`, `/v2`).\n* Inject a **custom router** (`routeRegistry`) for fine-grained control.\n* Use **`onPathResolve`** to normalize paths (lowercasing, trimming).\n* Pass **`env`** for consistent environment configs across runtimes.\n\n---\n"
    },
    {
      "id": 5,
      "path": "environment/nodejs",
      "name": "NodeJS",
      "folder": "Environment",
      "content": "\n# 🔧 TezX with Node.js – (`mountTezXOnNode`)\n\nBuild modern, middleware-driven APIs in Node.js using **TezX**, a lightweight server framework with first-class support for the Fetch API and native HTTP integration.\n\n---\n\n## ✅ Prerequisites\n\n* [Node.js](https://nodejs.org/) v16 or higher\n* TezX installed via `npm`, `yarn`, or `pnpm`\n\n```bash\n# Choose your preferred package manager\nnpm install tezx\n# or\nyarn add tezx\n# or\npnpm add tezx\n```\n\n---\n\n## 🗂️ Recommended Project Structure\n\n```bash\nproject/\n├── src/\n│   └── app.ts          # TezX app instance\n├── server.ts           # Native Node.js HTTP server\n├── .env                # Environment config\n```\n\n---\n\n## 🚀 Setting Up the Server (`server.ts`)\n\n```ts\nimport { createServer } from \"node:http\";\nimport { mountTezXOnNode, loadEnv } from \"tezx/node\";\nimport { app } from \"./src/app\";\n\n// Load environment variables from `.env` into process.env\nloadEnv();\n\n// Create a native HTTP server\nconst server = createServer();\n\n// Mount TezX to handle requests\nmountTezXOnNode(app, server);\n\n// Start listening on the defined port\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`🚀 TezX is running at http://localhost:${PORT}`);\n});\n```\n\n---\n\n## 📄 Example `.env`\n\n```env\nPORT=3000\n```\n\n> Loaded via `loadEnv()` and available as `process.env.PORT`\n\n---\n\n## 🧪 Running the Server\n\n```bash\nnode server.ts\n# or with live-reloading (recommended for dev)\nnpx nodemon server.ts\n```\n\n---\n\n## 🧠 What Does `mountTezXOnNode` Do?\n\n`mountTezXOnNode(app, server)` enables TezX to work natively with Node.js by:\n\n* 🔁 **Transforming** Node’s `IncomingMessage` into a Fetch-compatible `Request`\n* 📤 **Passing** the request to your TezX app via `app.serve()`\n* 📥 **Converting** the Fetch `Response` back into a native HTTP response\n* 🚰 **Supporting** streaming (files, JSON, Server-Sent Events)\n* 🛡️ **Handling** edge cases like errors and connection aborts cleanly\n\n---\n\n## 📚 Feature Breakdown\n\n| Feature                        | Description                                                          |\n| ------------------------------ | -------------------------------------------------------------------- |\n| `createServer()`               | Standard Node.js HTTP server                                         |\n| `mountTezXOnNode(app, server)` | Binds your TezX app to the server                                    |\n| Request conversion             | `IncomingMessage` → Fetch `Request`                                  |\n| Response conversion            | Fetch `Response` → `ServerResponse` (with stream support)            |\n| Streaming & SSE support        | Handles large or continuous data (e.g., file download, live updates) |\n| Error handling                 | Graceful 500 responses and logging                                   |\n| `.env` support via `loadEnv()` | Automatically loads environment variables                            |\n| Compatibility                  | Works with HTTP/1.x and HTTP/2 servers in Node.js                    |\n\n---\n\n## ✅ Benefits\n\n* 🔧 Native Node.js support without needing adapters\n* ✨ Clean Fetch API interface (like Deno or Bun)\n* 🧱 Minimal boilerplate, ideal for microservices or APIs\n* 🌊 Streaming-ready (e.g., `ctx.stream()`, SSE, large files)\n* 🧩 Works with existing Node.js tooling (e.g., Nodemon, PM2, ts-node)\n\n---\n\n## 🔁 Next Steps\n\n* Add routes using `.get()`, `.post()`, `.use()` on your `app` instance\n* Integrate `middleware`, `env`, and `logging` for full control\n* Explore WebSocket support (if using Bun/Deno) or custom WS handlers for Node.js\n\n---\n"
    },
    {
      "id": 6,
      "path": "environment/bun",
      "name": "Bun",
      "folder": "Environment",
      "content": "# ⚡ TezX + Bun Integration Guide\n\nLeverage **TezX** on the ultra-fast **Bun** runtime to build modern, scalable APIs with WebSocket support.\n\n---\n\n## ✅ Prerequisites\n\nMake sure you have:\n\n* [**Bun**](https://bun.sh) — modern all-in-one JavaScript runtime\n* [**TezX**](https://www.npmjs.com/package/tezx) — high-performance backend framework\n\nInstall TezX via Bun:\n\n```bash\nbun add tezx\n```\n\n---\n\n## 📁 Recommended Project Structure\n\n```bash\nproject/\n├── src/\n│   └── app.ts       # TezX app instance & routes\n├── server.ts        # Bun HTTP server entry point\n├── .env             # Environment variables\n```\n\n---\n\n## 🌐 Server Setup (with WebSocket Support)\n\n### `server.ts`\n\n```ts\nimport { loadEnv, wsHandlers } from \"tezx/bun\";\nimport { app } from \"./src/app\"; // TezX app instance\n\n// Load environment variables from .env\nloadEnv();\n\nBun.serve({\n  port: Number(process.env.PORT) || 3001,\n  reusePort: true, // Enables multi-process clustering\n  fetch(req, server) {\n    return app.serve(req, server); // Handle requests via TezX\n  },\n  websocket: wsHandlers({\n    // Optional WebSocket configure\n  })\n});\n\nconsole.log(`🚀 Server running at http://localhost:${process.env.PORT}`);\n```\n\n---\n\n## 📄 Example `.env`\n\n```env\nPORT=3001\n```\n\n> TezX automatically loads `.env` variables via `loadEnv()`. Accessible in your code via `process.env`.\n\n---\n\n## 🧪 Running the Server\n\nStart with live-reload during development:\n\n```bash\nbun run --watch server.ts\n```\n\nOr start normally:\n\n```bash\nbun run server.ts\n```\n\n---\n\n## 📚 Key Concepts & Features\n\n| Feature              | Description                                                       |\n| -------------------- | ----------------------------------------------------------------- |\n| `Bun.serve()`        | Launches the HTTP server (similar to Node.js `createServer`)      |\n| `reusePort: true`    | Enables multi-process (cluster) support for improved scalability  |\n| `fetch(req, server)` | Entry point for handling HTTP requests via TezX's `app.serve()`   |\n| `websocket`          | Manages WS lifecycle: `open`, `message`, `close` events           |\n| `ws.data`            | Attach custom session-specific data per WebSocket connection      |\n| `loadEnv()`          | Automatically loads `.env` variables for consistent configuration |\n\n---\n\n## 🚀 Pro Tips\n\n* **Clustering**: `reusePort: true` allows Bun to spawn multiple processes for high-concurrency workloads.\n* **WebSockets**: Use `wsHandlers()` to easily manage real-time connections and events.\n* **Environment management**: Always define `PORT` and other sensitive values in `.env`.\n* **Middleware-ready**: TezX middlewares work seamlessly in Bun for logging, security, and more.\n\n---\n"
    },
    {
      "id": 7,
      "path": "environment/deno",
      "name": "Deno",
      "folder": "Environment",
      "content": "# 🚀 TezX with Deno — Developer Guide\n\nBuild modern, high-performance HTTP applications using the TezX framework on Deno.\n\n---\n\n## ✅ Prerequisites\n\n* [Deno](https://deno.land) installed (v1.44+ recommended)\n* Basic knowledge of Deno’s permissions and module system\n* TezX app instance (`app`) created in `src/index.ts`\n\n---\n\n## 🛠️ Setup: `server.ts`\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { app } from \"./src/index.ts\";\n\n// Load environment variables from `.env` and `.env.local`\nawait loadEnv();\n\n// Start the HTTP server\nDeno.serve({ port: Number(Deno.env.get(\"PORT\") || 5000) }, (req, connInfo) => {\n  return app.serve(req, connInfo);\n});\n```\n\n---\n\n## 📁 Project Structure\n\n```bash\nmy-tezx-project/\n├── src/\n│   └── index.ts        # Your TezX app instance\n├── .env                # Environment variables\n├── server.ts           # Entry point\n```\n\n---\n\n## 📦 Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=MyDenoTezXApp\n```\n\nTezX will automatically load:\n\n* `.env`\n* `.env.local` (if exists)\n\nThese are injected into both `Deno.env` and `process.env` (polyfilled where applicable).\n\n---\n\n## 📌 Accessing Env Variables\n\n```ts\nconst port = Number(Deno.env.get(\"PORT\") || 5000);\nconst appName = Deno.env.get(\"APP_NAME\");\n```\n\n---\n\n## 📝 Deno Permissions\n\nTo use `.env` and serve HTTP, ensure the following permissions:\n\n```bash\ndeno run --allow-net --allow-env --allow-read server.ts\n```\n\nAlternatively, for full access during development:\n\n```bash\ndeno run --allow-all server.ts\n```\n\n---\n\n## 🔁 Live Development (with Watch)\n\n```bash\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## 📦 Optional: Use with NPM via `npm:` specifier\n\nIf you're integrating with an NPM-style toolchain or writing hybrid code:\n\n```ts\nimport { loadEnv } from \"npm:tezx/deno\";\n```\n\n---\n\n## 🔧 Pro Tip: Create a Run Script\n\nAdd to your `deno.json` for easier use:\n\n```json\n{\n  \"tasks\": {\n    \"dev\": \"deno run --watch --allow-all server.ts\",\n    \"start\": \"deno run --allow-all server.ts\"\n  }\n}\n```\n\nThen run with:\n\n```bash\ndeno task dev\n```\n\n---\n\n## 📚 Additional Docs\n\n* TezX Docs: *coming soon*\n* Deno Docs: [https://deno.land/manual](https://deno.land/manual)\n* Deno Permissions: [https://deno.land/manual@latest/basics/permissions](https://deno.land/manual@latest/basics/permissions)\n\n---\n"
    },
    {
      "id": 8,
      "path": "api/tezx/app",
      "name": "App",
      "folder": "API/TezX",
      "content": "# ⚡ TezX – Application Initialization Guide\n\n`TezX` is a **high-performance, middleware-driven server framework** designed for **Deno**, **Bun**, and **Node.js**. It provides first-class support for:\n\n* Route handling & dynamic path matching\n* Middleware chaining at global and route level\n* Runtime-agnostic request lifecycle management\n\n---\n\n## 🚀 Quick Start (`server.ts`)\n\n```ts\n// server.ts\nimport { loadEnv } from \"tezx/deno\";\nimport { TezX } from \"tezx/core\";\nimport { CustomRouter } from \"./router.ts\"; // Your custom routes\nimport { logger } from \"tezx/middleware\";\n\n// Load environment variables\nawait loadEnv();\n\n// Initialize TezX app\nconst app = new TezX({\n  routeRegistry: new CustomRouter(),        // Custom route tree\n  debugMode: true,                          // Enable detailed debug logs\n  onPathResolve: (path) => path             // Optional path normalization\n                    .replace(/\\/+$/, \"\")\n                    .toLowerCase(),\n});\n\n// Register global middleware\napp.use(logger);\n\n// Start server (Deno example)\nDeno.serve({ port: 5000 }, app.serve);\n```\n\n---\n\n## 📁 Recommended Project Structure\n\n```bash\nproject/\n├── middlewares/\n│   └── logger.ts\n├── router.ts\n├── server.ts\n├── .env\n└── src/\n    └── handlers/\n        └── home.ts\n```\n\n---\n\n## ⚙ TezX Configuration (`TezXConfig`)\n\n| Option          | Type                       | Description                                         |\n| --------------- | -------------------------- | --------------------------------------------------- |\n| `routeRegistry` | `Router`                   | Custom router implementing the `Router` interface   |\n| `debugMode`     | `boolean`                  | Enable detailed middleware-level logging            |\n| `onPathResolve` | `(path: string) => string` | Hook to normalize or rewrite incoming request paths |\n| `basePath`      | `string`                   | Optional prefix for all routes (default `/`)        |\n| `env`           | `Record<string, any>`      | Custom environment object available in each context |\n\n---\n\n## 🛡 Global Middleware Support\n\nMiddleware functions have access to the **context (`ctx`)** and **`next()`** callback:\n\n```ts\nimport { Middleware } from \"tezx\";\n\nexport const loggerMiddleware: Middleware = async (ctx, next) => {\n  console.log(`[${ctx.method}] ${ctx.pathname}`);\n  await next();\n};\n\n// Register globally\napp.use(loggerMiddleware);\n```\n\n---\n\n## ➕ Route-Level Middleware\n\n`TezX` supports **ALL-method middleware** for interceptors, guards, or path-specific logic:\n\n```ts\napp.when(\"ALL\", \"/admin/:section\", adminAuthMiddleware);\n```\n\n---\n\n## ❌ Custom 404 Handler\n\n```ts\napp.notFound((ctx) => ctx.status(404).text(\"🔍 Not Found\"));\n```\n\n---\n\n## 🛠 Custom Error Handling\n\n```ts\napp.onError((err, ctx) => {\n  console.error(\"Unhandled error:\", err.details);\n  return ctx.status(500).text(\"🔥 Internal Server Error\");\n});\n```\n\n---\n\n## 📦 Environment Variables (`.env`)\n\n```bash\nPORT=5000\nAPP_NAME=TezXApp\n```\n\nAccess variables anywhere in your app:\n\n```ts\nconst port = Deno.env.get(\"PORT\");\n```\n\n---\n\n## 🧪 Running the Server\n\n```bash\n# Standard run\ndeno run --allow-net --allow-read --allow-env server.ts\n\n# Live reload during development\ndeno run --watch --allow-all server.ts\n```\n\n---\n\n## 🧬 Runtime Compatibility\n\n| Feature    | Deno       | Bun        | Node.js   |\n| ---------- | ---------- | ---------- | --------- |\n| `.serve()` | ✅ Native   | ✅ Native   | ✅ Adapter |\n| Middleware | ✅ Yes      | ✅ Yes      | ✅ Yes     |\n| WebSocket  | ✅ Built-in | ✅ Built-in | ➖ Custom  |\n\n---\n\n## 💡 Summary\n\n| Feature      | Purpose                                        |\n| ------------ | ---------------------------------------------- |\n| `TezX`       | Main application & runtime-agnostic router     |\n| `use()`      | Register global middleware                     |\n| `when()`     | Register dynamic routes (including ALL-method) |\n| `notFound()` | Custom 404 handler                             |\n| `onError()`  | Global error handling                          |\n| `serve()`    | Entry point for Deno, Bun, or Node.js servers  |\n\n---\n"
    },
    {
      "id": 9,
      "path": "api/tezx/serve",
      "name": "Serve",
      "folder": "API/TezX",
      "content": "# 📡 `app.serve()` — TezX Runtime-Agnostic Request Handler\n\nThe `app.serve()` method is the **core universal handler** for processing HTTP requests in **TezX**. It adapts itself to different JavaScript runtimes by internally delegating requests to the appropriate logic.\n\n---\n\n## 🧠 What It Does\n\n* Accepts a native `Request` object (based on the Fetch API).\n* Optionally accepts runtime-specific arguments like `connInfo` (Deno), `req, res, server` (Node.js), or `server` (Bun).\n* Processes the request using your defined middleware and routes.\n* Returns a `Response` object.\n\nThis method allows you to **integrate TezX into any runtime** with **zero extra configuration**.\n\n---\n\n## ⚙️ How It Works Internally\n\n```ts\npublic async serve(req: Request, ...args: any[]): Promise<Response>\n```\n\n* `req`: A standard `Request` object.\n* `args`: Optional values like response objects, connections, or server instances.\n\n  * Parses the request.\n  * Creates a context.\n  * Executes middleware chain.\n  * Calls route handlers.\n  * Returns a finalized `Response`.\n\n---\n\n## 🖼️ Flow Overview\n\n```mermaid\nsequenceDiagram\n    participant Client as Client (Browser/HTTP)\n    participant TezX as TezX App\n    participant serve as app.serve()\n    participant handle as #handleRequest()\n    participant chain as #chain()\n    participant Middleware as Middlewares[]\n    participant Handler as Handlers[]\n\n    Client->>serve: HTTP Request\n    serve->>handle: Call #handleRequest(req, method, args)\n\n    handle->>handle: Validate Request (instanceof Request)\n    handle->>handle: Extract pathname & method\n    handle->>handle: Create Context(ctx)\n\n    alt Static file exists\n        handle-->>Client: Return static file Response\n    else Route found\n        handle->>handle: Search route in router\n        alt Only 1 handler, no middleware\n            handle->>Handler: Call handler(ctx)\n            Handler-->>handle: Response/ctx.body\n            handle-->>Client: Final Response\n        else Middleware/Handlers chain\n            handle->>chain: Call #chain(ctx, mLen, middlewares, hLen, handlers)\n            loop Dispatch(i)\n                chain->>Middleware: fn(ctx, next)\n                Middleware-->>chain: res / next()\n            end\n            chain->>Handler: fn(ctx, next)\n            Handler-->>chain: Response / ctx.body\n            chain-->>handle: Final ctx.res\n            handle-->>Client: Final Response\n        end\n    else No route match\n        handle-->>Client: 404 Not Found\n    end\n\n    handle->>handle: Catch errors\n    handle-->>Client: Error response (via #errorHandler)\n```\n\n---\n\n## ✅ Usage Examples\n\n### 🔷 Bun\n\n```ts\nimport {wsHandlers} from \"tezx/bun\";\n// Simple usage\napp.serve(req, server);\n\n// Full Bun server with WebSocket support\nBun.serve({\n  port: 3000,\n  fetch: app.serve,\n  websocket: wsHandlers({})\n});\n```\n\n---\n\n### 🟨 Deno\n\n```ts\n// Basic serve function\nimport { serve } from \"https://deno.land/std/http/server.ts\";\n\nserve((req, connInfo) => app.serve(req, connInfo));\n\n// Or using modern API\nDeno.serve({ port: 8080 }, app.serve);\n```\n\n---\n\n### 🟦 Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { mountTezXOnNode,toWebRequest } from \"tezx/node\";\n\n// Simple server mounting\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n\n// OR: manual conversion if needed\nconst response = await app.serve(toWebRequest(req), req, res, server);\n```\n\n---\n\n## 🔄 When to Use `app.serve()`\n\n| Scenario                       | Use `app.serve()`? |\n| ------------------------------ | ------------------ |\n| Bun’s `Bun.serve`              | ✅ Yes              |\n| Deno's `serve` or `Deno.serve` | ✅ Yes              |\n| Node's `http.createServer`     | ✅ Yes              |\n| Edge runtimes (like Vercel)    | ✅ Yes              |\n| Cloudflare Workers             | ✅ Yes              |\n\n---\n\n## 📝 Example\n\n```ts\nconst res = await app.serve(\n  new Request(\"http://localhost/hello\", { method: \"GET\" })\n);\nconsole.log(await res.text()); // → \"Hello TezX!\" (if route is defined)\n```\n\n---\n\n## 🛠 Tip for TypeScript Users\n\nSince `...args: any[]` can vary between environments, you can narrow down types like:\n\n```ts\n// For Deno\napp.serve(req, connInfo as Deno.ServeHandlerInfo);\n// For Node\napp.serve(req, res, server);\n```\n\n---\n\n## 🧪 Debugging Middleware Chain\n\nWant to trace how `app.serve()` is executing?\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Incoming request:\", ctx.method, ctx.url);\n  await next();\n});\n```\n\n---\n\n## 🔚 Summary\n\n* ✅ Cross-runtime request handler\n* 📦 Accepts Fetch API-compatible `Request`\n* 🔁 Handles middleware, routes, and returns `Response`\n* 💡 Plug-and-play with Node, Deno, and Bun\n\n> `app.serve()` is the glue between the **runtime** and your **application logic**.\n\n---\n"
    },
    {
      "id": 10,
      "path": "api/tezx/tezx-error",
      "name": "TezX Error",
      "folder": "API/TezX",
      "content": "# 🚨 TezXError\n\n`TezXError` is the **standard error type** used throughout **Tezx**.\nIt extends the native `Error` object and adds:\n\n* An **HTTP status code**\n* Optional **structured details payload** (metadata, validation issues, etc.)\n* Helper **static factories** for common HTTP errors\n\nThis makes it easy to throw consistent, structured errors in middleware, services, and route handlers.\n\n---\n\n## 📦 Import\n\n```ts\nimport { TezXError } from \"tezx\";\n```\n\n---\n\n## 🛠️ Constructor\n\n```ts\nnew TezXError(message: string, statusCode?: number, details?: any)\n```\n\n| Parameter    | Type     | Default     | Description                                      |\n| ------------ | -------- | ----------- | ------------------------------------------------ |\n| `message`    | `string` | —           | Human-readable error message.                    |\n| `statusCode` | `number` | `500`       | HTTP status code.                                |\n| `details`    | `any`    | `undefined` | Extra payload (e.g. validation errors, context). |\n\n---\n\n## ⚡ Static Helpers\n\nInstead of calling `new TezXError(...)` directly, you can use the built-in static methods for common error types:\n\n```ts\nTezXError.badRequest(message?, details?)\nTezXError.unauthorized(message?, details?)\nTezXError.forbidden(message?, details?)\nTezXError.notFound(message?, details?)\nTezXError.conflict(message?, details?)\nTezXError.internal(message?, details?)\n```\n\n### Example\n\n```ts\nthrow TezXError.notFound(\"User not found\", { userId: 42 });\n```\n\n---\n\n## 🔄 JSON Serialization\n\nEvery `TezXError` can be safely serialized to JSON using `.toJSON()` — useful for HTTP responses or logging.\n\n```ts\nconst err = TezXError.badRequest(\"Invalid email\", { field: \"email\" });\n\nconsole.log(err.toJSON());\n```\n\n#### Output\n\n```json\n{\n  \"error\": true,\n  \"message\": \"Invalid email\",\n  \"statusCode\": 400,\n  \"details\": { \"field\": \"email\" }\n}\n```\n\n---\n\n## ✅ Usage Examples\n\n### 1. Throw a Standard Error\n\n```ts\napp.get(\"/user/:id\", async (ctx) => {\n  const user = await db.findUser(ctx.params.id);\n  if (!user) throw TezXError.notFound(\"User not found\");\n  return ctx.json(user);\n});\n```\n\n---\n\n### 2. Custom Status Error\n\n```ts\nthrow new TezXError(\"Bad Gateway\", 502);\n```\n\n---\n\n### 3. Attach Validation Details\n\n```ts\nif (!email.includes(\"@\")) {\n  throw TezXError.badRequest(\"Invalid email format\", { field: \"email\" });\n}\n```\n\n---\n\n## 🧑‍💻 Developer Notes\n\n* Always throw `TezXError` instead of plain `Error` when working inside Tezx routes/middleware.\n* `details` is optional but very useful for structured API responses (e.g., validation errors, resource IDs).\n* Default fallback is `500 Internal Server Error`.\n\n---\n"
    },
    {
      "id": 11,
      "path": "api/context/context",
      "name": "Context",
      "folder": "API/Context",
      "content": "# Context Wrapper\n\nThe `Context` class is the central abstraction for handling requests and responses in TezX. It wraps a request, manages headers, status codes, body, and provides helper methods for sending different types of responses including text, HTML, JSON, XML, files, and redirects.\n\n## Context lifecycle\n\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Runtime\n    participant TezXApp as TezX.app\n    participant Context as Context\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n\n    Client->>Runtime: HTTP request\n    Runtime->>TezXApp: app.serve(req, ...)\n    TezXApp->>Context: new Context(req, pathname, method, env, args)\n    TezXApp->>Middleware: run middlewares with ctx\n    Middleware-->>TezXApp: control returns\n    TezXApp->>Handler: call route handler(ctx)\n    Handler-->>TezXApp: sets ctx.body / returns value\n    TezXApp->>Runtime: finalize Response from ctx (headers, status, body)\n    Runtime-->>Client: HTTP response sent\n\n```\n\n---\n\n## **1. Properties**\n\n### 1. **`url: string`**\n\n```ts\nconsole.log(ctx.url); // \"https://example.com/listings?page=2\"\n// Purpose: Access the full request URL including query string\n```\n\n### 2. **`pathname: string`**\n\n```ts\nconsole.log(ctx.pathname); // \"/listings\"\n// Purpose: Get the pathname part of the URL without query parameters\n```\n\n### 3. **`method: string`**\n\n```ts\nif (ctx.method === \"POST\") { /* handle post */ }\n// Purpose: Check the HTTP method of the incoming request\n```\n\n### 4. **`env: T & Record<string, any>`**\n\n```ts\nctx.env.db = dbClient;\n// Purpose: Store and access environment-specific variables, like database clients\n```\n\n### 5. **`req: TezXRequest<Path>`**\n\n```ts\nconst body = await ctx.req.json();\n// Purpose: Access and parse the request body as JSON\n```\n\n### 6. **`headers: Headers`**\n\n```ts\nctx.headers.set(\"X-Custom\", \"value\");\nconsole.log(ctx.headers.get(\"content-type\"));\n// Purpose: Get or set headers for the request/response\n```\n\n### 7. **`body: any`**\n\n```ts\nctx.body = \"<h1>Hello</h1>\"; // Response body (get/set)\nconsole.log(ctx.body);\n// Purpose: Directly set or read the response body\n```\n\n### 8. **`status(code: number): this`**\n\n```ts\nctx.status(404).text(\"Not Found\"); \n// Purpose: Set the HTTP status code and chain response methods\n```\n\n### 9. **`setHeader(key, value, options?)`**\n\n```ts\nctx.setHeader(\"X-Powered-By\", \"tezx\");\nctx.setHeader(\"Set-Cookie\", \"id=1; Path=/; HttpOnly\", { append: true });\nctx.setHeader(\"Set-Cookie\", \"token=abcd; Path=/; HttpOnly\", { append: true });\nreturn ctx.text(\"headers set\");\n// Purpose: Add or append a single header to the response\n```\n\n---\n\n## **2. Methods for Responses**\n\n```ts\n// Plain text\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX 🚀\"));\n// Purpose: Send a simple text response\n\n// JSON API\napp.get(\"/status\", (ctx) => ctx.json({ ok: true, uptime: process.uptime() }));\n// Purpose: Send a JSON response, useful for APIs\n\n// HTML page\napp.get(\"/hello\", (ctx) => ctx.html`<h1>Hello, ${ctx.env.username ?? \"Guest\"}!</h1>`);\n// Purpose: Send HTML content with template literals\n\n// XML response\napp.get(\"/feed\", (ctx) => ctx.xml`<rss><channel><title>TezX Feed</title></channel></rss>`);\n// Purpose: Send XML responses for feeds or APIs\n```\n\n---\n\n## **2. Dynamic Params & Queries**\n\n```ts\n// Route parameter\napp.get(\"/user/:id\", (ctx) => {\n  return ctx.json({ userId: ctx.req.params.id });\n});\n// Purpose: Extract dynamic route parameters\n\n// Query string\napp.get(\"/search\", (ctx) => {\n  return ctx.json({ q: ctx.req.query.q || \"nothing\" });\n});\n// Purpose: Access query parameters from the URL\n```\n\n---\n\n## **3. Form Data / File Upload**\n\n```ts\n// Handle multipart form upload\napp.post(\"/upload\", async (ctx) => {\n  const form = await ctx.req.formData();\n  const file = form.get(\"file\"); // File | null\n  const username = form.get(\"username\");\n  \n  return ctx.json({ uploadedBy: username, hasFile: !!file });\n});\n// Purpose: Parse form data including file uploads\n```\n\n**HTML for testing:**\n\n```html\n<form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"username\" placeholder=\"Your Name\" />\n  <input type=\"file\" name=\"file\" />\n  <button type=\"submit\">Upload</button>\n</form>\n```\n\n---\n\n## **4. Headers & Status**\n\n```ts\napp.get(\"/secure\", (ctx) => {\n  ctx.status(401)\n     .setHeader(\"WWW-Authenticate\", \"Bearer\")\n     .json({ error: \"Unauthorized\" });\n});\n// Purpose: Send a response with custom status and header\n\n// Multiple cookies\napp.get(\"/cookies\", (ctx) => {\n  ctx.setHeader(\"Set-Cookie\", \"id=1; Path=/; HttpOnly\", { append: true });\n  ctx.setHeader(\"Set-Cookie\", \"token=abc; Path=/; HttpOnly\", { append: true });\n  return ctx.text(\"Cookies set\");\n});\n// Purpose: Set multiple cookies in a response\n```\n\n---\n\n## **5. Redirects**\n\n```ts\napp.get(\"/old\", (ctx) => ctx.redirect(\"/new\"));          \n// Purpose: Temporary redirect (HTTP 302)\n\napp.get(\"/permanent\", (ctx) => ctx.redirect(\"/new\", 301)); \n// Purpose: Permanent redirect (HTTP 301)\n```\n\n---\n\n## **6. File Responses**\n\n```ts\n// Download as attachment\napp.get(\"/download\", (ctx) => ctx.download(\"./files/report.pdf\", \"report-2025.pdf\"));\n// Purpose: Force file download with a custom filename\n\n// Serve file inline (streaming)\napp.get(\"/video\", (ctx) => ctx.sendFile(\"./media/video.mp4\"));\n// Purpose: Stream a file for inline viewing\n\n// Serve with custom download filename\napp.get(\"/image\", (ctx) => ctx.sendFile(\"./media/pic.png\", { filename: \"photo.png\" }));\n// Purpose: Serve a file while specifying a download filename\n```\n\n---\n\n## **7. Chainable Response**\n\n```ts\napp.post(\"/create\", async (ctx) => {\n  const body = await ctx.req.json();\n  return ctx\n    .status(201)\n    .setHeader(\"x-resource-id\", \"42\")\n    .json({ message: \"Created\", data: body });\n});\n// Purpose: Demonstrate chaining of status, headers, and JSON response\n```\n\n---\n"
    },
    {
      "id": 12,
      "path": "api/context/context-propagation",
      "name": "Context Propagation",
      "folder": "API/Context",
      "content": "\n# 🧩 Context Propagation in TezX\n\nContext propagation allows **type-safe, request-scoped state sharing** across middleware and route handlers. Built on TypeScript, it enables:\n\n* Fine-grained control over request data\n* Modular architecture\n* Developer productivity with strict typing and tooling support\n\n---\n\n## **1. Conceptual Overview**\n\n1. Type-safe context shape\n2. Scoped to individual requests\n3. Mutable across middleware\n4. Extended through type composition\n\n---\n\n## **2. Defining a Typed Context**\n\nCreate a strongly-typed interface to define your request context structure:\n\n```ts\ninterface CustomContext {\n  user?: { id: number; email: string }; // Optional user data\n  requestId: string;                    // Required unique identifier per request\n}\n```\n\n---\n\n## **3. Typed Router / App Instantiation**\n\nPass the context type to Router or TezX for strict type enforcement:\n\n```ts\nimport { TezX } from \"tezx\";\n\nconst app = new TezX<CustomContext>();\n```\n\n---\n\n## **4. Injecting Data via Middleware**\n\nUse middleware to enrich the context during the request lifecycle:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.user = await authenticate(ctx.req);\n  return next();\n});\n\napp.use((ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  return next();\n});\n```\n\n---\n\n## **5. Typed Context Access in Handlers**\n\nAccess your context properties safely with full TypeScript support:\n\n```ts\napp.get(\"/me\", (ctx) => {\n  return ctx.json({\n    requestId: ctx.requestId,\n    email: ctx.user?.email ?? \"Anonymous\",\n  });\n});\n```\n\n---\n\n## **6. Context Composition**\n\nScale context by composing smaller domain-specific types:\n\n```ts\ninterface AuthContext {\n  user: { id: number; email: string };\n  session: { token: string; expires: Date };\n}\n\ninterface MetricsContext {\n  logger: Logger;\n  startTime: number;\n}\n\ntype AppContext = AuthContext & MetricsContext;\n\nconst app = new TezX<AppContext>();\n```\n\n---\n\n## **7. Validation Middleware**\n\nEnsure critical fields are present at runtime:\n\n```ts\napp.use((ctx, next) => {\n  if (!ctx.requestId) throw new Error(\"Missing request ID\");\n  return next();\n});\n```\n\n---\n\n## **8. Type Safety Guards**\n\nTypeScript prevents invalid usage:\n\n```ts\n// ❌ Property 'newProp' does not exist\nctx.newProp = \"value\";\n\n// ❌ Type mismatch\nctx.requestId = 123; // should be a string\n```\n\n---\n\n## **9. Optional Properties Handling**\n\nUse safe access patterns for optional context data:\n\n```ts\napp.get(\"/dashboard\", (ctx) => {\n  if (!ctx.user) return ctx.status(401).json({ error: \"Unauthorized\" });\n\n  return ctx.json({ email: ctx.user.email });\n});\n```\n\n---\n\n## **10. Best Practices**\n\n1. **Order Matters**\n   Set required context early and validate immediately:\n\n   ```ts\n   app.use((ctx, next) => {\n     ctx.requestId = crypto.randomUUID();\n     return next();\n   });\n\n   app.use((ctx, next) => {\n     if (!ctx.requestId) throw new Error(\"Missing ID\");\n     return next();\n   });\n   ```\n\n2. **Immutability**\n   Prefer immutable patterns when modifying nested objects:\n\n   ```ts\n   ctx.user = { ...ctx.user, email: \"updated@example.com\" };\n   ```\n\n3. **Testing with Mock Context**\n   Test logic in isolation with mock context:\n\n   ```ts\n   const mockCtx: CustomContext = {\n     requestId: \"req-test-001\",\n     user: { id: 1, email: \"test@example.com\" },\n   };\n\n   const response = await handler(mockCtx);\n   ```\n\n---\n\n## **11. Context Lifecycle Overview**\n\n```mermaid\nsequenceDiagram\n  Client->>Server: Incoming Request\n  Server->>Middleware A: Inject requestId\n  Middleware A->>Middleware B: Attach user\n  Middleware B->>Handler: Execute route\n  Handler->>Server: Prepare response\n  Server->>Client: Send response\n```\n\n---\n\n## **12. Why Context Propagation?**\n\n| Benefit            | Description                                                            |\n| ------------------ | ---------------------------------------------------------------------- |\n| 🔐 Type Safety     | Compile-time validation prevents access errors and invalid mutations   |\n| 🧩 Modularity      | Enables context slicing and extension across layers                    |\n| ⚙️ Maintainability | Clear structure for evolving app concerns like auth, logging, sessions |\n| 🚀 Scalability     | Composable and predictable patterns for large applications             |\n\n---\n"
    },
    {
      "id": 13,
      "path": "api/middleware/merging-middlewares",
      "name": "Merging Middlewares",
      "folder": "API/Middleware",
      "content": "# ✅ Middleware Merging Strategy\n\nThis outlines how two router trees with nested middlewares are **intelligently merged** to preserve execution order and structure.\n\n---\n\n## 🔹 **Before Merging**\n\n### 🧭 **Root Router Tree (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n└── \"/test\"                             # path\n    ├── middlewares: [m1]              # existing middleware\n    └── children:\n        └── \"/test/1\"\n            ├── middlewares: [m2]\n```\n\n* `/test`: Contains middleware `[m1]`.\n* `/test/1`: A subroute with its own middleware `[m2]`.\n\n---\n\n## 🔹 **New Router Tree to Merge (`RouterMiddlewares`)**\n\n### 🌱 **Incoming Subrouter**\n\n```plaintext\nRouterMiddlewares\n└── \"/test\"\n    ├── middlewares: [m3]              # additional middleware to merge\n    └── children:\n        └── \"/test/2\"\n            ├── middlewares: [m4]\n```\n\n* `/test`: New middleware `[m3]` for same path.\n* `/test/2`: New child route under `/test`.\n\n---\n\n## 🔁 **After Merging (`RootMiddlewares`)**\n\n```plaintext\nRootMiddlewares\n└── \"/test\"\n    ├── middlewares: [m1, m3]          # merged middlewares\n    └── children:\n        ├── \"/test/1\"\n        │   ├── middlewares: [m2]\n        └── \"/test/2\"\n            ├── middlewares: [m4]      # newly added\n```\n\n* Middleware arrays are **merged**: `[m1] + [m3] → [m1, m3]`.\n* All existing children remain untouched (`/test/1`).\n* New children are **appended** (`/test/2`).\n\n---\n\n## 🧠 **Mermaid Diagram: Middleware Merge Flow**\n\n```mermaid\nflowchart TD\n    A[\"/test (m1)\"] --> B[\"/test/1 (m2)\"]\n    A --> C[\"/test/2 (m4)\"]\n    A --- D[\"Merged Middlewares: m1 + m3\"]\n```\n\n* Shows how `/test` merges middlewares (`m1 + m3`) and retains all children.\n\n---\n\n## 🔧 **`when` API**\n\n```ts\n/**\n * Registers a route or middleware stack for a specific HTTP method.\n *\n * @param method - HTTP method (e.g., \"GET\", \"POST\", \"ALL\" for middleware).\n * @param path - Path to match (e.g., \"/api\", \"/test\").\n * @param handlers - Array of middleware or route handler functions.\n */\nwhen(method: HttpMethod | HttpMethod[], path: string, handlers: Handler[]): void;\n```\n\n* `method = \"ALL\"` → **middleware applied to all HTTP methods**.\n* Used internally when adding reusable or nested routers.\n\n---\n\n## 🧱 **Automatic Middleware Registration Logic**\n\nWhen merging routes via a registry:\n\n```ts\nif (middlewares?.length) {\n  this.#addRoute(\"ALL\", path, middlewares);\n}\n```\n\n* Ensures **all middleware layers** from incoming routers are preserved.\n* Middleware at the same path is **concatenated, not replaced**.\n\n---\n"
    },
    {
      "id": 14,
      "path": "api/middleware/middleware",
      "name": "Middleware",
      "folder": "API/Middleware",
      "content": "# 🧩 `use()` – Register Middlewares or Routers\n\nThe `use()` method in `TezX.Router` is a powerful, flexible API for registering middlewares and sub-routers — either globally or scoped to a specific path.\n\n## Sequence Diagram – Middleware / Router Chain\n\n```mermaid\nsequenceDiagram\n    participant App as TezX.App\n    participant Router as Router\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n    participant SubRouter as Sub-Router\n\n    App->>Router: use(path?, middlewares?, callback?/subRouter?)\n    Router->>Middleware: register middlewares\n    Router->>SubRouter: mount sub-router (if any)\n    \n    Note over Middleware, Handler: Marge Router\n\n    Client->>App: HTTP Request\n    App->>Router: match path + method\n    Router->>Middleware: execute each middleware(ctx, next)\n    Middleware-->>Router: await next()\n    Router->>Handler: call route handler(ctx)\n    Handler-->>Router: sets ctx.body / returns Response\n    Router-->>App: finalized response\n    App-->>Client: send Response\n```\n\n---\n\n## 📚 **Function Signature**\n\n```ts\nuse(...args: any[]): this;\n```\n\nSupports overloads like:\n\n```ts\n// Global middleware\nuse(middleware);\nuse([middleware1, middleware2]);\n\n// Scoped middleware\nuse(\"/path\", middleware);\nuse(\"/path\", [middleware1, middleware2]);\n\n// Middleware + handler or router\nuse(\"/path\", middleware, callback);\nuse(\"/path\", [middleware1], subRouter);\nuse(middleware, callback);\nuse([middleware], subRouter);\n```\n\n---\n\n## 📦 **Middleware Type**\n\n```ts\ntype Middleware<T = {}, Path extends string = any> = (\n  ctx: Ctx<T, Path>,\n  next: () => Promise<void>\n) => Response | Promise<Response | void>;\n```\n\n* Receives a request context (`ctx`) and a `next()` callback.\n* Can **modify `ctx`**, **short-circuit**, or **continue** the chain with `await next()`.\n\n---\n\n## 🧪 **Usage Examples**\n\n### 1. **Global Middleware**\n\n```ts\napp.use(async (ctx, next) => {\n  console.log(\"Request started\");\n  await next();\n  console.log(\"Request ended\");\n});\n```\n\n### 2. **Multiple Global Middlewares**\n\n```ts\napp.use([\n  loggerMiddleware,\n  requestIDMiddleware,\n  timingMiddleware\n]);\n```\n\n### 3. **Scoped Middleware by Path**\n\n```ts\napp.use(\"/admin/:section?\", async (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    return ctx.status(403).text(\"Forbidden\");\n  }\n  return next();\n});\n```\n\n---\n\n### 4. **Scoped Middleware with Sub-Router**\n\n```ts\nconst authRouter = new Router();\n\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login page\"));\n\napp.use(\"/auth/:provider?\", authMiddleware, authRouter);\n```\n\n---\n\n## 🧠 **How It Works Internally**\n\nThe `use()` function:\n\n* Normalizes arguments into `path`, `middlewares`, and optional `router`.\n* Registers middlewares using:\n\n```ts\nthis.#addRoute(\"ALL\", path, middlewares);\n```\n\n* If a `Router` is passed, it’s mounted using:\n\n```ts\nthis.addRouter(path, router);\n```\n\n* Middleware paths support **all route param syntaxes** (`:id`, `:id?`, `*wildcard`).\n\n---\n\n## 🔁 **Middleware Chaining**\n\nAll middleware functions follow a **chainable model** via `next()`:\n\n```ts\napp.use(async (ctx, next) => {\n  ctx.startTime = Date.now();\n  await next();\n  const ms = Date.now() - ctx.startTime;\n  console.log(`${ctx.method} ${ctx.pathname} - ${ms}ms`);\n});\n```\n\n* Each middleware may perform actions **before or after** the next one.\n* If `next()` is not called, the chain stops.\n\n---\n\n## 🧱 **Router Composition**\n\n```ts\nconst v1 = new Router();\nv1.use(\"/users\", authMiddleware, userRouter);\n\nconst v2 = new Router();\nv2.use(\"/products\", productRouter);\n\napp.use(\"/api\", [loggerMiddleware], v1);\napp.use(\"/api\", v2);\n```\n\n---\n\n## 🛡️ **Best Practices**\n\n| Tip                           | Description                                        |\n| ----------------------------- | -------------------------------------------------- |\n| ✅ Use scoped middleware       | For route-specific logic like authentication       |\n| ✅ Keep global middleware pure | Logging, CORS, rate limiting, etc.                 |\n| ✅ Chain with `next()`         | Enables layered composition                        |\n| ✅ Compose routers             | Modularize APIs or feature groups                  |\n| ✅ Handle errors               | Wrap logic in try/catch or global error middleware |\n\n---\n"
    },
    {
      "id": 15,
      "path": "api/router/router",
      "name": "Router",
      "folder": "API/Router",
      "content": "# 🚀 TezX Router\n\n**TezX Router** is the core of the **tezx** web framework. It offers a **high-performance, flexible, and modern** way to handle:\n\n* HTTP routing\n* Middleware chaining\n* Static assets\n* Sub-routers\n* Server-Sent Events (SSE)\n\nWhether you’re building small APIs or large modular applications, TezX Router provides the structure and tools you need.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Client as HTTP Client\n    participant ParentRouter as Parent Router<T>\n    participant SubRouter as Sub-Router<T>\n    participant Static as Static File Handler\n    participant Middleware as Middleware Chain\n    participant Handler as Route Handler\n\n    note over ParentRouter, SubRouter: Step 0: Merge sub-router routes into parent\n    ParentRouter->>SubRouter: Read routes & staticFile map\n    SubRouter-->>ParentRouter: Copy routes & staticFile entries\n\n    Client->>ParentRouter: HTTP Request (method + path)\n    \n    alt Static file match\n        ParentRouter->>Static: check staticFile map for \"METHOD path\"\n        Static-->>ParentRouter: return file response\n        ParentRouter-->>Client: send static response\n    else Route match\n        ParentRouter->>Middleware: execute global middlewares(ctx, next)\n        Middleware-->>ParentRouter: await next()\n        \n        alt Sub-router route (merged into parent)\n            ParentRouter->>Handler: execute sub-router's handler(ctx)\n            Handler-->>ParentRouter: return ctx.body / Response\n        else Direct route\n            ParentRouter->>Handler: execute parent route handler(ctx)\n            Handler-->>ParentRouter: return ctx.body / Response\n        end\n\n        ParentRouter-->>Client: send response\n    end\n```\n\n---\n\n## 1. Installation & Initialization\n\n```ts\nimport { Router } from \"tezx\";\n\n// Create a new Router instance\nconst app = new Router({\n  basePath: \"/\",            // Base path for all routes (default: \"/\")\n  env: { NODE_ENV: \"prod\" } // Environment variables accessible in middleware\n});\n```\n\n### Router Configuration Options\n\n```ts\nexport type RouterConfig = {\n  /** Custom route registry used internally */\n  routeRegistry?: RouteRegistry;\n\n  /** Optional segments handling (ignored by RadixRouter internally) */\n  optionalSegments?: {\n    expand?: boolean;           // Always true internally\n    maxExpansion?: number;      // Maximum number of optional segment permutations (default: 6)\n  };\n\n  /** Environment variables for this router instance */\n  env?: Record<string, string | number>;\n\n  /** Base path prefix for all routes (e.g., \"/api/v1\") */\n  basePath?: string;\n};\n```\n\n**Notes:**\n\n* Optional segments (`?`) expand internally into all permutations.\n* Use `basePath` to mount routers under a sub-path.\n\n---\n\n## 2. Core Concepts\n\nTezX Router revolves around a few key ideas:\n\n1. **Route registration** — Define endpoints with HTTP verbs (`GET`, `POST`, etc.).\n2. **Middleware chaining** — Reusable pre-processing or validation logic.\n3. **Route grouping** — Organize routes under common prefixes.\n4. **Sub-routers** — Modularize large APIs by mounting routers on paths.\n5. **Static file serving** — Serve assets like images, CSS, and JS.\n\n---\n\n## 3. Defining Routes\n\n### 3.1 Basic Route\n\n```ts\napp.get(\"/hello\", (ctx) => {\n  ctx.body = \"Hello from TezX!\";\n});\n```\n\n* `ctx` contains request info, parameters, and response methods.\n* Set responses using `ctx.body`, `ctx.text()`, or `ctx.json()`.\n\n---\n\n### 3.2 Route with Middleware\n\n```ts\nconst auth = async (ctx, next) => {\n  if (!ctx.user) {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  await next();\n};\n\napp.get(\"/profile\", auth, (ctx) => {\n  return ctx.json({ user: ctx.user });\n});\n```\n\n* Middleware is a function `(ctx, next)` that can halt or continue the request chain.\n* Call `await next()` to proceed to the next middleware or handler.\n\n---\n\n### 3.3 Multiple Middlewares\n\n```ts\nconst log = (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  return next();\n};\n\nconst adminOnly = (ctx, next) => {\n  if (!ctx.user?.isAdmin) {\n    ctx.setStatus = 403;\n    return ctx.text(\"Forbidden\");\n  }\n  return next();\n};\n\napp.get(\"/admin/dashboard\", [auth, log, adminOnly], (ctx) => {\n  return { body: \"Admin Dashboard\" };\n});\n```\n\n* Middleware can be applied as an array for **chained execution**.\n* Allows reusable, composable logic like logging, authentication, or authorization.\n\n---\n\n## 4. HTTP Methods\n\nTezX Router supports standard HTTP verbs:\n\n```ts\napp.get(\"/path\", ...middlewares, handler)\napp.post(\"/path\", ...middlewares, handler)\napp.put(\"/path\", ...middlewares, handler)\napp.patch(\"/path\", ...middlewares, handler)\napp.delete(\"/path\", ...middlewares, handler)\napp.options(\"/path\", ...middlewares, handler)\napp.all(\"/path\", ...middlewares, handler);\n```\n\nExample:\n\n```ts\napp.post(\"/submit\", (ctx) => {\n  const data = ctx.request.body;\n  return ctx.json({ received: data });\n});\n```\n\n```ts\napp.all(\"/path\", ...middlewares, handler);\n```\n\n**Explanation:**\n\n* `app.all()` is primarily used to **register middleware** that should run for **all HTTP methods** (GET, POST, PUT, DELETE, etc.) for a given path.\n* Middleware functions in `...middlewares` are executed **in order** before the final `handler`.\n* **Optional route parameters are not supported** in `app.all()` — the path must be **explicit and exact**.\n* Use it to apply global or reusable middleware logic on a specific path.\n\n**Example:**\n\n```ts\n// Middleware that runs for all methods on \"/dashboard\"\napp.all(\"/dashboard\", authMiddleware, logMiddleware, (ctx) => {\n  return ctx.text(\"Dashboard accessed!\");\n});\n```\n\n> **Note:** `.all()` is mainly used for middleware or global handlers, not optional parameters.\n\n---\n\n## 5. Serving Static Files\n\n```ts\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n\napp.static(serveStatic(\"/assets\", \"./public/assets\"));  // Serve under route\napp.static(serveStatic(\"./public\"));                     // Serve at root\n```\n\n* Use for images, CSS, JS, or any public assets.\n\n---\n\n## 6. Grouping Routes\n\n```ts\napp.group(\"/api/v1\", (router) => {\n  router.get(\"/users\", (ctx) => { /*...*/ });\n  router.post(\"/users\", (ctx) => { /*...*/ });\n});\n```\n\n* Groups create **scoped sub-routers** for modular organization.\n* You can attach middlewares to the group.\n\n---\n\n## 7. Mounting Sub-Routers\n\n```ts\nconst adminRouter = new Router();\nadminRouter.use(auth); // Auth applies to all admin routes\n\nadminRouter.get(\"/dashboard\", (ctx) => ctx.text(\"Welcome, admin!\"));\n\napp.addRouter(\"/admin\", adminRouter);\n```\n\n* Sub-routers can have their own middlewares, groups, and routes.\n* `addRouter()` mounts the sub-router at a base path.\n\n---\n\n## 8. Middleware Usage Tips\n\n* Middleware signature: `async (ctx, next) => { ... }`\n* Always call `await next()` unless you want to **short-circuit**.\n* Attach data to `ctx` (e.g., `ctx.user = {...}`).\n* Arrays of middlewares can be applied to routes, groups, or routers.\n\n---\n\n## 9. Full Example Mini App\n\n```ts\nimport { Router } from \"tezx\";\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n\nconst app = new Router();\n\nconst logger = async (ctx, next) => {\n  console.log(`${ctx.method} ${ctx.pathname}`);\n  await next();\n};\n\nconst auth = async (ctx, next) => {\n  const token = ctx.headers[\"authorization\"];\n  if (token !== \"secret-token\") {\n    ctx.setStatus = 401;\n    return ctx.text(\"Unauthorized\");\n  }\n  ctx.user = { name: \"Alice\" };\n  await next();\n};\n\napp.use(logger);\n\napp.get(\"/\", (ctx) => ctx.text(\"Welcome to TezX Router!\"));\n\napp.group(\"/api\", (api) => {\n  api.get(\"/public\", (ctx) => ctx.text(\"Public API data\"));\n  api.get(\"/private\", auth, (ctx) =>\n    ctx.text(`Hello ${ctx.user.name}, this is private data.`)\n  );\n});\n\napp.static(serveStatic(\"/static\", \"./public\"));\n\nexport default app;\n```\n\n---\n\n## Troubleshooting & Gotchas\n\n* **Optional param expansion:** RadixRouter internally expands optional segments. Overuse can create many permutations; tune `maxExpansion`.\n* **Order matters:** Middleware order (global → group → route) determines execution order. Register global middleware early.\n* **Group parameter collisions:** Avoid consecutive unnamed optional params — prefer a fixed segment between them.\n"
    },
    {
      "id": 16,
      "path": "api/router/router-merging",
      "name": "Router Merging",
      "folder": "API/Router",
      "content": "# 🔀 **TezX Router Merging**\n\n## 📘 Overview\n\nTezX allows merging multiple routers into a **parent app**, enabling modular route management. This ensures:\n\n* **Non-destructive merges** — existing routes remain intact.\n* **Hierarchical route structure** — sub-routers can maintain their own nested routes.\n* **Safe middleware scoping** — each router can define its own middlewares.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant ParentRouter\n    participant SubRouter\n    participant RouteRegistry\n\n    Note over ParentRouter, SubRouter: Merge process begins\n    ParentRouter->>SubRouter: addRouter(\"/prefix\", subRouter)\n    SubRouter->>RouteRegistry: Iterate all sub-router routes\n    RouteRegistry-->>ParentRouter: Return each route (method, pattern, handlers)\n    ParentRouter->>RouteRegistry: Add each route to parent registry\n    Note over ParentRouter: ParentRouter now contains:\\n- its original routes\\n- all sub-router routes\n```\n\n---\n\n## 🧭 Terminology\n\n| Term              | Meaning                                                                   |\n| ----------------- | ------------------------------------------------------------------------- |\n| **Parent Router** | The main `TezX` instance or a Router that aggregates multiple sub-routers |\n| **Sub-Router**    | A router that contains its own routes & middleware                        |\n| **Merged Router** | The result of merging sub-routers into the parent router                  |\n\n---\n\n## 📂 Pre-Merge Example\n\nParent router before adding any sub-router:\n\n```bash\nParent Router:\n├── /test\n│   ├── GET → handler1\n│   └── /1\n│       ├── GET → handler2\n```\n\n---\n\n## ➕ Adding a Sub-Router\n\nSub-router structure:\n\n```bash\nSub-Router:\n├── /products\n│   └── /2\n│       ├── GET → handler3\n```\n\n---\n\n## ✅ After Merge\n\nMerged router structure:\n\n```bash\nMerged Router:\n├── /test\n│   ├── GET → handler1\n│   └── /1\n│       ├── GET → handler2\n├── /products\n│   └── /2\n│       ├── GET → handler3\n```\n\n> All routes remain intact and merge **non-destructively**.\n\n---\n\n## 🧪 Code Example\n\n```ts\nimport { TezX, Router } from \"tezx\";\n\n// Parent router\nconst app = new TezX();\napp.get(\"/test\", (ctx) => ctx.text(\"Handler 1\"));\napp.get(\"/test/1\", (ctx) => ctx.text(\"Handler 2\"));\n\n// Sub-router\nconst productRouter = new Router();\nproductRouter.get(\"/products/2\", (ctx) => ctx.text(\"Handler 3\"));\n\n// Merge the routers into parent\napp.use(\"/\", productRouter);\n```\n\n---\n\n## 🧑‍💻 Best Practices\n\n### 1. **Use Unique Prefixes**\n\nPrevent conflicts by using distinct prefixes:\n\n```ts\nconst authRouter = new Router();\nauthRouter.get(\"/login\", (ctx) => ctx.text(\"Login\"));\n\napp.use(\"/auth\", authRouter);\n// Resulting route: /auth/login\n```\n\n---\n\n### 2. **Middleware Hygiene**\n\nEach router can define its own middlewares:\n\n```ts\nconst api = new Router();\n\napi.use((ctx, next) => {\n  ctx.setHeader(\"x-api\", \"v1\");\n  return next();\n});\n\napi.get(\"/status\", (ctx) => ctx.json({ ok: true }));\n\napp.use(\"/api\", api);\n```\n\n> Requests to `/api/status` automatically pass through the API middleware.\n\n---\n\n### 3. **Inspect Route Tree**\n\nLogging can help debug route structure:\n\n```ts\nconsole.log(app.routes);\n// Outputs a tree-like structure for verification\n```\n\n---\n\n### 4. **Safe Re-Merge Patterns**\n\nAvoid defining the same path across multiple routers:\n\n```ts\n// ❌ Avoid\nrouter1.get(\"/ping\", ...);\nrouter2.get(\"/ping\", ...);\n\n// ✅ Use prefixes\napp.use(\"/api\", router1);\napp.use(\"/public\", router2);\n```\n\n---\n"
    },
    {
      "id": 17,
      "path": "api/request/request",
      "name": "Request",
      "folder": "API/Request",
      "content": "# 📦 TezXRequest — Request Wrapper\n\n`TezXRequest` is a thin wrapper around the native `Request` object.\nIt makes working with **query params, route params, headers, body parsing, and file uploads** straightforward.\n\n---\n\n```mermaid\nflowchart TD\n    A[Incoming HTTP Request] --> B[TezXRequest Wrapper]\n\n    B --> C1[URL]\n    B --> C2[Method]\n    B --> C3[Pathname]\n    B --> C4[Params]\n    B --> C5[Query]\n    B --> C6[Headers]\n    B --> C7[Body Parsing]\n\n    C7 --> D1[Raw Text]\n    C7 --> D2[JSON]\n    C7 --> D3[FormData]\n    D3 --> D4[Files]\n```\n\n**Explanation:**\n\n* Request comes in → wrapped by `TezXRequest`\n* You can directly access **URL, method, pathname, params, query, headers**\n* For the body → you can parse as **text, JSON, or FormData** (with file support)\n\n---\n\n## 🔹 Properties\n\n### `url: string`\n\nFull request URL.\n\n```ts\nctx.req.url; \n// \"https://example.com/api/user?id=5\"\n```\n\n---\n\n### `method: HTTPMethod`\n\nHTTP method (GET, POST, PUT, etc).\n\n```ts\nctx.req.method; \n// \"POST\"\n```\n\n---\n\n### `pathname: string`\n\nURL path without query string.\n\n```ts\nctx.req.pathname; \n// \"/api/user\"\n```\n\n---\n\n### `params: Record<string, string>`\n\nRoute parameters extracted from the router.\n\n```ts\n// Route: /user/:id\nctx.req.params.id; \n// \"123\"\n```\n\n---\n\n### `query: Record<string, string>`\n\nQuery string parsed into a plain object.\n\n```ts\n// URL: /search?q=js&page=2\nctx.req.query.q;    // \"js\"\nctx.req.query.page; // \"2\"\n```\n\n---\n\n## 🔸 Methods\n\n### `header(): Record<string, string>`\n\nGet all request headers.\n\n```ts\nconst headers = ctx.req.header();\nconsole.log(headers[\"content-type\"]); \n// \"application/json\"\n```\n\n---\n\n### `header(name: string): string | undefined`\n\nGet a specific header (case-insensitive).\n\n```ts\nconst type = ctx.req.header(\"content-type\");\n// \"application/json\"\n```\n\n---\n\n### `text(): Promise<string>`\n\nRead raw body as a string.\n\n```ts\nconst body = await ctx.req.text();\nconsole.log(body); \n// '{\"username\":\"rakib\"}'\n```\n\n---\n\n### `json<T = any>(): Promise<T>`\n\nParse body as JSON. Returns `{}` if content-type isn’t JSON or parsing fails.\n\n```ts\nconst data = await ctx.req.json<{ username: string }>();\nconsole.log(data.username); \n// \"rakib\"\n```\n\n---\n\n### `formData(): Promise<FormData>`\n\nParse body as `FormData`. Supports:\n\n* `application/x-www-form-urlencoded`\n* `multipart/form-data` (with file uploads)\n\n```ts\nconst form = await ctx.req.formData();\nconsole.log(form.get(\"name\")); \n// \"Rakib\"\n\nconsole.log(form.getAll(\"skills\")); \n// [\"js\", \"ts\"]\n```\n\n---\n\n### ✅ `useFormData<T>()`\n\nType-safe helper for form parsing.\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nconst data = await useFormData<{ name: string; file: File }>(ctx);\n\nconsole.log(data.name); // \"Rakib\"\nconsole.log(data.file); // File object\n```\n\n---\n\n## 🛠 Developer Tips\n\n* Use `params` for **dynamic routes**\n* Use `query` for **URL query strings**\n* Use `header(\"content-type\")` before parsing body\n* Use `useFormData` if you need **typed + file-safe** handling\n* Always `await` parsing methods (`text()`, `json()`, `formData()`)\n\n---\n"
    },
    {
      "id": 18,
      "path": "api/response",
      "name": "Response",
      "folder": "API",
      "content": "# 🔁 Response Handling in TezX\n\nThe **TezX** framework provides a **rich response system** via the `ctx` object.\nThis system makes it easy to return **JSON, HTML, text, XML, files, redirects, and custom responses** with a clean API.\n\n---\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Handler as Route Handler\n    participant Ctx as ctx\n    participant Runtime as Runtime\n    participant Client as HTTP Client\n\n    Handler->>Ctx: ctx.json({..}) / ctx.html(..) / ctx.text(..) / ctx.xml(..) / ctx.send(..)\n    Ctx->>Runtime: prepare Response object\n    Runtime-->>Client: HTTP Response (with proper headers, status, body)\n```\n\n## 🧩 Core Type Definitions\n\n```ts\nexport type NextCallback = () => Promise<void>; // continue middleware chain\n\nexport type HttpBaseResponse = Response | Promise<Response>;\n\nexport type Ctx<T extends Record<string, any> = {}, Path extends string = any> =\n  Context<T, Path> & T & Record<string, any>;\n\nexport type Callback<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>) => HttpBaseResponse;\n\nexport type Middleware<T = {}, Path extends string = any> =\n  (ctx: Ctx<T, Path>, next: NextCallback) =>\n    HttpBaseResponse | Promise<HttpBaseResponse | void> | NextCallback;\n\nexport type ErrorHandler<T = {}> =\n  (err: Error, ctx: Ctx<T>) => HttpBaseResponse;\n```\n\n---\n\n## ✅ Native Response\n\nFor full control, return a native `Response`:\n\n```ts\napp.get(\"/data\", (ctx) => {\n  ctx.setHeader(\"Content-Type\", \"text/plain\" )\n  return new Response(\"Hello World\", {\n    status: 200,\n    headers: ctx.header(),\n  });\n});\n```\n\n---\n\n## 🚀 Response Utilities on `ctx`\n\n### `ctx.json(body, status?, headers?)`\n\nSend JSON.\n\n```ts\napp.get(\"/json\", (ctx) => ctx.json({ success: true }, 200));\n```\n\n* **Content-Type**: `application/json`\n\n---\n\n### `ctx.html(html, status?, headers?)`\n\nSend HTML.\n\n```ts\napp.get(\"/html\", (ctx) => ctx.html(\"<h1>Welcome</h1>\"));\n```\n\n* **Content-Type**: `text/html`\n\n---\n\n### `ctx.text(text, status?, headers?)`\n\nSend plain text.\n\n```ts\napp.get(\"/plain\", (ctx) => ctx.text(\"Just text\"));\n```\n\n* **Content-Type**: `text/plain`\n\n---\n\n### `ctx.xml(xml, status?, headers?)`\n\nSend XML.\n\n```ts\napp.get(\"/xml\", (ctx) => ctx.xml(\"<note><msg>Hi</msg></note>\"));\n```\n\n* **Content-Type**: `application/xml`\n\n---\n\n### `ctx.send(body, status?, headers?)`\n\nSmart responder (auto-detects type).\n\n```ts\napp.get(\"/send\", (ctx) => ctx.send({ user: \"admin\" }));\n```\n\n* `object` → JSON\n* `string` → plain text\n* `Buffer`/`Uint8Array` → binary\n\n---\n\n### `ctx.redirect(url, status?, headers?)`\n\nRedirect user.\n\n```ts\napp.get(\"/go\", (ctx) => ctx.redirect(\"https://example.com\"));\n```\n\n* **Default Status**: `302`\n* **Header**: `Location`\n\n---\n\n### `ctx.download(filePath, fileName)`\n\nTrigger file download.\n\n```ts\napp.get(\"/download\", (ctx) => \n  ctx.download(\"/files/report.pdf\", \"Monthly-Report.pdf\")\n);\n```\n\n* **Header**: `Content-Disposition: attachment`\n\n---\n\n### `ctx.sendFile(filePath, fileName?)`\n\nServe static file.\n\n```ts\napp.get(\"/image\", (ctx) => ctx.sendFile(\"/assets/banner.jpg\"));\n```\n\n* Auto sets `Content-Type`\n* Streams file efficiently\n\n---\n\n## 🛠 Best Practices\n\n| Use Case               | Recommended Method |\n| ---------------------- | ------------------ |\n| JSON API response      | `ctx.json()`       |\n| HTML rendering         | `ctx.html()`       |\n| Plain text output      | `ctx.text()`       |\n| XML feeds / APIs       | `ctx.xml()`        |\n| Dynamic content (auto) | `ctx.send()`       |\n| External redirects     | `ctx.redirect()`   |\n| Secure file download   | `ctx.download()`   |\n| Static asset serving   | `ctx.sendFile()`   |\n| Full manual control    | Native `Response`  |\n\n---\n"
    },
    {
      "id": 19,
      "path": "route-registry/radix-router",
      "name": "Radix Router",
      "folder": "Route Registry",
      "content": "# 📦 RadixRouter\n\n`RadixRouter` is a **high-performance HTTP router** using a radix tree for **fast, memory-efficient route matching**. It supports static, dynamic, optional, and wildcard routes, with middleware stacking and router composition for modular applications.\n\n```mermaid\nsequenceDiagram\n    autonumber\n    participant Client as 🧑‍💻 HTTP Client\n    participant Router as 🧭 RadixRouter\n    Note over Router: Match priority → **Static → Dynamic → Optional → Wildcard**\n\n    Client->>Router: Incoming Request (method + path)\n\n    alt Static Segment Match\n        Router-->>Client: Return Handlers\n    else Dynamic Segment Match\n        Router-->>Client: Return Handlers + Params\n    else Optional Segment Match\n        Router-->>Client: Return Handlers (Param or null)\n    else Wildcard Segment Match\n        Router-->>Client: Return Handlers (remaining path)\n    else No Match\n        Router-->>Client: 404 Not Found\n    end\n```\n\n---\n\n## 🔍 Key Features\n\n* **Static Routes:** `/users`\n* **Dynamic Parameters:** `/users/:id`\n* **Optional Parameters:** `/users/:id?`\n* **Wildcards:** `/files/*path`\n* **Middleware Stacking:** Global & route-specific\n* **Router Composition:** Merge sub-routers for maintainability\n\n---\n\n## 📄 Usage\n\n### Initialize Router\n\n```ts\nimport { RadixRouter } from \"tezx/registry\";\n\nconst router = new RadixRouter();\n```\n\n---\n\n### Add Routes\n\n```ts\nrouter.addRoute(\"GET\", \"/hello\", [(ctx) => ctx.text(\"Hello World\")]);\n\nrouter.addRoute(\"GET\", \"/user/:id?\", [\n  (ctx) => ctx.text(`User ID: ${ctx.params.id ?? \"Guest\"}`),\n]);\n\nrouter.addRoute(\"GET\", \"/files/*path\", [serveFileHandler]);\n```\n\n*Supports static, dynamic (`:id`), optional (`:id?`), and wildcard (`*path`) segments.*\n\n---\n\n### Search Routes\n\n```ts\nconst match = router.search(\"GET\", \"/user/123\");\nawait match.handlers[0](ctx); // Executes matched handler\n```\n\n**Return Structure:**\n\n```ts\n{\n  method: \"GET\",\n  params: { id: \"123\" },\n  middlewares: [...],\n  handlers: [...],\n}\n```\n\n---\n\n## ⚡ Matching Priority\n\n1. **Static segments** (`/users`)\n2. **Dynamic segments** (`/users/:id`)\n3. **Optional segments** (`/users/:id?`)\n4. **Wildcard segments** (`/files/*path`)\n\nBacktracking ensures optional segments fallback gracefully.\n\n---\n\n## 🧩 Internal: `parsePattern`\n\nSegments are parsed into:\n\n```ts\ntype Segment = {\n  type: \"static\" | \"dynamic\" | \"wildcard\";\n  value?: string;\n  paramName?: string;\n  isOptional?: boolean;\n};\n```\n\nUsed internally for **efficient radix tree insertion & matching**.\n\n---\n\n## 📊 Performance (Updated Benchmark)\n\n```text\nRadixRouter.search()\nTotal ops:       1,200,000\nTotal time:      170.72 ms\nAvg per op:      142.26 ns (0.142 µs)\nThroughput:      7,029,244 ops/sec\n```\n\n> Extremely fast and suitable for **high-traffic, low-latency applications**.\n\n---\n\n## 🛠 Types\n\n```ts\ntype RouteMatchResult<T> = {\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>[];\n  params: Record<string, string | null | undefined>;\n};\n\ninterface RouteRegistry {\n  name: string;\n  addRoute<T>(method: HTTPMethod, path: string, handler: HandlerType<T>): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult<T>;\n}\n```\n\n---\n"
    },
    {
      "id": 20,
      "path": "route-registry/custom-router",
      "name": "Custom Router",
      "folder": "Route Registry",
      "content": "# TezX Route Registry\n\n## Quick overview\n\nTezX uses a `RouteRegistry` to store and match routes. A `Router` (or the top-level `TezX` server) delegates route registration and lookup to a `RouteRegistry` implementation. You can provide the built-in registry or implement your own `CustomRouter` if you need different behavior (radix tree, trie, high-performance matcher, custom param parsing, etc.).\n\nThis doc assumes basic TypeScript knowledge.\n\n---\n\n## Install & import\n\n```ts\n// package name: tezx\nimport { TezX, Router, Middleware, Callback, HTTPMethod } from \"tezx\";\n```\n\n---\n\n## Core types & interfaces (simplified)\n\n```ts\nexport type RouteMatchResult<T extends Record<string, any> = any> = {\n  method: HTTPMethod;\n  middlewares: Middleware<T>[];\n  handlers: HandlerType<T>;\n  params: Record<string, string | null | undefined>;\n};\n\nexport type HandlerType<T extends Record<string, any> = any> = (\n  | Callback<T>\n  | Middleware<T>\n)[];\n\nexport interface RouteRegistry {\n  name: string;\n  addRoute<T extends Record<string, any> = any>(\n    method: HTTPMethod,\n    path: string,\n    handler: HandlerType<T>,\n  ): void;\n  search(method: HTTPMethod, path: string): RouteMatchResult;\n}\n```\n\n> Short note: `ALL` is conventionally used for \"attach to all methods\" (common for middlewares).\n\n---\n\n## What you’ll implement in a `CustomRouter`\n\nMinimal responsibilities:\n\n1. store registered routes and their handlers/middlewares\n2. match an incoming `method` + `path` and return a `RouteMatchResult`\n3. allow wildcard/middleware routes (e.g. `method = \"ALL\"`) and sub-routers (optional)\n\nA high-level `addRoute` + `search` is all TezX needs. The rest is implementation detail.\n\n---\n\n## Example: a simple `CustomRouter` implementation (radix/trie-free but clear)\n\n> This is a **drop-in** example you can expand (add performance, caching, param parsing).\n\n```ts\n// CustomRouter.ts\nimport type { RouteRegistry, RouteMatchResult, HTTPMethod, HandlerType } from \"tezx\";\n\ntype RouteNode = {\n  path: string; // exact or param pattern like \":id\" or \"*\"\n  method: HTTPMethod;\n  handlers: HandlerType;\n};\n\nexport class CustomRouter implements RouteRegistry {\n  name = \"custom-router\";\n  private routes: RouteNode[] = [];\n\n  addRoute(method: HTTPMethod, path: string, handlers: HandlerType) {\n    // normalize path (remove trailing slash except root)\n    const p = path === \"/\" ? \"/\" : path.replace(/\\/$/, \"\");\n    this.routes.push({ path: p, method, handlers });\n  }\n\n  search(method: HTTPMethod, path: string) : RouteMatchResult {\n    const p = path === \"/\" ? \"/\" : path.replace(/\\/$/, \"\");\n\n    // 1) exact match\n    for (const r of this.routes) {\n      if ((r.method === method || r.method === \"ALL\") && r.path === p) {\n        return {\n          method: r.method,\n          middlewares: r.handlers.filter(Boolean) as any,\n          handlers: r.handlers,\n          params: {},\n        } as RouteMatchResult;\n      }\n    }\n\n    // 2) simple param match (e.g. /users/:id)\n    for (const r of this.routes) {\n      if (r.method !== method && r.method !== \"ALL\") continue;\n      const routeParts = r.path.split(\"/\").filter(Boolean);\n      const urlParts = p.split(\"/\").filter(Boolean);\n      if (routeParts.length !== urlParts.length) continue;\n\n      const params: Record<string, string> = {};\n      let matched = true;\n      for (let i = 0; i < routeParts.length; i++) {\n        const rp = routeParts[i];\n        const up = urlParts[i];\n        if (rp.startsWith(\":\")) {\n          params[rp.slice(1)] = decodeURIComponent(up);\n          continue;\n        }\n        if (rp === \"*\") continue;\n        if (rp !== up) {\n          matched = false;\n          break;\n        }\n      }\n\n      if (matched) {\n        return {\n          method: r.method,\n          middlewares: r.handlers.filter(Boolean) as any,\n          handlers: r.handlers,\n          params,\n        } as RouteMatchResult;\n      }\n    }\n\n    // 3) not found — return empty result (TezX may treat as 404)\n    return {\n      method,\n      middlewares: [],\n      handlers: [],\n      params: {},\n    } as RouteMatchResult;\n  }\n}\n```\n\n---\n\n## How TezX uses the registry (sequence diagram)\n\n```mermaid\nsequenceDiagram\n  participant Client\n  participant TezX\n  participant RouteRegistry\n  participant Middlewares\n  participant Handler\n\n  Client->>TezX: HTTP GET /users/42\n  TezX->>RouteRegistry: search(\"GET\", \"/users/42\")\n  RouteRegistry-->>TezX: RouteMatchResult { handlers, middlewares, params }\n  TezX->>Middlewares: run middleware chain (in-order)\n  Middlewares-->>TezX: next()\n  TezX->>Handler: invoke final handler with ctx + params\n  Handler-->>Client: response\n```\n\n---\n\n## Example: register routes & start server\n\n```ts\nimport { TezX, Router } from \"tezx\";\nimport { CustomRouter } from \"./CustomRouter\";\n\nconst app = new TezX({\n  debugMode: true,\n  routeRegistry: new CustomRouter(),\n  env: { /* your env */ },\n});\n\n// Using Router helper (sub-router) — Router will call into the provided routeRegistry\nconst router = new Router({ routeRegistry: new CustomRouter() });\n\n// handlers\nconst authMiddleware: Middleware<any> = async (ctx, next) => {\n  if (!ctx.user) throw new Error(\"unauthenticated\");\n  await next();\n};\n\nconst getUser: Callback<any> = async (ctx) => {\n  const id = ctx.params.id;\n  ctx.res.json({ id, name: \"User\" + id });\n};\n\n// register\napp.get(\"/users/:id\", [authMiddleware, getUser]);\n\n// or via app convenience method (if TezX exposes one)\nrouter.post(\"/users\", [async (ctx) => {/*...*/}]);\n\n\n```\n\n---\n\n## API Reference (cheat-sheet)\n\n* `RouteRegistry.name: string` — identifier.\n* `addRoute(method, path, handler)` — register route or middleware. `method = \"ALL\"` for global.\n* `search(method, path) -> RouteMatchResult` — returns handlers, middlewares and `params`.\n\n---\n\n## Common extensions you might add\n\n* `priority` or `order` for routes so specific routes beat wildcard routes.\n* compiled regex for param routes (`/users/:id(\\\\d+)`).\n* method groups (e.g. `GET|POST`) and versioned routes (`/v1/users`).\n* route metadata (auth roles, rate limits) stored in the route node.\n\n---\n"
    },
    {
      "id": 21,
      "path": "middleware/basic-auth",
      "name": "Basic Auth",
      "folder": "Middleware",
      "content": "# 🔐 Basic Authentication Middleware (`basicAuth`)\n\nThe `basicAuth` middleware enforces **HTTP Basic Authentication** on incoming requests.\nIt verifies the `Authorization: Basic ...` header, validates credentials, and rejects unauthorized clients.\n\n---\n\n## ✅ When to Use\n\n* Protect admin routes (e.g., `/admin`, `/dashboard`).\n* Secure APIs during development/testing without setting up OAuth/JWT.\n* Quickly add a login wall for staging servers.\n\n---\n\n## 📦 Import\n\n```ts\nimport {basicAuth} from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type BasicAuthOptions = {\n  /**\n   * Function to validate credentials.\n   */\n  validate: (\n    username: string,\n    password: string,\n    ctx: Context\n  ) => boolean | Promise<boolean>;\n\n  /**\n   * Authentication realm (shown in browser login popup).\n   * @default \"Restricted Area\"\n   */\n  realm?: string;\n\n  /**\n   * Custom handler when authentication fails.\n   * Must return an HttpBaseResponse.\n   */\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n};\n```\n\n---\n\n## 🛠️ Usage Example\n\n### 1. Simple Static Credentials\n\n```ts\nimport {basicAuth} from \"tezx/middleware\";\n\nconst auth = basicAuth({\n  validate: (username, password) =>\n    username === \"admin\" && password === \"secret\",\n});\n```\n\n```ts\n// Use in your route\napp.use(\"/admin\", auth, (ctx) => {\n  ctx.json({ message: \"Welcome, admin!\" });\n});\n```\n\n---\n\n### 2. Async Validation (e.g., Database)\n\n```ts\nconst auth = basicAuth({\n  validate: async (username, password, ctx) => {\n    const user = await db.users.findOne({ username });\n    return user && user.passwordHash === hash(password);\n  },\n});\n```\n\n---\n\n### 3. Custom Unauthorized Handler\n\n```ts\nconst auth = basicAuth({\n  validate: (u, p) => u === \"demo\" && p === \"demo\",\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    return ctx.json({ error: \"Access denied\", reason: error?.message });\n  },\n});\n```\n\n---\n\n## 🔄 How It Works\n\n1. Reads the `Authorization` header.\n2. Ensures it starts with `Basic`.\n3. Decodes the Base64 credentials into `username:password`.\n4. Calls your `validate(username, password, ctx)`.\n5. * ✅ If valid → attaches `ctx.user = { username }` and continues.\n   * ❌ If invalid → calls `onUnauthorized` and ends the request.\n\n---\n\n## 🧑‍💻 Accessing Authenticated User\n\n```ts\napp.get(\"/profile\", auth, (ctx) => {\n  const user = (ctx as any).user;\n  return ctx.json({ message: `Hello ${user.username}` });\n});\n```\n\n---\n\n## ⚠️ Notes\n\n* Credentials are sent **on every request** in Base64 (not secure unless using HTTPS).\n* For production, prefer JWT, OAuth2, or session-based auth.\n* `realm` value appears in the browser’s login popup.\n\n---\n"
    },
    {
      "id": 22,
      "path": "middleware/bearer-auth",
      "name": "Bearer Auth",
      "folder": "Middleware",
      "content": "# Bearer Authentication Middleware (`bearerAuth`)\n\nMiddleware to protect routes using **Bearer tokens** (commonly used for JWTs, opaque API tokens, etc.).\nIt extracts the token from the `Authorization` header, delegates validation to your code, and either continues the pipeline or returns an unauthorized response.\n\n---\n\n## Import\n\n```ts\nimport { bearerAuth } from \"tezx/middleware\";\n```\n\n---\n\n## Purpose\n\n* Enforce presence of `Authorization: Bearer <token>` header.\n* Call user-provided `validate` function to determine token validity.\n* Provide a hook to return a custom `HttpBaseResponse` on failure.\n* Attach token (or user info) to `ctx` for downstream handlers.\n\n---\n\n## API / Options\n\n```ts\nexport type BearerAuthOptions = {\n  /**\n   * Validate function. Return `true` (or a truthy value) if token is valid.\n   * Can be synchronous or async.\n   */\n  validate: (token: string, ctx: Context) => boolean | Promise<boolean>;\n\n  /**\n   * Realm shown in `WWW-Authenticate` header. Defaults to \"API\".\n   */\n  realm?: string;\n\n  /**\n   * Handler invoked on unauthorized access.\n   * Must return an `HttpBaseResponse`.\n   */\n  onUnauthorized?: (ctx: Context, error?: Error) => HttpBaseResponse;\n};\n```\n\n**Default behavior** (when `onUnauthorized` not provided):\n\n* Sets `ctx.setStatus = 401`\n* Sets header `WWW-Authenticate: Bearer realm=\"<realm>\"`\n* Returns `ctx.json({ error: \"<message>\" })`\n\n---\n\n## Behavior / Flow\n\n1. Read `authorization` header via `ctx.req.header(\"authorization\")`.\n2. If missing or not `Bearer` → call `onUnauthorized` with error `Bearer token required`.\n3. Extract token (`auth.slice(7).trim()`).\n4. If token empty → `onUnauthorized` with `Empty token`.\n5. Call `await validate(token, ctx)`.\n\n   * If false → `onUnauthorized` with `Invalid or expired token`.\n   * If true → attach `(ctx as any).token = token` and call `next()`.\n\nErrors thrown inside `validate` are caught and passed to `onUnauthorized`.\n\n---\n\n## Examples\n\n### 1) Simple synchronous token check\n\n```ts\nconst auth = bearerAuth({\n  validate: (token) => token === \"dev-secret-token\"\n});\n\napp.use(\"/protected\", auth, (ctx) => {\n  ctx.json({ ok: true });\n});\n```\n\n### 2) Async check (DB / cache)\n\n```ts\nconst auth = bearerAuth({\n  validate: async (token) => {\n    const record = await db.tokens.findOne({ token });\n    return !!record && !record.revoked && record.expiresAt > Date.now();\n  }\n});\n```\n\n### 3) JWT verification example\n\n```ts\nimport jwt from \"jsonwebtoken\";\n\nconst auth = bearerAuth({\n  validate: async (token, ctx) => {\n    try {\n      const payload = jwt.verify(token, process.env.JWT_SECRET);\n      // attach decoded user for downstream handlers\n      (ctx as any).user = payload;\n      return true;\n    } catch {\n      return false;\n    }\n  },\n});\n```\n\n### 4) Custom `onUnauthorized`\n\n```ts\nconst auth = bearerAuth({\n  validate: async (t) => verifyTokenSomehow(t),\n  onUnauthorized: (ctx, error) => {\n    ctx.setStatus = 401;\n    ctx.setHeader(\"WWW-Authenticate\", `Bearer realm=\"API\"`);\n    // Return a custom HttpBaseResponse (or ctx.json)\n    return ctx.json({ error: \"Auth failed\", reason: error?.message });\n  }\n});\n```\n\n---\n\n## How to access validated token / user\n\nDownstream handlers can read the token (or attached user info):\n\n```ts\napp.get(\"/me\", auth, (ctx) => {\n  const token = (ctx as any).token; // raw token string\n  const user = (ctx as any).user;   // if you attached user in validate()\n  ctx.json({ token, user });\n});\n```\n\n---\n\n## Security Notes\n\n* **Always use HTTPS** — Bearer tokens sent in plaintext over HTTP are vulnerable.\n* Tokens are sent on every request; prefer short-lived tokens + refresh strategy or signed tokens (JWT).\n* Don’t log full tokens in production.\n* If validating JWTs, verify signature, issuer, audience, and expiry.\n\n---\n\n## Edge Cases & Recommendations\n\n* Header casing: `ctx.req.header(\"authorization\")` should handle typical casing; if not, fallback to `Authorization`.\n* Multiple auth schemes: if you support Basic/API-Key, ensure middleware ordering or combine into a flexible auth middleware.\n* If `validate` attaches heavy objects to `ctx`, prefer a sanitized `ctx.user` structure.\n* For streaming responses, nothing special is needed; this middleware runs before response generation.\n\n---\n\n## Testing Tips\n\n* Unit test both success and failure flows:\n\n  * Missing header\n  * `Authorization: Bearer` (empty token)\n  * Invalid token\n  * `validate` throwing an error\n  * Valid token attaches `token` / `user` and calls `next()`\n* Mock `ctx.req.header` and `ctx.json` when testing in isolation.\n* Integration tests: issue HTTP requests with `Authorization` header to protected endpoints.\n\n---\n\n## Example: Full usage with Express-like pseudo-app\n\n```ts\nconst auth = bearerAuth({\n  validate: async (token, ctx) => {\n    // Example: decode jwt + attach user\n    try {\n      const payload = jwt.verify(token, process.env.JWT_SECRET);\n      (ctx as any).user = payload;\n      return true;\n    } catch {\n      return false;\n    }\n  },\n});\n\napp.use(\"/api\", auth);\n\napp.get(\"/api/profile\", (ctx) => {\n  const user = (ctx as any).user;\n  return ctx.json({ user });\n});\n```\n\n---\n\n## Troubleshooting\n\n* If requests always fail: ensure the `Authorization` header is present and not stripped by proxies. Check `Authorization` vs `authorization` handling.\n* If `validate` never runs: confirm the middleware is registered for the correct route and that other middleware isn’t short-circuiting.\n* If `onUnauthorized` returns unexpected shape: ensure it returns the `HttpBaseResponse` expected by your framework or uses `ctx.json()`.\n\n---\n"
    },
    {
      "id": 23,
      "path": "middleware/cors",
      "name": "CORS",
      "folder": "Middleware",
      "content": "\n# CORS Middleware (`cors`)\n\nMiddleware for handling **Cross-Origin Resource Sharing (CORS)** in your TezX server. It allows you to configure which origins, methods, headers, and credentials are allowed.\n\n## Import\n\n```ts\nimport { cors } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`CorsOptions`)\n\n```ts\nexport type CorsOptions = {\n  /** Allowed origins for CORS.\n   * Can be:\n   * - A string: e.g. \"https://example.com\"\n   * - An array of strings: e.g. [\"https://example.com\", \"https://foo.com\"]\n   * - A function: (reqOrigin: string) => boolean\n   */\n  origin?: string | string[] | ((reqOrigin: string) => boolean);\n\n  /** Allowed HTTP methods for CORS requests.\n   * Defaults to [\"GET\", \"POST\", \"PUT\", \"DELETE\"]\n   */\n  methods?: string[];\n\n  /** Allowed headers for CORS requests.\n   * Defaults to [\"Content-Type\", \"Authorization\"]\n   */\n  allowedHeaders?: string[];\n\n  /** Headers exposed to the browser */\n  exposedHeaders?: string[];\n\n  /** Indicates whether credentials (cookies/auth headers) are allowed */\n  credentials?: boolean;\n\n  /** Preflight cache duration (in seconds) */\n  maxAge?: number;\n};\n```\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { cors } from \"tezx/middleware\";\n\napp.use(\n  cors({\n    origin: \"*\", // allow all origins\n  })\n);\n```\n\n### Restrict to a Single Origin\n\n```ts\napp.use(\n  cors({\n    origin: \"https://example.com\",\n  })\n);\n```\n\n### Restrict to Multiple Origins\n\n```ts\napp.use(\n  cors({\n    origin: [\"https://example.com\", \"https://foo.com\"],\n  })\n);\n```\n\n### Dynamic Origin Check\n\n```ts\napp.use(\n  cors({\n    origin: (reqOrigin) => {\n      // allow only origins ending with 'mydomain.com'\n      return reqOrigin.endsWith(\"mydomain.com\");\n    },\n  })\n);\n```\n\n### Custom Methods and Headers\n\n```ts\napp.use(\n  cors({\n    methods: [\"GET\", \"POST\", \"PATCH\"],\n    allowedHeaders: [\"Content-Type\", \"Authorization\", \"X-Custom-Header\"],\n    exposedHeaders: [\"X-Custom-Header\"],\n  })\n);\n```\n\n### Enable Credentials and Preflight Cache\n\n```ts\napp.use(\n  cors({\n    credentials: true,\n    maxAge: 86400, // 1 day\n  })\n);\n```\n\n---\n\n## Behavior\n\n* Sets the following response headers automatically:\n\n```text\nAccess-Control-Allow-Origin\nAccess-Control-Allow-Methods\nAccess-Control-Allow-Headers\nAccess-Control-Expose-Headers (optional)\nAccess-Control-Allow-Credentials (optional)\nAccess-Control-Max-Age (optional)\n```\n\n* Automatically responds to **OPTIONS preflight requests** with status `204` (No Content) and does **not call the next middleware**.\n\n---\n\n## Middleware Type\n\n```ts\nfunction cors<T extends Record<string, any> = {}, Path extends string = any>(\n  option: CorsOptions = {}\n): Middleware<T, Path>\n```\n\n* `T` – custom context type (optional)\n* `Path` – route path type (optional)\n* Returns a `Middleware` function compatible with TezX.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport { router } from \"tezx\";\nimport cors from \"tezx/middleware\";\n\nrouter.get(\"/api/data\", cors(), async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\nrouter.post(\n  \"/api/secure\",\n  cors({\n    origin: \"https://example.com\",\n    credentials: true,\n  }),\n  async (ctx) => {\n    return ctx.json({ message: \"Secure POST request\" });\n  }\n);\n```\n\n---\n\n### Notes\n\n* If `origin` is not provided, defaults to `\"*\"` (allow all origins).\n* `methods` and `allowedHeaders` default to standard HTTP methods and headers.\n* Preflight requests (`OPTIONS`) are handled automatically and will not call downstream middleware.\n\n---\n"
    },
    {
      "id": 24,
      "path": "middleware/cache-control",
      "name": "Cache Control",
      "folder": "Middleware",
      "content": "# ⚡ `cacheControl` Middleware\n\nA **super-lightweight, zero-overhead HTTP caching middleware** for your custom web framework.\nIt automatically adds proper `Cache-Control`, `Expires`, and optional `Vary` headers — dynamically, based on flexible caching rules.\n\n---\n\n## 🚀 Features\n\n✅ Ultra-fast — optimized for V8 hot path (manual loop, no .find, no closures).\n✅ Zero dependencies — pure TypeScript, ~1KB runtime footprint.\n✅ Rule-based — apply dynamic caching based on request conditions.\n✅ Fully safe — errors wrapped in `TezXError`, never crash the app.\n✅ Works seamlessly with your existing `Context` and `Middleware` interfaces.\n\n---\n\n## 📦 Installation\n\nIf this middleware is part of your internal framework, just import directly:\n\n```ts\nimport { cacheControl } from \"tezx/middleware\";\n```\n\n---\n\n## 🧠 Usage Example\n\n```ts\nimport { cacheControl } from \"tezx/middleware\";\n\napp.use(\n  cacheControl({\n    defaultSettings: {\n      maxAge: 3600, // 1 hour\n      scope: \"public\",\n    },\n    rules: [\n      {\n        condition: (ctx) => ctx.url.startsWith(\"/api/private\"),\n        maxAge: 0,\n        scope: \"private\",\n      },\n      {\n        condition: (ctx) => ctx.url.includes(\"/images/\"),\n        maxAge: 86400, // 1 day\n        scope: \"public\",\n        vary: [\"Accept-Encoding\"],\n      },\n    ],\n    onError: (error, ctx) => {\n      ctx.setStatus = error.statusCode ?? 500;\n      return ctx.json(error?.message)\n    },\n  })\n);\n```\n\n---\n\n## ⚙️ API Reference\n\n### `cacheControl(options: CacheOptions): Middleware`\n\nCreates and returns a new caching middleware function.\n\n#### Parameters\n\n| Name              | Type                                                                | Description                                                         |\n| ----------------- | ------------------------------------------------------------------- | ------------------------------------------------------------------- |\n| `defaultSettings` | `CacheSettings`                                                     | Default caching policy applied when no rule matches.                |\n| `rules`           | `CacheRule[]` *(optional)*                                          | Custom cache rules evaluated per request. First matching rule wins. |\n| `onError`         | `(error: TezXError, ctx: Context) => HttpBaseResponse` *(optional)* | Custom error handler for middleware-level exceptions.               |\n\n---\n\n## 🧩 Type Definitions\n\n```ts\nexport interface CacheRule {\n  /** 🎯 Condition to determine if this rule applies */\n  condition: (ctx: Context) => boolean;\n  /** ⏳ Max age (in seconds) */\n  maxAge: number;\n  /** 🌐 Cache scope */\n  scope: \"public\" | \"private\";\n  /** 🏷️ Optional vary header */\n  vary?: string[];\n}\n\nexport interface CacheSettings\n  extends Pick<CacheRule, \"maxAge\" | \"scope\" | \"vary\"> {}\n\nexport interface CacheOptions {\n  defaultSettings: CacheSettings;\n  rules?: readonly CacheRule[];\n  onError?: (error: TezXError, ctx: Context) => HttpBaseResponse;\n}\n```\n\n---\n\n## 🧮 How It Works\n\n1. Middleware runs **only** for `GET` and `HEAD` requests (no effect on POST/PUT).\n2. It checks the provided `rules` sequentially.\n3. The **first matching rule** determines the caching policy.\n4. If no rules match, the `defaultSettings` are applied.\n5. The following headers are set:\n\n   * `Cache-Control: public, max-age=3600`\n   * `Expires: <UTC datetime>`\n   * `Vary: Accept-Encoding, ...` *(if specified)*\n\n---\n\n## 🧩 Error Handling\n\nIf an exception occurs inside your route handler or cache logic:\n\n* The error is wrapped in `TezXError`.\n* The middleware invokes `onError(error, ctx)` (if provided).\n* Default behavior sets status `500` and a JSON body `{ error: \"Cache middleware failed\" }`.\n\n---\n\n## 🧭 Recommended Patterns\n\n| Scenario            | Recommended Setting                             |\n| ------------------- | ----------------------------------------------- |\n| Static assets       | `{ scope: \"public\", maxAge: 86400 }`            |\n| Authenticated API   | `{ scope: \"private\", maxAge: 0 }`               |\n| Dynamic pages       | `{ scope: \"public\", maxAge: 60 }`               |\n| Sensitive user data | Disable cache (`maxAge: 0`, `scope: \"private\"`) |\n\n---\n\n## 🧱 Example Integration with Router\n\n```ts\napp.use(\"/products\", cacheControl({\n  defaultSettings: { maxAge: 600, scope: \"public\" },\n}));\n```\n\n---\n"
    },
    {
      "id": 25,
      "path": "middleware/detact-bot",
      "name": "Detact Bot",
      "folder": "Middleware",
      "content": "# 🧠 `detectBot` Middleware\n\nDetect and block automated or malicious requests using advanced heuristics — combining **User-Agent analysis**, **IP blacklists**, **rate limiting**, and **custom detection logic**.\nBuilt for **high performance** on **Bun**, **Node.js**, and **Deno** runtimes.\n\n---\n\n## 📦 Import\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\n```\n\n---\n\n## 🚀 Quick Start\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\n\napp.use(\n  detectBot({\n    enableRateLimiting: true,\n    botUserAgents: [\"bot\", \"crawler\", \"indexer\"],\n    onBotDetected: (ctx, reason) =>\n      ctx.status(403).json({ error: `Bot detected: ${reason}` }),\n  })\n);\n```\n\n✅ The middleware automatically:\n\n* Detects common bots by analyzing the **User-Agent** header\n* Blocks requests from **blacklisted IPs**\n* Throttles suspicious traffic via **rate limiting**\n* Allows your own **custom detection rules**\n\n---\n\n## ⚙️ Configuration\n\n### `DetectBotOptions`\n\n| Option                 | Type                                                 | Default                               | Description                                                      |\n| ---------------------- | ---------------------------------------------------- | ------------------------------------- | ---------------------------------------------------------------- |\n| **botUserAgents**      | `string[]`                                           | `[\"bot\", \"spider\", \"crawl\", \"slurp\"]` | List of User-Agent substrings that indicate bot traffic.         |\n| **enableRateLimiting** | `boolean`                                            | `false`                               | Enable rate-limit based bot detection.                           |\n| **maxRequests**        | `number`                                             | `30`                                  | Maximum allowed requests per IP within the window.               |\n| **windowMs**           | `number`                                             | `60000`                               | Duration of rate-limit window (in milliseconds).                 |\n| **storage**            | `object`                                             | `In-memory Map`                       | Custom storage for rate-limit tracking (Redis, Memcached, etc.). |\n| **isBlacklisted**      | `(ctx: Context) => boolean \\| Promise<boolean>`      | `() => false`                         | Function to check if IP is blacklisted.                          |\n| **customBotDetector**  | `(ctx: Context) => boolean \\| Promise<boolean>`      | `undefined`                           | Custom logic for detecting bots (headers, params, etc.).         |\n| **onBotDetected**      | `(ctx: Context, reason: string) => HttpBaseResponse` | Returns `403 JSON`                    | Callback executed when a bot is detected.                        |\n\n---\n\n## 🧩 Example — Custom Setup\n\n### 1. Detect by custom header or query\n\n```ts\ndetectBot({\n  customBotDetector: (ctx) => ctx.query?.token === \"fake-token\",\n  onBotDetected: (ctx, reason) => ctx.status(403).json({ error: `Blocked by custom rule: ${reason}` }),\n});\n```\n\n### 2. Block a specific IP\n\n```ts\ndetectBot({\n  isBlacklisted: (ctx) => ctx.req.remoteAddress.address === \"192.168.0.42\",\n});\n```\n\n### 3. Redis-based rate-limit storage\n\n```ts\ndetectBot({\n  enableRateLimiting: true,\n  storage: {\n    get: (key) => myRedis.get(key),\n    set: (key, value) => myRedis.set(key, JSON.stringify(value)),\n    clearExpired: () => {},\n  },\n});\n```\n\n---\n\n## ⚡ Performance\n\nTezX automatically optimizes detection depending on the runtime:\n\n| Runtime            | Detection Method                      | Performance Note                     |\n| ------------------ | ------------------------------------- | ------------------------------------ |\n| **Bun**            | Precompiled RegExp                    | 🧠 Fastest; uses native regex engine |\n| **Node.js / Deno** | Manual `for..of` + `.includes()` loop | ⚙️ Optimized for V8                  |\n\n---\n\n## 🔍 Detection Flow\n\nThe middleware executes in the following order:\n\n1. **User-Agent Check**\n   Scans for known bot keywords in the User-Agent string.\n2. **IP Blacklist Check**\n   Executes your custom `isBlacklisted` callback.\n3. **Rate-Limiting Check** *(optional)*\n   Detects excessive requests per IP using `getConnInfo()`.\n4. **Custom Detection**\n   Executes your `customBotDetector` callback.\n5. **Pass-through**\n   Calls `next()` if no suspicious behavior is detected.\n\n---\n\n## ⚙️ Rate-Limiting Requirements\n\nTo use rate limiting, you must import `getConnInfo()` from your runtime adapter:\n\n```ts\n// Bun runtime\nimport { getConnInfo } from \"tezx/bun\";\n\n// Node.js runtime\nimport { getConnInfo } from \"tezx/node\";\n\n// Deno runtime\nimport { getConnInfo } from \"tezx/deno\";\n```\n\nEnsure the middleware has access to `ctx.req.remoteAddress`.\n\n---\n\n## 💡 Example Responses\n\n| Scenario            | Default Response                                              |\n| ------------------- | ------------------------------------------------------------- |\n| Bot by User-Agent   | `{ \"error\": \"Bot detected: User-Agent\" }`                     |\n| Rate-limit exceeded | `{ \"error\": \"Rate limit exceeded. Retry after 45 seconds.\" }` |\n| Blacklisted IP      | `{ \"error\": \"Bot detected: Blacklisted IP\" }`                 |\n\nYou can fully customize this behavior using `onBotDetected`.\n\n---\n\n## 🧰 Advanced Integration\n\nCombine `detectBot` with other TezX middlewares for a layered defense:\n\n```ts\nimport { detectBot } from \"tezx/middleware\";\nimport { cors } from \"tezx/middleware\";\n\napp.use(cors());\napp.use(detectBot({ enableRateLimiting: true }));\n```\n\n---\n\n## 🧾 Type Definitions\n\n```ts\ntype DetectBotOptions = {\n  botUserAgents?: string[];\n  enableRateLimiting?: boolean;\n  maxRequests?: number;\n  windowMs?: number;\n  storage?: RateLimitStorage;\n  isBlacklisted?: (ctx: Context) => boolean | Promise<boolean>;\n  customBotDetector?: (ctx: Context) => boolean | Promise<boolean>;\n  onBotDetected?: (ctx: Context, reason: string) => HttpBaseResponse;\n};\n```\n\n---\n\n## 🧩 Summary\n\n| Feature                | Description                                    |\n| ---------------------- | ---------------------------------------------- |\n| ✅ User-Agent detection | Detects bots via known patterns                |\n| 🚫 IP Blacklisting     | Blocks known or suspicious IPs                 |\n| ⚡ Rate Limiting        | Detects aggressive bot-like activity           |\n| 🧠 Custom Heuristics   | Flexible detection logic per project           |\n| 🛡️ Lightweight & Fast | Built for high-performance frameworks like Bun |\n| 🔄 Pluggable Storage   | Works with Redis, Memory, or custom stores     |\n\n---\n"
    },
    {
      "id": 26,
      "path": "middleware/logger",
      "name": "Logger",
      "folder": "Middleware",
      "content": "# Logger Middleware (`logger`)\n\nMiddleware for logging incoming HTTP requests and responses. Logs the **method**, **pathname**, **status code**, and **execution time** for each request. Useful for debugging and monitoring your TezX server.\n\n---\n\n## Import\n\n```ts\nimport { logger } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`LoggerOptions`)\n\n```ts\nexport interface LoggerOptions {\n  /** Enable or disable logging. Default: true */\n  enabled?: boolean;\n}\n```\n\n* `enabled` – Boolean flag to enable or disable logging.\n\n  * `true` – logs requests (default)\n  * `false` – disables logging for silent operation\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { logger } from \"tezx/middleware\";\n\n\napp.use(logger()); // logging enabled by default\n\napp.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n```\n\n### Disable Logging\n\n```ts\napp.use(logger({ enabled: false }));\n```\n\n---\n\n## Behavior\n\n1. **Logs Incoming Request**\n   When a request comes in, it logs:\n\n```bash\n<-- METHOD /pathname\n```\n\nExample:\n\n```bash\n<-- GET /api/data\n```\n\n2. **Measures Execution Time**\n   The middleware measures how long the downstream middleware or handler takes to complete.\n\n3. **Logs Response**\n   After the request is processed, it logs:\n\n```bash\n--> METHOD /pathname STATUS_CODE TIME\n```\n\nExample:\n\n```bash\n--> GET /api/data 200 3.45ms\n```\n\n4. **Error Logging**\n   If an error occurs during request processing, it logs the stack trace:\n\n```bash\nError: <stack trace>\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction logger(options?: LoggerOptions): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used globally or per-route.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport logger from \"tezx/middleware\";\n\n// Enable logger globally\napp.use(logger());\n\n// Sample route\napp.get(\"/api/users\", async (ctx) => {\n  return ctx.json({ users: [] });\n});\n\n// Disable logger for a specific route\napp.post(\"/api/secret\", logger({ enabled: false }), async (ctx) => {\n  return ctx.json({ secret: \"hidden\" });\n});\n```\n\n---\n\n## Console Output Example\n\n```text\n<-- GET /api/users\n--> GET /api/users 200 2.14ms\n\n<-- POST /api/secret\n--> POST /api/secret 200 1.07ms\n```\n\n* `<--` indicates **incoming request**\n* `-->` indicates **response completed**\n* Execution time shows **performance of route handler**\n\n---\n"
    },
    {
      "id": 27,
      "path": "middleware/pagination-handler",
      "name": "Pagination Handler",
      "folder": "Middleware",
      "content": "# 📘 Pagination Middleware (`paginationHandler`)\n\nThe `paginationHandler` middleware provides **automatic pagination handling** for API endpoints.\nIt simplifies extracting pagination parameters, calculating offsets, generating metadata, and optionally integrates with a **dynamic data source** (e.g., database, ORM).\n\n---\n\n## 📦 Import\n\n```ts\n// Standard import\nimport { paginationHandler } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type PaginationOptions<\n  DataKey extends string = \"data\",\n  CountKey extends string = \"total\",\n  Item = any\n> = {\n  defaultPage?: number;       // Default page if not specified (default: 1)\n  defaultLimit?: number;      // Default items per page (default: 10)\n  maxLimit?: number;          // Maximum items per page (default: 100)\n  queryKeyPage?: string;      // Query parameter for page (default: \"page\")\n  queryKeyLimit?: string;     // Query parameter for limit (default: \"limit\")\n  countKey?: CountKey;        // Key for total count (default: \"total\")\n  dataKey?: DataKey;          // Key for data array (default: \"data\")\n\n  getDataSource?: <T extends Record<string, any> = {}>(\n    ctx: Context<T>,\n    pagination: { page: number; limit: number; offset: number }\n  ) => Promise<\n    { [K in DataKey]: Item[] } & { [K in CountKey]: number }\n  >;\n};\n```\n\n---\n\n## 📊 Pagination Metadata\n\nWhen pagination is applied, the following structure is available in `ctx.pagination` and response body:\n\n```ts\ntype PaginationBodyType = {\n  [x: string]: any;\n  pagination: {\n    page: number;          // Current page number\n    limit: number;         // Items per page\n    offset: number;        // Calculated offset\n    totalItems: number;    // Total number of items\n    totalPages: number;    // Total number of pages\n    hasNextPage: boolean;  // Whether next page exists\n    hasPrevPage: boolean;  // Whether previous page exists\n    nextPage: number|null; // Next page number (or null)\n    prevPage: number|null; // Previous page number (or null)\n  };\n};\n```\n\n---\n\n## 🚀 Usage Examples\n\n### 1. Basic Setup (No Data Source)\n\nOnly extracts pagination parameters and makes them available via `ctx.pagination`.\n\n```ts\nimport { paginationHandler } from \"tezx/middleware\";\n\napp.get(\"/users\", paginationHandler(), async (ctx) => {\n  const { page, limit, offset } = ctx.pagination;\n  ctx.json({ page, limit, offset });\n});\n\n// GET /users?page=2&limit=5\n// → { \"page\": 2, \"limit\": 5, \"offset\": 5 }\n```\n\n---\n\n### 2. With Dynamic Data Source (Database Integration)\n\nAutomatically fetches data and total count from your database and returns a **structured response**.\n\n```ts\napp.get(\n  \"/products\",\n  paginationHandler({\n    getDataSource: async (ctx, { page, limit, offset }) => {\n      // Example using Sequelize\n      const { rows, count } = await Product.findAndCountAll({\n        offset,\n        limit,\n      });\n      return { data: rows, total: count };\n    },\n  })\n);\n\n// GET /products?page=2&limit=10\n// → {\n//   \"data\": [ ... 10 products ... ],\n//   \"total\": 53,\n//   \"pagination\": {\n//     \"page\": 2,\n//     \"limit\": 10,\n//     \"offset\": 10,\n//     \"totalItems\": 53,\n//     \"totalPages\": 6,\n//     \"hasNextPage\": true,\n//     \"hasPrevPage\": true,\n//     \"nextPage\": 3,\n//     \"prevPage\": 1\n//   }\n// }\n```\n\n---\n\n### 3. Custom Query Keys\n\nUse different query parameter names for pagination.\n\n```ts\napp.get(\n  \"/articles\",\n  paginationHandler({\n    queryKeyPage: \"p\",\n    queryKeyLimit: \"size\",\n  }),\n  async (ctx) => {\n    const { page, limit } = ctx.pagination;\n    ctx.json({ page, limit });\n  }\n);\n\n// GET /articles?p=3&size=20\n// → { \"page\": 3, \"limit\": 20 }\n```\n\n---\n\n### 4. Custom Data and Count Keys\n\nReturn custom response keys for compatibility with frontend clients.\n\n```ts\napp.get(\n  \"/comments\",\n  paginationHandler({\n    dataKey: \"items\",\n    countKey: \"totalCount\",\n    getDataSource: async (ctx, { offset, limit }) => {\n      const { rows, count } = await Comment.findAndCountAll({ offset, limit });\n      return { items: rows, totalCount: count };\n    },\n  })\n);\n\n// GET /comments?page=1&limit=5\n// → {\n//   \"items\": [ ... 5 comments ... ],\n//   \"totalCount\": 42,\n//   \"pagination\": { ... }\n// }\n```\n\n---\n\n### 5. Strict Maximum Limit\n\nProtect your API by enforcing a **hard max limit**.\n\n```ts\napp.get(\n  \"/logs\",\n  paginationHandler({\n    defaultLimit: 20,\n    maxLimit: 50, // Clients cannot request more than 50\n  }),\n  async (ctx) => {\n    ctx.json({ limit: ctx.pagination.limit });\n  }\n);\n\n// GET /logs?limit=500\n// → limit will be capped at 50\n```\n\n---\n\n## 🔒 Best Practices\n\n* **Always enforce `maxLimit`** to prevent abuse (e.g., denial-of-service by requesting huge datasets).\n* **Use `whitelist` query keys** (`queryKeyPage`, `queryKeyLimit`) for consistency across APIs.\n* **Custom response keys (`dataKey`, `countKey`)** make integration smoother with frontend expectations.\n* Place `paginationHandler` **before your route handler** so that `ctx.pagination` is available when querying your DB.\n* If using `getDataSource`, the middleware automatically sets the response body — otherwise, you can manually use `ctx.pagination`.\n\n---\n"
    },
    {
      "id": 28,
      "path": "middleware/powered-by",
      "name": "Powered By",
      "folder": "Middleware",
      "content": "# PoweredBy Middleware (`poweredBy`)\n\nMiddleware for adding an **`X-Powered-By`** header to HTTP responses. This is commonly used to indicate the server or framework powering the application.\n\n---\n\n## Import\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\n```\n\n---\n\n## Parameters\n\n```ts\nconst poweredBy = (serverName?: string): Middleware => { ... }\n```\n\n* `serverName` (optional) – A custom server name to use in the header.\n\n  * Default: `\"TezX\"`\n\n---\n\n## Usage\n\n### Basic Usage\n\nAdds the default `X-Powered-By` header with value `\"TezX\"`:\n\n```ts\nimport { poweredBy } from \"tezx/middleware\";\napp.use(poweredBy());\n```\n\n* Response Header Example:\n\n```bash\nX-Powered-By: TezX\n```\n\n### Custom Server Name\n\n```ts\napp.use(poweredBy(\"MyServer\"));\n```\n\n* Response Header Example:\n\n```bash\nX-Powered-By: MyServer\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction poweredBy(serverName?: string): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used **globally** or **per route**.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport poweredBy from \"tezx/middleware/poweredBy\";\n\n// Set global X-Powered-By header\napp.use(poweredBy());\n\n// Sample route\napp.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Hello World\" });\n});\n\n// Override with custom server name for a specific route\napp.get(\"/api/custom\", poweredBy(\"CustomServer\"), async (ctx) => {\n  return ctx.json({ message: \"Custom Header Applied\" });\n});\n```\n\n* `/api/data` response header: `X-Powered-By: TezX`\n* `/api/custom` response header: `X-Powered-By: CustomServer`\n\n---\n"
    },
    {
      "id": 29,
      "path": "middleware/rate-limiter",
      "name": "Rate Limiter",
      "folder": "Middleware",
      "content": "# 🚦 Rate Limiter Middleware (`rateLimiter`)\n\nThe `rateLimiter` middleware **limits the number of requests per client** over a configurable time window. It is ideal for **preventing abuse, brute-force attacks, or accidental API overload**.\n\nIt supports **custom client identification**, **custom storage**, and **custom error handling**.\n\n---\n\n## 📦 Import\n\n```ts\n// Standard import\nimport { rateLimiter } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type RateLimiterOptions = {\n  maxRequests: number;         // Maximum requests per window\n  windowMs: number;            // Time window in milliseconds\n\n  keyGenerator?: (ctx: Context) => string;\n  // Generate a unique client key\n  // default: use IP address from x-forwarded-for / client-ip / remoteAddress\n\n  storage?: {\n    get: (key: string) => { count: number; resetTime: number } | undefined;\n    set: (key: string, value: { count: number; resetTime: number }) => void;\n    clearExpired: () => void;\n  };\n  // Custom storage for tracking rate limits (e.g., Map, Redis)\n\n  onError?: (\n    ctx: Context,\n    retryAfter: number,\n    error: Error\n  ) => HttpBaseResponse;\n  // Custom callback when rate limit is exceeded\n};\n```\n\n---\n\n## 🧩 Behavior\n\n* Each client is identified by a **key** (IP by default, or custom via `keyGenerator`).\n* Requests are counted per **time window (`windowMs`)**.\n* Response headers provided:\n\n  * `X-RateLimit-Limit`: maximum requests allowed.\n  * `X-RateLimit-Remaining`: requests remaining in current window.\n  * `X-RateLimit-Reset`: timestamp (ms) when window resets.\n  * `Retry-After`: seconds until the window resets (only sent when limit exceeded).\n* If the client exceeds `maxRequests`, the `onError` callback is invoked (default: throw `429 Too Many Requests`).\n\n---\n\n## ✅ Default Behavior\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000, // 1 minute\n  })\n);\n```\n\n* Limits each client to **100 requests per minute**.\n* Sends standard rate-limit headers.\n* Returns `429` when exceeded.\n\n---\n\n## 🔑 Custom Client Key Example\n\nUse authenticated user IDs or tokens instead of IP addresses.\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 10,\n    windowMs: 10_000, // 10 seconds\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  })\n);\n```\n\n* Useful for APIs behind proxies or load balancers.\n* Ensures rate limiting is per **user** instead of per IP.\n\n---\n\n## 🗄️ Custom Storage (Redis Example)\n\nYou can replace the default in-memory store with Redis:\n\n```ts\nimport { redisClient } from \"./redisClient\";\n\nconst redisStorage = {\n  get: async (key: string) => {\n    const val = await redisClient.get(key);\n    return val ? JSON.parse(val) : undefined;\n  },\n  set: async (key: string, value: { count: number; resetTime: number }) => {\n    await redisClient.set(key, JSON.stringify(value), \"PX\", value.resetTime - Date.now());\n  },\n  clearExpired: () => {}, // Redis automatically expires keys\n};\n\napp.use(\n  rateLimiter({\n    maxRequests: 50,\n    windowMs: 60_000,\n    storage: redisStorage,\n  })\n);\n```\n\n---\n\n## ⚠️ Custom Error Handler\n\nYou can customize the response when the client exceeds the limit:\n\n```ts\napp.use(\n  rateLimiter({\n    maxRequests: 5,\n    windowMs: 60_000,\n    onError: (ctx, retryAfter) => {\n      ctx.setStatus = 429;\n      return ctx.json({\n        success: false,\n        message: `Too many requests. Try again in ${retryAfter} seconds.`,\n      });\n    },\n  })\n);\n```\n\n* Allows sending JSON, HTML, or custom formatted responses.\n* Still receives `Retry-After` header automatically.\n\n---\n\n## 🧾 Headers Sent by Middleware\n\n| Header                  | Description                                      |\n| ----------------------- | ------------------------------------------------ |\n| `X-RateLimit-Limit`     | Maximum requests per window                      |\n| `X-RateLimit-Remaining` | Requests left in the current window              |\n| `X-RateLimit-Reset`     | Timestamp (ms) when the window resets            |\n| `Retry-After`           | Seconds until next allowed request (only on 429) |\n\n---\n\n## 💡 Best Practices\n\n* Always use **`maxRequests` + `windowMs`** appropriate for your API traffic.\n* Use **custom keyGenerator** for user-based rate limiting.\n* Use **Redis or other distributed store** if deploying behind multiple servers.\n* Always include the `Retry-After` header for clients.\n* Combine with other middleware like `logger` or `cors` for robust APIs.\n\n---\n\n## Example: Full Stack Integration\n\n```ts\nimport { app } from \"tezx\";\nimport rateLimiter from \"tezx/middleware/rateLimiter\";\nimport logger from \"tezx/middleware/logger\";\nimport cors from \"tezx/middleware/cors\";\n\napp.use(cors());\napp.use(logger());\napp.use(\n  rateLimiter({\n    maxRequests: 100,\n    windowMs: 60_000,\n    keyGenerator: (ctx) => ctx.user?.id || ctx.ip,\n  })\n);\n\napp.get(\"/api/data\", async (ctx) => {\n  ctx.json({ success: true, data: [\"item1\", \"item2\"] });\n});\n```\n\n---\n"
    },
    {
      "id": 30,
      "path": "middleware/request-id",
      "name": "Request ID",
      "folder": "Middleware",
      "content": "# Request ID Middleware (`requestID`)\n\nMiddleware for assigning a **unique request ID** to every incoming HTTP request. Useful for **request tracking**, **logging**, and **debugging**.\n\n---\n\n## Import\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n```\n\n---\n\n## Parameters\n\n```ts\nconst requestID = (\n  headerName: string = \"X-Request-ID\",\n  contextKey: string = \"requestID\",\n): Middleware => { ... }\n```\n\n| Parameter    | Type     | Default          | Description                                              |\n| ------------ | -------- | ---------------- | -------------------------------------------------------- |\n| `headerName` | `string` | `\"X-Request-ID\"` | The HTTP header to store the request ID.                 |\n| `contextKey` | `string` | `\"requestID\"`    | Key to store the request ID in the TezX context (`ctx`). |\n\n---\n\n## Behavior\n\n1. Checks if the incoming request already has the request ID header.\n2. If not present, generates a new unique ID using `generateUUID()`.\n3. Sets the request ID in:\n\n   * **HTTP header** (`ctx.headers.set(headerName, requestId)`)\n   * **TezX context** (`ctx[contextKey] = requestId`)\n4. Can be accessed by downstream middleware or handlers using `ctx[contextKey]`.\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { requestID } from \"tezx/middleware\";\n\napp.use(requestID());\n\n// Access request ID in a route\nrouter.get(\"/api/data\", async (ctx) => {\n  console.log(\"Request ID:\", ctx.requestID);\n  return ctx.json({ requestID: ctx.requestID });\n});\n```\n\n* Adds header:\n\n```bash\nX-Request-ID: req-<unique-id>\n```\n\n---\n\n### Custom Header Name\n\n```ts\napp.use(requestID(\"X-Custom-Request-ID\"));\n```\n\n* Sets the request ID in `X-Custom-Request-ID` header and context key `requestID`:\n\n```ts\nctx.requestID // contains the generated ID\n```\n\n---\n\n### Custom Context Key\n\n```ts\napp.use(requestID(\"X-Request-ID\", \"reqId\"));\n\n// Access in route\nrouter.get(\"/api/data\", async (ctx) => {\n  console.log(ctx.reqId); // custom context key\n  return ctx.json({ reqId: ctx.reqId });\n});\n```\n\n---\n\n## Middleware Type\n\n```ts\nfunction requestID(headerName?: string, contextKey?: string): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Can be used **globally** or **per-route**.\n\n---\n\n## Example with Logger Integration\n\n```ts\nimport {requestID,logger} from \"tezx/middleware\";\n\napp.use(requestID()); // assign request ID\napp.use(logger());    // log requests including request ID\n\napp.get(\"/api/users\", async (ctx) => {\n  return ctx.json({ requestID: ctx.requestID });\n});\n```\n\n* Each log can include the unique request ID for traceability.\n\n---\n"
    },
    {
      "id": 31,
      "path": "middleware/sanitize-headers",
      "name": "Sanitize Headers",
      "folder": "Middleware",
      "content": "# SanitizeHeaders Middleware (`sanitizeHeaders`)\n\nMiddleware for **sanitizing HTTP headers** to enhance security and compliance. It allows you to **whitelist** allowed headers, **blacklist** disallowed headers, and removes dangerous or unnecessary headers to prevent **information leakage** or **header injection attacks**.\n\n---\n\n## Import\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\n```\n\n---\n\n## Options (`SanitizeHeadersOptions`)\n\n```ts\nexport type SanitizeHeadersOptions = {\n  /**\n   * 🟢 Whitelist of allowed headers (case-insensitive)\n   * @default [] (allow all headers if empty)\n   */\n  whitelist?: string[];\n\n  /**\n   * 🔴 Blacklist of disallowed headers (case-insensitive)\n   * @default [] (block none if empty)\n   */\n  blacklist?: string[];\n};\n```\n\n* `whitelist` – Only headers in this list are **kept**; all others are removed.\n* `blacklist` – Headers in this list are **removed** regardless of whitelist.\n* Header names are **case-insensitive**.\n\n---\n\n## Usage\n\n### Basic Usage\n\n```ts\nimport { sanitizeHeaders } from \"tezx/middleware\";\napp.use(sanitizeHeaders());\n```\n\n* With defaults, all headers are allowed unless explicitly removed elsewhere.\n\n---\n\n### Whitelist Only\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\"],\n  })\n);\n```\n\n* Keeps only `Content-Type` and `Authorization` headers; all others are removed.\n\n---\n\n### Blacklist Only\n\n```ts\napp.use(\n  sanitizeHeaders({\n    blacklist: [\"x-powered-by\", \"server\"],\n  })\n);\n```\n\n* Removes `X-Powered-By` and `Server` headers, while keeping all others.\n\n---\n\n### Combined Whitelist & Blacklist\n\n```ts\napp.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\", \"accept\"],\n    blacklist: [\"x-powered-by\"],\n  })\n);\n```\n\n* Keeps only headers in whitelist, except those in blacklist (`X-Powered-By` is removed even if present in whitelist).\n\n---\n\n## Middleware Type\n\n```ts\nfunction sanitizeHeaders(options?: SanitizeHeadersOptions): Middleware\n```\n\n* Returns a `Middleware` function compatible with TezX.\n* Should be applied **before sending response** to ensure headers are sanitized.\n\n---\n\n## Example with TezX Routes\n\n```ts\nimport { router } from \"tezx\";\nimport sanitizeHeaders from \"tezx/middleware/sanitizeHeaders\";\n\nrouter.use(\n  sanitizeHeaders({\n    whitelist: [\"content-type\", \"authorization\"],\n    blacklist: [\"x-powered-by\", \"server\"],\n  })\n);\n\nrouter.get(\"/api/data\", async (ctx) => {\n  return ctx.json({ message: \"Headers sanitized!\" });\n});\n```\n\n* Ensures that only allowed headers are present in the response.\n\n---\n"
    },
    {
      "id": 32,
      "path": "middleware/secure-headers",
      "name": "Secure Headers",
      "folder": "Middleware",
      "content": "\n# **`secureHeaders` Middleware**\n\n`secureHeaders` is a TezX-compatible middleware for adding **HTTP security headers** like HSTS, CSP, X-Frame-Options, and more. It supports presets, custom configurations, and optional per-request CSP nonces. Optimized for both **production** and **development**.\n\n---\n\n## **Installation**\n\n```ts\nimport { secureHeaders } from 'tezx/middleware';\n```\n\n---\n\n## **Usage Example**\n\n```ts\napp.use(secureHeaders({\n  preset: 'strict',       // strong defaults\n  cspUseNonce: true,      // generate per-request nonce for inline scripts\n}));\n```\n\n---\n\n## **Preset Options**\n\n| Preset     | Description                                                                                      |\n| ---------- | ------------------------------------------------------------------------------------------------ |\n| `strict`   | Strongest security for production: HSTS 2yrs, CSP enforcement, frame-guard DENY, XSS & sniffing. |\n| `balanced` | Default preset for most apps: reasonable headers, CSP report-only.                               |\n| `dev`      | Development mode: permissive headers, allows localhost, unsafe-inline scripts.                   |\n\n---\n\n## **SecureHeadersOptions & What Each Option Does**\n\n```ts\nexport type SecureHeadersOptions = {\n    preset?: \"strict\" | \"balanced\" | \"dev\";\n    hsts?: HstsOptions;\n    frameGuard?: \"DENY\" | \"SAMEORIGIN\" | string;\n    noSniff?: boolean;\n    xssProtection?: boolean;\n    referrerPolicy?: string;\n    permissionsPolicy?: string;\n    csp?: string | Record<string, string | string[]>;\n    cspReportOnly?: boolean;\n    cspUseNonce?: boolean;\n    ultraFastMode?: boolean;\n};\n```\n\n---\n\n### 1. **preset**\n\n* Chooses a pre-configured security set.\n* Default: `\"balanced\"`\n* **Use Case:** Quick setup without manual configuration.\n* **Example:** `'strict'` for production, `'dev'` for local development.\n\n---\n\n### 2. **hsts** (HTTP Strict Transport Security)\n\n* Adds `Strict-Transport-Security` header.\n* Forces HTTPS and optionally applies to subdomains.\n* **Example:**\n\n```ts\n{\n  maxAge: 31536000,          // 1 year\n  includeSubDomains: true,   // apply to all subdomains\n  preload: true,             // for browser preload list\n  hstsOnlyOnHttps: true,     // only on HTTPS requests\n}\n```\n\n* **Use Case:** Prevent man-in-the-middle attacks over HTTP.\n* **Tip:** Only use `preload` if you are confident about HTTPS everywhere.\n\n---\n\n### 3. **frameGuard**\n\n* Sets `X-Frame-Options` header to prevent clickjacking.\n* **Values:**\n\n  * `'DENY'` → never allow framing\n  * `'SAMEORIGIN'` → allow only same-origin\n  * custom string allowed\n* **Default:** `'SAMEORIGIN'`\n* **Use Case:** Prevent your site being embedded in iframes to avoid UI redress attacks.\n\n---\n\n### 4. **noSniff**\n\n* Sets `X-Content-Type-Options: nosniff`.\n* Prevents browsers from MIME type sniffing.\n* **Default:** true for strict/balanced presets.\n* **Use Case:** Stops content misinterpretation vulnerabilities.\n\n---\n\n### 5. **xssProtection**\n\n* Sets `X-XSS-Protection: 1; mode=block`.\n* Legacy protection for older browsers.\n* **Default:** true for strict/balanced presets.\n* **Use Case:** Extra protection in legacy browsers; modern browsers rely on CSP.\n\n---\n\n### 6. **referrerPolicy**\n\n* Sets `Referrer-Policy` header.\n* **Examples:** `\"no-referrer\"`, `\"strict-origin-when-cross-origin\"`.\n* **Use Case:** Control what referrer info browsers send, improves privacy/security.\n* **Default:** preset-dependent.\n\n---\n\n### 7. **permissionsPolicy**\n\n* Sets `Permissions-Policy` header (formerly Feature-Policy).\n* **Controls:** access to features like geolocation, microphone, camera.\n* **Example:** `'geolocation=(), microphone=()'`\n* **Use Case:** Limit access to sensitive APIs to reduce attack surface.\n\n---\n\n### 8. **csp** (Content Security Policy)\n\n* Prevents XSS, data injection, and unsafe script execution.\n* Can be a **string** or an **object map** of directives:\n\n```ts\n{\n  \"default-src\": [\"'self'\"],\n  \"script-src\": [\"'self'\", \"https://cdn.example.com\"],\n  \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n}\n```\n\n* **Use Case:** Strict CSP prevents malicious script execution.\n* **Tip:** Use object to precompute string at middleware init for performance.\n\n---\n\n### 9. **cspReportOnly**\n\n* Sends `Content-Security-Policy-Report-Only` instead of enforcement.\n* **Use Case:** Test CSP without blocking scripts.\n\n---\n\n### 10. **cspUseNonce**\n\n* Generates **per-request nonce** for inline scripts.\n* Injected as `'nonce-<value>'` in `script-src`.\n* Inline scripts must use same nonce:\n\n```html\n<script nonce=\"ctx.cspNonce\">\n  console.log(\"Allowed inline script\");\n</script>\n```\n\n* **Use Case:** Allows safe inline scripts without `'unsafe-inline'`.\n\n---\n\n### 11. **ultraFastMode**\n\n* Disables per-request allocations (like nonce generation).\n* Useful for **high-QPS APIs**.\n* **Use Case:** Skip nonce if inline scripts are not needed.\n\n---\n\n## **HSTS Options (HstsOptions)**\n\n```ts\nexport interface HstsOptions {\n    maxAge?: number;             // in seconds\n    includeSubDomains?: boolean; // apply to all subdomains\n    preload?: boolean;           // add to browser preload list\n    hstsOnlyOnHttps?: boolean;   // only apply on HTTPS\n}\n```\n\n---\n\n## **Middleware Flow**\n\n1. Checks protocol (HSTS only on HTTPS if configured)\n2. Sets core headers:\n\n   * `X-Frame-Options`\n   * `X-Content-Type-Options`\n   * `X-XSS-Protection`\n   * `Referrer-Policy`\n   * `Permissions-Policy`\n3. Sets CSP headers:\n\n   * `Content-Security-Policy` or `Content-Security-Policy-Report-Only`\n   * Optionally includes per-request nonce\n4. Passes context to `next()` middleware.\n\n---\n\n## **Example with Inline Scripts (Nonce)**\n\n```ts\napp.use(secureHeaders({ cspUseNonce: true }));\n\n// Template:\n<script nonce=\"<%= ctx.cspNonce %>\">\n  console.log(\"This inline script is allowed!\");\n</script>\n```\n\n---\n\n## **Developer Notes / Tips**\n\n* **Strict preset:** production-ready, enforce all headers.\n* **Balanced preset:** good for initial deployment; CSP report-only.\n* **Dev preset:** permissive for local dev; allows unsafe-inline.\n* **UltraFastMode:** skip nonce generation for high-QPS APIs.\n* Always use **HTTPS** when HSTS is enabled.\n* **Nonce values** are per-request and cryptographically random (if using `generateRandomBase64`).\n\n---\n\n## **Quick Reference: What each header does**\n\n| Header                                | Purpose                                                                    |\n| ------------------------------------- | -------------------------------------------------------------------------- |\n| `Strict-Transport-Security`           | Forces HTTPS, prevents MITM, optional preload                              |\n| `X-Frame-Options`                     | Prevent clickjacking (DENY / SAMEORIGIN)                                   |\n| `X-Content-Type-Options`              | Stops MIME sniffing (`nosniff`)                                            |\n| `X-XSS-Protection`                    | Legacy XSS protection in older browsers                                    |\n| `Referrer-Policy`                     | Controls which referrer info browsers send                                 |\n| `Permissions-Policy`                  | Controls access to sensitive browser APIs                                  |\n| `Content-Security-Policy`             | Controls scripts, styles, images, etc., prevents XSS and injection attacks |\n| `Content-Security-Policy-Report-Only` | Test-only CSP enforcement without blocking scripts                         |\n\n## **Full Example:**\n\n```ts\nimport { secureHeaders } from \"tezx/middleware\";\n\n// Use secureHeaders middleware\napp.use(\n  secureHeaders({\n    preset: \"strict\",        // strongest security\n    cspUseNonce: true,       // generate nonce per request\n    ultraFastMode: false,    // allow nonce generation\n  })\n);\n\n// Example route\napp.get(\"/\", (ctx) => {\n  // If cspUseNonce is enabled, nonce is available in ctx.cspNonce\n  const nonce = ctx.cspNonce || \"fallback-nonce\";\n  return ctx.html(`\n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\">\n        <title>Secure Headers Example</title>\n        <script nonce=\"${nonce}\">\n          console.log(\"This inline script is allowed by CSP nonce!\");\n        </script>\n      </head>\n      <body>\n        <h1>Hello Secure World!</h1>\n      </body>\n    </html>\n  `);\n});\n\n```\n\n---\n"
    },
    {
      "id": 33,
      "path": "middleware/xss-protection",
      "name": "XSS Protection",
      "folder": "Middleware",
      "content": "# 🛡️ XSS Protection Middleware (`xssProtection`)\n\nThe `xssProtection` middleware **adds HTTP headers to protect against Cross-Site Scripting (XSS) attacks**. It sets the `X-XSS-Protection` header and optionally a fallback `Content-Security-Policy` (CSP) for enhanced security.\n\nThis middleware is lightweight and ideal for **web apps, APIs, or any server-rendered content**.\n\n---\n\n## 📦 Import\n\n```ts\n// Named import\nimport { xssProtection } from \"tezx/middleware\";\n```\n\n---\n\n## ⚙️ Options\n\n```ts\nexport type XSSProtectionOptions = {\n  enabled?: boolean | ((ctx: Context) => boolean);\n  // Whether XSS protection is enabled\n  // Default: true\n  // Can also be a function to enable/disable dynamically per request\n\n  mode?: \"block\" | \"filter\";\n  // Protection mode\n  // Default: \"block\"\n  // \"block\": Prevent page rendering if XSS detected\n  // \"filter\": Attempt to sanitize content\n\n  fallbackCSP?: string;\n  // Fallback Content-Security-Policy header\n  // Default: \"default-src 'self'; script-src 'self';\"\n  // Can be customized to allow trusted CDNs or stricter policies\n};\n```\n\n---\n\n## 🧩 Behavior\n\n1. Determines if protection is **enabled**.\n\n   * Can be static (`true`/`false`) or dynamic using a callback function.\n2. Sets the `X-XSS-Protection` header:\n\n   * `1; mode=block` → blocks rendering on XSS detection.\n   * `1` → filters the XSS content without blocking.\n3. Sets a **fallback CSP header** (`Content-Security-Policy`) if none is present.\n4. Calls the **next middleware** in the chain.\n\n---\n\n## ✅ Default Usage\n\n```ts\nimport {xssProtection} from \"tezx/middleware\";\n\napp.use(xssProtection());\n```\n\n* Enables XSS protection in **block mode**.\n* Adds default fallback CSP:\n  `default-src 'self'; script-src 'self';`\n* Works for all incoming requests.\n\n---\n\n## ⚙️ Custom Configuration\n\n```ts\napp.use(\n  xssProtection({\n    mode: \"filter\", // sanitize instead of blocking\n    fallbackCSP: \"default-src 'self'; script-src 'self' https://trusted.cdn.com\",\n  })\n);\n```\n\n* Filters XSS content instead of blocking.\n* Allows scripts from trusted CDNs via CSP.\n\n---\n\n## 🔄 Dynamic Enabling per Request\n\n```ts\napp.use(\n  xssProtection({\n    enabled: (ctx) => !ctx.isAdmin, // Disable for admin routes\n  })\n);\n```\n\n* Enables XSS protection **only for non-admin routes**.\n* Dynamic decision can be based on user role, path, headers, or any context property.\n\n---\n\n## 🧩 Headers Set by Middleware\n\n| Header                    | Description                                                        |\n| ------------------------- | ------------------------------------------------------------------ |\n| `X-XSS-Protection`        | Activates browser XSS filtering (`1` or `1; mode=block`)           |\n| `Content-Security-Policy` | Fallback CSP policy if none is set, provides additional mitigation |\n\n---\n\n## 💡 Best Practices\n\n* Always enable XSS protection for **public-facing routes**.\n* Use **block mode** (`mode: \"block\"`) in production for strong security.\n* Add a **fallback CSP** to prevent script injection from untrusted sources.\n* Use **dynamic `enabled`** to disable for trusted internal routes if needed.\n* Combine with other middlewares like `cors` or `logger` for full-stack security.\n\n---\n\n## 🔧 Full Example: Web App Integration\n\n```ts\nimport xssProtection from \"tezx/middleware/xssProtection\";\nimport logger from \"tezx/middleware/logger\";\nimport cors from \"tezx/middleware/cors\";\n\napp.use(cors());\napp.use(logger());\napp.use(\n  xssProtection({\n    mode: \"block\",\n    fallbackCSP: \"default-src 'self'; script-src 'self' https://cdn.example.com\",\n    enabled: (ctx) => !ctx.user?.isAdmin, // Skip admin panel\n  })\n);\n\napp.get(\"/\", (ctx) => {\n  ctx.send(\"<h1>Hello, World!</h1>\");\n});\n```\n\n* **Public pages** have full XSS protection.\n* **Admin panel** can disable blocking for convenience.\n* CSP ensures scripts are loaded only from trusted sources.\n\n---\n"
    },
    {
      "id": 34,
      "path": "middleware/i18",
      "name": "i18",
      "folder": "Middleware",
      "content": "# 🌍 TezX i18n Middleware\n\n## Overview\n\n`i18n` middleware adds **multi-language (internationalization)** support to TezX applications.\nIt automatically detects the user's preferred language, loads translation files, caches them (in-memory or via custom adapter), and provides a simple translation function (`ctx.t`) inside every request.\n\n---\n\n## ⚙️ Basic Usage\n\n```ts\nimport { i18n } from \"tezx/middleware\";\n\napp.use(\n  i18n({\n    loadTranslations: async (lang) => import(`./locales/${lang}.json`),\n    detectLanguage: (ctx) => ctx.req.query.lang || \"en\",\n    defaultLanguage: \"en\",\n  })\n);\n```\n\nNow every request will have:\n\n```ts\nctx.t(\"greeting.hello\"); // returns \"Hello\"\nctx.t(\"user.welcome\", { name: \"Rakibul\" }); // interpolates variables\n```\n\n---\n\n## 🧠 How It Works\n\n| Step | Description                                                                |\n| ---- | -------------------------------------------------------------------------- |\n| 1️⃣  | Detects the preferred language using `detectLanguage(ctx)`                 |\n| 2️⃣  | Loads translations dynamically via `loadTranslations(language)`            |\n| 3️⃣  | Optionally caches translations in memory or a custom adapter (e.g., Redis) |\n| 4️⃣  | Attaches a translation helper (`ctx.t`) to the context                     |\n| 5️⃣  | Interpolates variables in messages like `{{name}}`                         |\n| 6️⃣  | Fallbacks to `defaultLanguage` if translation missing                      |\n\n---\n\n## 🧩 Example — Simple Setup\n\n### Directory structure\n\n```bash\n/locales\n  ├── en.json\n  └── bn.json\n```\n\n### en.json\n\n```json\n{\n  \"greeting\": {\n    \"hello\": \"Hello\",\n    \"welcome\": \"Welcome, {{name}}!\"\n  }\n}\n```\n\n### Middleware setup\n\n```ts\napp.use(\n  i18n({\n    loadTranslations: async (lang) => import(`./locales/${lang}.json`),\n    detectLanguage: (ctx) => ctx.req.query.lang || \"en\",\n    defaultLanguage: \"en\"\n  })\n);\n```\n\n### Usage in route\n\n```ts\nrouter.get(\"/hi\", (ctx) => {\n  return ctx.t(\"greeting.welcome\", { name: \"Rakibul\" });\n});\n```\n\n✅ Output:\nIf `?lang=en` → `\"Welcome, Rakibul!\"`\nIf `?lang=bn` → `\"স্বাগতম, Rakibul!\"`\n\n---\n\n## ⚡ Caching\n\nThe middleware supports **translation caching** to improve performance.\n\n### 🧠 In-memory cache (default)\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true, // enables Map-based local cache\n  })\n);\n```\n\n### 💾 External cache (Redis, Memcached, etc.)\n\nYou can implement your own cache adapter by extending `I18nCacheAdapter`.\n\n```ts\nconst redisCache = {\n  async get(lang) {\n    const data = await redis.get(`i18n:${lang}`);\n    return data ? JSON.parse(data) : null;\n  },\n  async set(lang, data) {\n    await redis.set(`i18n:${lang}`, JSON.stringify(data), \"PX\", data.expiresAt - Date.now());\n  },\n  async delete(lang) {\n    await redis.del(`i18n:${lang}`);\n  },\n};\n\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true,\n    cacheStorage: redisCache,\n  })\n);\n```\n\n---\n\n## 🧩 Options Reference (Full)\n\n| Option                       | Type                                        | Default                | Description                                                     |\n| ---------------------------- | ------------------------------------------- | ---------------------- | --------------------------------------------------------------- |\n| **`loadTranslations`**       | `(lang: string) => Promise<TranslationMap>` | —                      | Function to load translations dynamically (from JSON, DB, etc.) |\n| **`detectLanguage`**         | `(ctx: Context) => string`                  | —                      | Determines which language to use for the request                |\n| **`defaultLanguage`**        | `string`                                    | `\"en\"`                 | Fallback language if requested language unavailable             |\n| **`defaultCacheDuration`**   | `number`                                    | `3600000` (1 hour)     | How long cached translations stay valid                         |\n| **`translationFunctionKey`** | `string`                                    | `\"t\"`                  | Property name for translator function attached to `ctx`         |\n| **`formatMessage`**          | `(msg, vars) => string`                     | Interpolates `{{var}}` | Custom variable interpolation logic                             |\n| **`isCacheValid`**           | `(cached, lang) => boolean`                 | Expiry check           | Determines if cache entry is still valid                        |\n| **`cacheTranslations`**      | `boolean`                                   | `false`                | Enables or disables caching                                     |\n| **`cacheStorage`**           | `I18nCacheAdapter`                          | `null`                 | Custom cache (e.g., Redis, file system, DB)                     |\n\n---\n\n## 🧩 Example — Custom Format Function\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    formatMessage: (msg, vars) =>  msg.replace(/\\{(\\w+)\\}/g, (_, k) => vars?.[k] ?? \"\"),\n  })\n);\n```\n\n✅ `\"Hello {name}\" → \"Hello Rakibul\"`\n\n---\n\n## 🧩 Example — Custom Language Detection\n\nYou can detect language from:\n\n* Query params (`?lang=bn`)\n* Headers (`Accept-Language`)\n* Cookies (`ctx.cookies.get('lang')`)\n\n```ts\ndetectLanguage: (ctx) =>\n  ctx.req.query.lang || ctx.cookies.get(\"lang\") || ctx.req.headers[\"accept-language\"]?.split(\",\")[0] || \"en\"\n```\n\n---\n\n## 🧩 Example — File-based Cache Adapter\n\nFor servers without Redis:\n\n```ts\nimport fs from \"fs/promises\";\nimport path from \"path\";\n\nconst fileCache = {\n  async get(lang) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    try {\n      const content = JSON.parse(await fs.readFile(file, \"utf-8\"));\n      return content;\n    } catch {\n      return null;\n    }\n  },\n  async set(lang, data) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    await fs.mkdir(\"./cache\", { recursive: true });\n    await fs.writeFile(file, JSON.stringify(data), \"utf-8\");\n  },\n  async delete(lang) {\n    const file = path.join(\"./cache\", `${lang}.json`);\n    await fs.unlink(file).catch(() => {});\n  },\n};\n```\n\nThen plug it in:\n\n```ts\napp.use(\n  i18n({\n    loadTranslations,\n    detectLanguage,\n    cacheTranslations: true,\n    cacheStorage: fileCache,\n  })\n);\n```\n\n---\n\n## 🧩 Example — Custom Cache Validation\n\n```ts\nisCacheValid: (cached, lang) => {\n  // Reload if file modified recently\n  const file = `./locales/${lang}.json`;\n  const lastModified = fs.statSync(file).mtimeMs;\n  return cached.expiresAt > Date.now() && cached.expiresAt > lastModified;\n}\n```\n\n---\n\n## 🧩 Error Handling\n\nIf any error occurs during translation loading, caching, or formatting,\nthe middleware throws a structured `TezXError`:\n\n```ts\ntry {\n  await next();\n} catch (err) {\n  if (err instanceof TezXError) {\n    console.error(\"i18n failed:\", err.message);\n  }\n}\n```\n\n---\n\n## 🧩 Example — Using Translations in Templates or API\n\n```ts\nrouter.get(\"/about\", (ctx) => {\n  return {\n    title: ctx.t(\"page.about.title\"),\n    description: ctx.t(\"page.about.description\"),\n  };\n});\n```\n\n---\n"
    },
    {
      "id": 35,
      "path": "helpers/cookie",
      "name": "Cookie",
      "folder": "Helpers",
      "content": "\n# 🍪 Cookie Utilities – TezX Helper\n\nA utility module for managing HTTP cookies within TezX applications. This includes reading, setting, parsing, and deleting cookies in a type-safe and consistent manner.\n\n---\n\n## 📦 Import\n\n```ts\nimport {\n  getCookie,\n  allCookies,\n  setCookie,\n  deleteCookie,\n  serializeOptions,\n} from \"tezx/helper\";\n```\n\n---\n\n## 🧰 API Reference\n\n### 🔍 `getCookie(ctx: Context, name: string): string | undefined`\n\nRetrieve the value of a specific cookie from the incoming HTTP request.\n\n#### **Parameters for `getCookie`**\n\n* `ctx`: The request context.\n* `name`: The name of the cookie.\n\n#### **Returns**\n\n* The decoded cookie value if found, otherwise `undefined`.\n\n#### **Example**\n\n```ts\nconst session = getCookie(ctx, \"session_id\")\nif (session) {\n  console.log(\"Active session:\", session);\n}\n```\n\n---\n\n### 📋 `allCookies(ctx: Context): Record<string, string>`\n\nParse all cookies from the request and return them as an object.\n\n#### **Parameters**\n\n* `ctx`: The request context.\n\n#### **Returns**\n\n* A key-value map of all cookies.\n\n#### **Example**\n\n```ts\nconst cookies = allCookies(ctx);\nconsole.log(\"Cookies:\", cookies);\n```\n\n---\n\n### ➕ `setCookie(ctx: Context, name: string, value: string, options?: CookieOptions): void`\n\nSet a cookie on the response using optional attributes.\n\n#### **Parameters for `setCookie`**\n\n* `ctx`: The response context.\n* `name`: The name of the cookie.\n* `value`: The value to store.\n* `options` *(optional)*: Configuration like expiration, security flags, etc.\n\n#### **Example**\n\n```ts\nsetCookie(ctx, \"session_id\", \"abc123\", {\n  httpOnly: true,\n  secure: true,\n  maxAge: 3600,\n  path: \"/\",\n});\n```\n\n---\n\n### ❌ `deleteCookie(ctx: Context, name: string, options?: CookieOptions): void`\n\nDelete a cookie by expiring it immediately.\n\n#### **Parameters for `deleteCookie`**\n\n* `ctx`: The response context.\n* `name`: The cookie to remove.\n* `options` *(optional)*: Must match original cookie attributes (e.g., `path`, `domain`) to ensure deletion.\n\n#### **Example**\n\n```ts\ndeleteCookie(ctx, \"session_id\", { path: \"/\" });\n```\n\n---\n\n### 🛠️ `serializeOptions(options: CookieOptions): string`\n\nSerialize a cookie options object into a valid `Set-Cookie` string fragment.\n\n> Used internally, but available for custom header construction if needed.\n\n#### **Parameters for `serializeOptions`**\n\n* `options`: An object describing cookie settings.\n\n#### **Returns**\n\n* A string representation suitable for HTTP headers.\n\n#### **Example**\n\n```ts\nconst header = serializeOptions({ maxAge: 3600, httpOnly: true });\n// Output: \"Max-Age=3600; HttpOnly\"\n```\n\n---\n\n## 📑 `CookieOptions` Interface\n\nUse this interface to configure cookie behavior:\n\n| Property   | Type                              | Description                                              |\n| ---------- | --------------------------------- | -------------------------------------------------------- |\n| `maxAge`   | `number`                          | Lifetime of the cookie (in seconds).                     |\n| `expires`  | `Date`                            | Absolute expiry timestamp.                               |\n| `path`     | `string`                          | Path scope of the cookie.                                |\n| `domain`   | `string`                          | Domain scope of the cookie.                              |\n| `secure`   | `boolean`                         | Send only over HTTPS.                                    |\n| `httpOnly` | `boolean`                         | Restrict access from JavaScript.                         |\n| `sameSite` | `'Strict'` \\| `'Lax'` \\| `'None'` | Restrict cross-site cookie behavior for CSRF protection. |\n\n---\n\n## ✅ Best Practices\n\n* Always use `httpOnly` and `secure` for sensitive cookies.\n* Use `path` and `domain` to avoid scope conflicts.\n* Set `sameSite: 'Strict'` or `'Lax'` for CSRF mitigation.\n* Call `deleteCookie()` with matching `path` and `domain` for successful removal.\n\n---\n"
    },
    {
      "id": 36,
      "path": "helpers/useformdata",
      "name": "useFormData",
      "folder": "Helpers",
      "content": "\n# 🚀 `useFormData` — Multipart Form & File Upload Handler\n\n`useFormData` is a powerful helper designed for efficient parsing, validation, and management of **multipart/form-data** HTTP requests in TezX applications. It simplifies handling complex file uploads combined with form fields while enforcing strict limits to protect your server from overload and security risks.\n\n```mermaid\nsequenceDiagram\n  participant Client\n  participant TezX\n  participant useFormData\n  participant Validators\n  participant FileProcessor\n\n\n  Client->>TezX: POST /upload (multipart/form-data)\n  TezX->>useFormData: useFormData(ctx, options)\n  useFormData->>Validators: Validate text fields & limits\n  useFormData->>FileProcessor: Validate & process files\n  FileProcessor-->>useFormData: processed files\n  Validators-->>useFormData: validated text fields\n  useFormData-->>TezX: { fieldName: value | File | Array }\n  TezX-->>Client: response\n```\n\n---\n\n## 🔧 Function Signature\n\n```ts\nimport { Context,FormDataOptions } from \"tezx\";\n\nexport async function useFormData(\n  ctx: Context,\n  options?: FormDataOptions\n): Promise<Record<string, string | File | (string | File)[]>>;\n```\n\n---\n\n## 🔥 Core Features\n\n* **Full multipart/form-data parsing** for text fields and file uploads\n* **Automatic merging** of repeated fields into arrays\n* **File validation:**\n\n  * MIME type whitelist\n  * Max file size per file\n  * Max number of files per field\n  * Max total upload size (combined all files)\n* **Text field validation:**\n\n  * Max size per text field (bytes/characters)\n  * Optional sanitization (trimming, escaping)\n* **Streaming-aware file processing** for large uploads (configurable)\n* Detailed **error handling** with descriptive messages\n* Easily **extensible** to add custom file processors or virus scanners\n\n---\n\n## 🔹 Parameters\n\n| Name      | Type              | Description                                                         |\n| --------- | ----------------- | ------------------------------------------------------------------- |\n| `ctx`     | `Context`         | TezX request context with the incoming multipart HTTP request       |\n| `options` | `FormDataOptions` | Optional configuration object to control validations and processing |\n\n---\n\n## 🔸 Returns\n\nPromise resolving to an object mapping field names to:\n\n* **string** — for text form fields\n* **File** — for single uploaded files\n* **Array\\<string | File>** — for repeated fields (multiple values/files)\n\n---\n\n## ⚙️ FormDataOptions Interface\n\n| Property       | Type       | Description                                                                     |\n| -------------- | ---------- | ------------------------------------------------------------------------------- |\n| `sanitized`    | `boolean`  | Enables sanitization of text inputs (trimming, escaping, etc.)                  |\n| `allowedTypes` | `string[]` | MIME types allowed for file uploads (e.g., `[\"image/jpeg\", \"application/pdf\"]`) |\n| `maxSize`      | `number`   | Maximum size (in bytes) allowed per individual file                             |\n| `maxFiles`     | `number`   | Maximum number of files accepted per single field                               |\n| `maxTotalSize` | `number`   | Maximum combined size (in bytes) allowed for all files in the request           |\n| `maxFieldSize` | `number`   | Maximum allowed length (characters or bytes) for text fields                    |\n\n---\n\n## 🔍 Detailed Behavior\n\n### 1. **Multipart Form Parsing**\n\nThe function calls `ctx.req.formData()` internally to parse the multipart form. It then iterates over all fields and files, applying the configured validations.\n\n### 2. **File Handling**\n\n* **File Size:** Each file is checked against the `maxSize` option. Files exceeding this size are rejected immediately.\n* **File Count:** Enforces a strict maximum number of files per field via `maxFiles`.\n* **MIME Type Validation:** If `allowedTypes` is specified, files not matching allowed MIME types are rejected.\n* **Total Upload Size:** Keeps a running total of all uploaded file bytes and throws if the `maxTotalSize` is exceeded.\n* **Extensible Processing:** Internally calls a customizable `processFile` function for potential streaming, virus scanning, or on-the-fly compression.\n\n### 3. **Text Field Handling**\n\n* Checks each string field against `maxFieldSize` for length.\n* Optionally sanitizes text fields when `sanitized` is enabled (trimming whitespace, escaping dangerous chars).\n\n### 4. **Duplicate Field Names**\n\nFields with the same name are grouped into arrays, supporting inputs like:\n\n```html\n<input type=\"file\" name=\"photos\" multiple>\n<input type=\"text\" name=\"tags\">\n<input type=\"text\" name=\"tags\">\n```\n\n---\n\n## 🛡️ Error Handling & Security\n\n* Throws clear, actionable errors on exceeding any configured limits (size, count, type).\n* Prevents large unexpected uploads from exhausting memory or disk space.\n* Supports input sanitization to prevent injection or XSS attacks from text fields.\n* Encourages defining strict `allowedTypes` and `maxSize` to avoid malicious uploads.\n\n---\n\n## ⚡ Example Usage (Robust File Upload)\n\n```ts\nimport { useFormData } from \"tezx/helper\";\n\nasync function uploadHandler(ctx: Context) {\n  try {\n    const form = await useFormData(ctx, {\n      allowedTypes: [\"image/jpeg\", \"image/png\", \"application/pdf\"],\n      maxSize: 10 * 1024 * 1024,       // 10MB max per file\n      maxFiles: 5,                     // Max 5 files per field\n      maxTotalSize: 50 * 1024 * 1024, // 50MB combined limit\n      maxFieldSize: 2000,              // Max 2000 chars for text fields\n      sanitized: true,                 // Trim & sanitize text inputs\n    });\n\n    // Access text fields and files\n    const username = form[\"username\"];\n    const profilePics = form[\"photos\"]; // Array of File objects\n\n    // Process or store files\n    for (const file of Array.isArray(profilePics) ? profilePics : [profilePics]) {\n      // e.g. save to disk, cloud storage, virus scan, etc.\n      console.log(`Uploading file: ${file.name} (${file.size} bytes)`);\n    }\n\n    return ctx.text(\"Upload successful!\");\n  } catch (err) {\n    // Handle validation errors\n    return ctx.status(400).text(err.message);\n  }\n}\n```\n\n---\n"
    },
    {
      "id": 37,
      "path": "helpers/load-environment",
      "name": "Load Environment",
      "folder": "Helpers",
      "content": "\n---\n\n# `loadEnv(basePath?: string)`\n\n**Purpose:** Load `.env` files into `process.env` (Node/Bun) or `Deno.env` and get a **typed object** for safe access.\n\n**Supported `.env` Files (Priority):**\n\n```bash\n.env → .env.local → .env.[mode] → .env.[mode].local\n```\n\n**Return Type:**\n\n```ts\ntype EnvVariables = {\n  [key: string]: string;\n  NODE_ENV: \"development\" | \"production\" | \"test\";\n};\n```\n\n**Usage:**\n\n```ts\nimport { loadEnv } from \"tezx/node\"; // or \"tezx/bun\", \"tezx/deno\"\n\nconst env = loadEnv(\"./config\");\nconst port = env.PORT || process.env.PORT || \"3000\";\n```\n\n---\n\n# Custom Context\n\n**Purpose:** Extend TezX’s `Context` with your own properties (e.g., user info, request metadata).\n\n**Example:**\n\n```ts\ninterface CustomContext {\n  user?: { id: string; roles: string[] };\n  requestId: string;\n}\n\napp.use(async (ctx, next) => {\n  ctx.requestId = crypto.randomUUID();\n  ctx.user = await authenticate(ctx.headers.get(\"Authorization\"));\n  return next();\n});\n\napp.get(\"/me\", (ctx) => ctx.json(ctx.user));\n```\n\n---\n\n# Server Initialization with Env & Custom Context\n\n```ts\nconst env = loadEnv();\n\nconst app = new TezX<CustomContext>({ env });\n\napp.use((ctx) => {\n  if (ctx.env.API_KEY !== \"expected\") return ctx.status(401).text(\"Unauthorized\");\n});\n```\n\n**Options Table:**\n\n| Option | Type           | Description                    |\n| ------ | -------------- | ------------------------------ |\n| `env`  | `EnvVariables` | Injected environment variables |\n\nAccess via `ctx.env` safely in middleware/routes.\n\n---\n\n# Best Practices\n\n* **.env per mode:**\n\n```bash\n.env.development\n.env.production\n.env.production.local\n```\n\n* **Git ignore sensitive files:**\n\n```bash\n.env.local\n.env.*.local\n```\n\n* **Feature flags:**\n\n```ts\nif (env.FEATURE_X === \"enabled\") enableExperimentalFeature();\n```\n\n---\n\n# Advanced Context Usage\n\n```ts\ninterface AppContext {\n  user?: User;\n  analytics: Tracker;\n}\n\napp.use((ctx, next) => {\n  ctx.analytics = new Tracker(ctx.env.TRACKING_ID);\n  return next();\n});\n```\n\n---\n"
    },
    {
      "id": 38,
      "path": "helpers/jwt",
      "name": "JWT",
      "folder": "Helpers",
      "content": "# TezX JWT Module – Developer Documentation\n\n## Overview\n\n`tezx/jwt` is a **lightweight, dependency-free JSON Web Token (JWT) module** designed for the TezX framework. It provides **signing, verification, and expiration management** for JWTs using either:\n\n- **Node.js crypto** (for server-side)\n- **WebCrypto API** (for modern runtimes: browser, Deno, Bun)\n\nKey Features:\n\n- ✅ Pure implementation (no external dependencies)\n- ⚡ Supports `HS256` and `HS512` algorithms\n- ⏱ Flexible expiration format (`\"1h\"`, `\"2d\"`, `\"30m\"`, numeric seconds)\n- 🔒 Safe Base64URL encoding/decoding (RFC 7515)\n- 🧩 Works in **Node.js**, **Bun**, **Deno**, or TezX server environment\n- 📦 Easy to integrate as a middleware or standalone utility\n\n---\n\n## Installation\n\n```bash\n# if using npm/yarn\nnpm install tezx\n# or\nyarn add tezx\n```\n\n---\n\n## Importing\n\n```ts\nimport { sign, verify } from \"tezx/jwt/web\"; // For WebCrypto-compatible runtimes\n// or\nimport { sign, verify } from \"tezx/jwt/node\"; // Node.js-compatible\n```\n\n- `sign` – generate JWT token\n- `verify` – decode & verify JWT token\n\n---\n\n## Functions\n\n### 1. `sign(payload, options)`\n\nGenerates a signed JWT token.\n\n**Parameters**:\n\n| Parameter           | Type                  | Description                                                                         |                                          |\n| ------------------- | --------------------- | ----------------------------------------------------------------------------------- | ---------------------------------------- |\n| `payload`           | `Record<string, any>` | The data or claims to include in the token                                          |                                          |\n| `options`           | `Object`              | Optional configuration                                                              |                                          |\n| `options.secret`    | `string`              | Secret key to sign the token (default: `process.env.JWT_SECRET` or `\"tezx_secret\"`) |                                          |\n| `options.algorithm` | `\"HS256\"              | \"HS512\"`                                                                            | Hash algorithm to use (default: `HS256`) |\n| `options.expiresIn` | `string \\| number`    | Token expiration, e.g., `\"2h\"`, `\"7d\"`, `3600` (seconds)                            |                                          |\n\n**Returns**: `string` – signed JWT token in format `header.payload.signature`\n\n**Example**:\n\n```ts\nimport { sign } from \"tezx/jwt/node\";\n\nconst token = sign(\n  { userId: 101, role: \"trainer\" },\n  { secret: \"5435345\", algorithm: \"HS512\", expiresIn: \"2h\" },\n);\n\nconsole.log(\"JWT:\", token);\n```\n\n> ⚡ **WebCrypto version** returns a `Promise<string>`.\n\n---\n\n### 2. `verify(token, secret)`\n\nVerifies a JWT token and returns the payload if valid.\n\n**Parameters**:\n\n| Parameter | Type     | Description                                                                              |\n| --------- | -------- | ---------------------------------------------------------------------------------------- |\n| `token`   | `string` | The JWT string to verify                                                                 |\n| `secret`  | `string` | Secret key used to sign the token (default: `process.env.JWT_SECRET` or `\"tezx_secret\"`) |\n\n**Returns**:\n\n- `Record<string, any>` – decoded payload if token is valid and not expired\n- `null` – if invalid or expired\n\n**Example**:\n\n```ts\nimport { verify } from \"tezx/jwt/node\";\n\nconst decoded = verify(token, \"5435345\");\n\nif (decoded) {\n  console.log(\"User ID:\", decoded.userId);\n} else {\n  console.log(\"Invalid or expired token\");\n}\n```\n\n> ⚡ **WebCrypto version** returns `Promise<Record<string, any> | null>`.\n\n---\n\n## Base64URL Encoding (internal)\n\nThe module automatically encodes and decodes JWT parts using **Base64URL**:\n\n```ts\nimport { sign } from \"tezx/jwt/node\";\n\nconst token = sign({ userId: 1 });\n// Base64URL ensures URL-safe JWT with no padding\n```\n\n> Do **not manually modify** JWT parts unless you follow RFC 7515 rules.\n\n---\n\n## Expiration Handling\n\n- Human-readable string formats:\n  - `\"30m\"` → 30 minutes\n  - `\"2h\"` → 2 hours\n  - `\"1d\"` → 1 day\n\n- Numeric seconds: `3600` → 1 hour\n- Default expiration is **1 day** if not provided\n\n```ts\nconst token = sign({ userId: 1 }, { expiresIn: \"2h\" });\n```\n\n---\n\n## TezX Middleware Example\n\nYou can create a middleware for protected routes:\n\n```ts\nimport { verify } from \"tezx/jwt/node\";\n\nexport function jwtMiddleware({ secret }) {\n  return async (ctx, next) => {\n    const auth = ctx.headers.get(\"authorization\") || \"\";\n    const token = auth.startsWith(\"Bearer \") ? auth.slice(7) : null;\n\n    if (!token) return ctx.status(401).json({ error: \"Missing token\" });\n\n    const payload = verify(token, secret);\n    if (!payload)\n      return ctx.status(401).json({ error: \"Invalid or expired token\" });\n\n    ctx.user = payload; // inject payload into context\n    await next();\n  };\n}\n```\n\n**Usage**:\n\n```ts\nimport { jwtMiddleware } from \"./middleware\";\n\napp.use(jwtMiddleware({ secret: \"5435345\" }));\n\napp.get(\"/dashboard\", async (ctx) => {\n  console.log(ctx.user); // access decoded JWT\n  return ctx.json({ message: \"Welcome to dashboard\" });\n});\n```\n\n---\n"
    },
    {
      "id": 39,
      "path": "websocket",
      "name": "WebSocket",
      "folder": ".",
      "content": "# 🔌 `upgradeWebSocket` Middleware\n\nEnable **WebSocket support** across **Node.js**, **Deno**, and **Bun** with runtime-specific optimizations.\n\n---\n\n## Prerequisites\n\n| Runtime | Support | Notes                            |\n| ------- | ------- | -------------------------------- |\n| Node.js | ✅ Yes   | Requires `ws` (`npm install ws`) |\n| Deno    | ✅ Yes   | Native                           |\n| Bun     | ✅ Yes   | Native                           |\n\n---\n\n## Import\n\n```ts\n// Node.js\nimport { upgradeWebSocket } from \"tezx/node\";\n// Deno\nimport { upgradeWebSocket } from \"tezx/deno\";\n// Bun\nimport { upgradeWebSocket } from \"tezx/bun\";\n```\n\n---\n\n## Types\n\n```ts\ntype WebSocketEvent = {\n  open?: (ws: WebSocket, ctx?: Context) => void;\n  message?: (ws: WebSocket, data: string | Buffer | ArrayBuffer) => void;\n  close?: (ws: WebSocket, info: { code: number; reason: string }) => void;\n  error?: (ws: WebSocket, err: Error | any) => void;\n  ping?: (ws: WebSocket, data: Buffer) => void;\n  pong?: (ws: WebSocket, data: Buffer) => void;\n  drain?: (ws: WebSocket) => void;\n};\ntype WebSocketCallback = (ctx: Context) => WebSocketEvent;\ntype WebSocketOptions = {\n  onUpgradeError?: (err: Error, ctx: Context) => HttpBaseResponse;\n};\n```\n\n---\n\n## Basic Usage\n\n```ts\napp.use(\n  \"/chat\",\n  upgradeWebSocket((ctx) => ({\n    open(ws) { console.log(\"Connected\"); },\n    message(ws, data) { ws.send(`Echo: ${data}`); },\n    close(ws, { code, reason }) { console.log(\"Closed\", code, reason); },\n    error(ws, err) { console.error(err); },\n  }))\n);\n```\n\n---\n\n## Runtime Setup\n\n### Node.js\n\n```ts\nimport { createServer } from \"http\";\nimport { upgradeWebSocket, mountTezXOnNode } from \"tezx/node\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open: ws => console.log(\"Node client connected\"),\n  message: (ws, msg) => ws.send(\"Node: \" + msg),\n})));\n\nconst server = createServer();\nmountTezXOnNode(app, server);\nserver.listen(3000);\n```\n\n### Deno\n\n```ts\nimport { upgradeWebSocket } from \"tezx/deno\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open(ws) { console.log(\"Deno connected\"); },\n  message(ws, msg) { ws.send(\"Deno: \" + msg); },\n})));\n\nDeno.serve({ port: 3000 }, app.serve);\n```\n\n### Bun\n\n```ts\nimport { upgradeWebSocket, wsHandlers } from \"tezx/bun\";\n\napp.use(\"/chat\", upgradeWebSocket(ctx => ({\n  open(ws) { console.log(\"Bun connected\"); },\n  message(ws, msg) { ws.send(\"Bun: \" + msg); },\n})));\n\nBun.serve({ port: 3000, fetch: app.serve, websocket: wsHandlers() });\n```\n\n---\n\n## Upgrade Error Handling\n\n```ts\nupgradeWebSocket(callback, {\n  onUpgradeError: (err, ctx) => ctx.text(\"Upgrade failed: \" + err.message, 400),\n});\n```\n\n---\n\n## Advanced Events\n\n```ts\nmessage(ws, data) { ws.send(\"Hello\"); },\nping(ws, buffer) { console.log(\"Ping:\", buffer); },\npong(ws, buffer) { console.log(\"Pong:\", buffer); },\ndrain(ws) { console.log(\"Backpressure relieved\"); }\n```\n\n---\n\n## Runtime Features Matrix\n\n| Feature         | Node.js | Deno  | Bun   |\n| --------------- | ------- | ----- | ----- |\n| Native Upgrade  | ❌ `ws`  | ✅ Yes | ✅ Yes |\n| `ping` / `pong` | ✅       | ❌     | ✅     |\n| `drain`         | ❌       | ❌     | ✅     |\n| Compression     | ✅       | ❌     | ❌     |\n\n---\n"
    },
    {
      "id": 40,
      "path": "static-file",
      "name": "Static File",
      "folder": ".",
      "content": "# 📦 Static File\n\nServe static files (HTML, CSS, JS, images, JSON, etc.) via specific routes using `serveStatic`.\n\n**Supported Platforms:** `tezx/bun`, `tezx/node`, `tezx/deno`\n\n---\n\n## ✅ Import\n\n```ts\n// Bun\nimport { serveStatic } from \"tezx/bun\";\n// Node.js\nimport { serveStatic } from \"tezx/node\";\n// Deno\nimport { serveStatic } from \"tezx/deno\";\n```\n\n---\n\n## 📘 Usage\n\n```ts\napp.static(serveStatic(config));\n```\n\n### Parameters\n\n* **config**: `ServeStatic` — configuration object with files and optional options like headers, cache, and allowed extensions.\n\n---\n\n## 📄 Types\n\n```ts\ntype StaticFileArray = {\n  fileSource: string;  // Absolute path on disk\n  route: string;       // Public URL path\n}[];\n\ntype StaticServeOption = {\n  cacheControl?: string;                 // Cache-Control header\n  headers?: Record<string, string>;     // Custom headers\n  extensions?: string[];                // Allowed file extensions\n};\n\ntype ServeStatic = {\n  files: StaticFileArray;\n  options?: StaticServeOption;\n};\n```\n\n---\n\n## 🧪 Examples\n\n### Bun\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/bun\";\n\nconst app = new TezX();\n\napp.static(serveStatic('/', './public', {\n  extensions: ['html', 'css', 'js'],\n  cacheControl: 'max-age=86400',\n  headers: { 'X-Static-Served-By': 'TezX-Bun' }\n}));\n```\n\n### Node.js\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/node\";\n\napp.static(serveStatic('/', './static-files', {\n  extensions: ['json'],\n  headers: { 'X-Content-Type': 'application/json' }\n}));\n```\n\n### Deno\n\n```ts\nimport { TezX } from \"tezx\";\nimport { serveStatic } from \"tezx/deno\";\n\napp.static(serveStatic('/', './assets', {\n  extensions: ['png', 'jpg'],\n  cacheControl: 'public, max-age=7200'\n}));\n```\n\n---\n\n## 📂 Folder Example\n\n```\nmy-app/\n├── public/\n│   ├── index.html\n│   ├── style.css\n│   └── script.js\n└── server.ts\n```\n\n---\n\n## 📝 Summary\n\n| Feature             | Description                                     |\n| ------------------- | ----------------------------------------------- |\n| 🔍 Extension filter | Serve only allowed file types                   |\n| 🗂️ Route mapping   | Map files to custom URL routes                  |\n| 🧠 Headers          | Add custom headers like `Cache-Control`, `ETag` |\n| ⚡ Performance       | Fast static file serving                        |\n| ✅ Multi-env support | Works with Bun, Node.js, Deno                   |\n\n---\n\n## 🚀 Tips\n\n* Validate folder paths — `serveStatic()` resolves them internally.\n* Use extension filters to prevent accidental exposure of sensitive files.\n* Combine `static()` with dynamic routes for hybrid apps.\n\n---\n\n💡 **Reference:** [MDN – Cache-Control Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)\n\n---\n"
    },
    {
      "id": 41,
      "path": "toolkit/middlewares/github-oauth2",
      "name": "Github Oauth2",
      "folder": "Toolkit/Middlewares",
      "content": "\n# 📦 `@tezx/github-oauth2`\n\nGitHub OAuth2.0 middleware for the [TezX](https://github.com/tezxjs/TezX) web framework. Securely authenticate users via GitHub, and define custom sign-in, session, and token handling logic.\n\n---\n\n## ✅ Setup GitHub OAuth App\n\nGo to: [https://github.com/settings/developers](https://github.com/settings/developers)\n\n1. Click **\"New OAuth App\"**\n2. Name: `My GitHub Login App`\n3. Homepage URL: `http://localhost:3000`\n4. Authorization callback URL: `http://localhost:3000/auth/github/callback`\n5. Save and copy `Client ID` and `Client Secret`\n\n## 📥 Installation\n\n```bash\nnpm install @tezx/github-oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx@latest github-auth -- --template github-oauth2 --y\n```\n\n---\n\n## 📄 Example Usage\n\n```ts\nimport { TezX } from 'tezx';\nimport {\n  GitHubOauthClient,\n  getGithubOAuthURL,\n  verifyGithubToken\n} from '@tezx/github-oauth2';\n\nconst app = new TezX({\n  debugMode: true\n});\n\n// Initialize OAuth client\nconst client = GitHubOauthClient({\n  clientId: process.env.GITHUB_CLIENT_ID!,\n  clientSecret: process.env.GITHUB_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000'\n});\n\n// Step 1: Redirect user to GitHub login\napp.get('github', getGithubOAuthURL({\n  authClient: client,\n}), (ctx) => {\n  return ctx.redirect(ctx.github.oauth_url);\n});\n\n// Step 2: Verify GitHub token and handle user session\napp.get('/', verifyGithubToken({\n  authClient: client,\n  Callbacks: (ctx) => {\n    return {\n      session: async (session, user) => {\n        console.log('Session:', session);\n        console.log('User:', user);\n        return session;\n      }\n    };\n  }\n}), async (ctx) => {\n  return ctx.json({ success: ctx.github.user });\n});\n```\n\n---\n\n## 🧩 API Reference\n\n### `GitHubOauthClient(config: GithubOauthClient): GitHubAuthClient`\n\nCreates an OAuth client instance.\n\n#### Parameters\n\n| Name         | Type   | Description                    |\n| ------------ | ------ | ------------------------------ |\n| clientId     | string | GitHub OAuth App client ID     |\n| clientSecret | string | GitHub OAuth App client secret |\n| redirectUri  | string | URI GitHub should redirect to  |\n\n---\n\n### `getGithubOAuthURL(options: OAuthURLParams)`\n\nGenerates the GitHub OAuth URL and stores it in `ctx.github.oauth_url`.\n\n#### Parameters\n\n| Name        | Type              | Description                                                      |\n| ----------- | ----------------- | ---------------------------------------------------------------- |\n| authClient  | GitHubOauthClient | The OAuth client instance                                        |\n| scopes      | string\\[]         | (Optional) OAuth scopes (default: `['read:user', 'user:email']`) |\n| state       | string            | (Optional) CSRF protection state value                           |\n| allowSignup | boolean           | (Optional) Allow GitHub signups (default: true)                  |\n\n---\n\n### `verifyGithubToken(options: { authClient: GitHubOauthClient, Callbacks: Callbacks })`\n\nMiddleware to validate the token returned from GitHub and handle user info.\n\n#### Parameters\n\n| Name       | Type                       | Description                  |\n| ---------- | -------------------------- | ---------------------------- |\n| authClient | GitHubOauthClient          | The initialized OAuth client |\n| Callbacks  | `(ctx) => CallbacksReturn` | Optional lifecycle methods   |\n\n---\n\n### 🌀 `CallbacksReturn`\n\n| Method                   | Description                                                       |\n| ------------------------ | ----------------------------------------------------------------- |\n| `signIn(user)`           | Called after user is authenticated. Return `true` to allow login. |\n| `jwt(token, user?)`      | Customize JWT token if applicable.                                |\n| `session(session, user)` | Customize the session object before sending to client.            |\n\n---\n"
    },
    {
      "id": 42,
      "path": "toolkit/middlewares/google-oauth2",
      "name": "Google Oauth2",
      "folder": "Toolkit/Middlewares",
      "content": "\n## @tezx/google-oauth2\n\n### **Documentation**\n\n<https://developers.google.com/identity/protocols/oauth2>\n\n### **Configuration**\n\n<https://console.developers.google.com/apis/credentials>\n\nProvides:\n\n* **OAuth2 client initialization**\n* **Auth URL generation**\n* **Token verification middleware**\n* **Full TypeScript support** with JSDoc annotations\n\n---\n\n### 🔧 Installation\n\n```bash\nnpm install @tezx/google-oauth2 @googleapis/oauth2\n```\n\nOr with Yarn:\n\n```bash\nyarn add @tezx/google-oauth2 @googleapis/oauth2\n```\n\n#### **Template**\n\n```bash\nnpm create tezx@latest google-auth -- --template google-oauth2 --y\n```\n\n---\n\n### 🚀 Quick Start\n\n```ts\nimport { TezX } from 'tezx';\nimport { GoogleOauthClient, getGoogleOAuthURL, verifyGoogleToken } from '@tezx/google-oauth2';\n\nconst app = new TezX({\n  debugMode: true,\n});\n\n// 1. Initialize OAuth2 client\nconst client = GoogleOauthClient({\n  clientId: process.env.GOOGLE_CLIENT_ID!,\n  clientSecret: process.env.GOOGLE_CLIENT_SECRET!,\n  redirectUri: 'http://localhost:3000/auth/callback',\n});\n\n// 2. Route to start Google login\napp.get('/auth/google', getGoogleOAuthURL({\n  authClient: client,\n  scopes: ['openid','email','profile'],\n}), (ctx) => {\n  return ctx.redirect(ctx.google?.oauth_url);\n});\n\n// 3. Callback route, verify token and establish session\napp.get('/auth/callback', verifyGoogleToken({\n  authClient: client,\n  onError: (err) => {\n    console.error('OAuth Error:', err);\n    // handle error or redirect\n  },\n  onSuccess: (tokens) => {\n    console.log('Tokens:', tokens);\n  },\n  Callbacks: (ctx)=> {\n    return {\n    signIn: async (user) => {\n      // e.g. allow only users from a domain\n      return user.email.endsWith('@yourcompany.com');\n    },\n    jwt: async (token, user) => {\n      // attach roles or custom claims\n      token.role = user.email_verified ? 'member' : 'guest';\n      return token;\n    },\n    session: async (session, user) => {\n      // persist user profile in session\n      session.user = {\n        id: user.sub,\n        email: user.email,\n        name: user.name,\n        picture: user.picture\n      };\n      return session;\n    }\n  }\n  } \n}), async (ctx) => {\n  // Now ctx.session is populated\n  return ctx.json({ success: true });\n});\n\n```\n\n---\n\n## 📚 API Reference\n\n### `GoogleOauthClient(config) → OAuth2Client`\n\nCreate a configured Google OAuth2 client.\n\n```ts\nimport type { OAuth2Client } from 'google-auth-library';\n\ninterface GoogleOauthConfig {\n  clientId: string;\n  clientSecret: string;\n  redirectUri: string;\n}\n\n/**\n * @param config.clientId     Google OAuth Client ID.\n * @param config.clientSecret Google OAuth Client Secret.\n * @param config.redirectUri  Registered redirect URI.\n * @returns OAuth2Client\n */\nexport function GoogleOauthClient(config: GoogleOauthConfig): OAuth2Client;\n```\n\n---\n\n### `getGoogleOAuthURL(params) → Middleware`\n\nGenerate and store the Google authentication URL in `ctx.google?.oauth_url`.\n\n```ts\ninterface OAuthURLParams {\n  authClient: OAuth2Client;\n  scopes?: string[];               // default ['openid','email','profile']\n  loginHint?: string;              // optional, e.g. user email\n  prompt?: string;                 // default 'consent select_account'\n  accessType?: 'online'|'offline'; // default 'offline'\n  includeGrantedScopes?: boolean;  // default true\n}\n\n/**\n * Middleware that adds `state` header, generates auth URL, and redirects.\n * On success: ctx.google?.oauth_url contains the URL.\n */\nexport function getGoogleOAuthURL(params: OAuthURLParams): Middleware<any>;\n```\n\n---\n\n### `verifyGoogleToken(params) → Middleware`\n\nValidate the OAuth callback, exchange the code, verify ID token, and invoke your callbacks.\n\n```ts\nexport type CallbacksReturn = {\n    /**\n     * Callback function called when a user signs in successfully.\n     * \n     * @param {User} user - The user object containing user details such as email, name, etc.\n     * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating whether the sign-in is allowed. \n     *         If `false`, the sign-in will be rejected; if `true`, the sign-in will proceed.\n     * \n     * @example\n     * const callbacks = {\n     *     signIn: async (user) => {\n     *         // Check if the user is allowed to sign in\n     *         return user.email.endsWith('@example.com');\n     *     }\n     * };\n     */\n    signIn?: (user: User) => Promise<boolean>;\n\n    /**\n     * Callback function for handling JWT (JSON Web Token) creation or modification.\n     * \n     * @param {any} token - The token object that contains the user's authentication information.\n     * @param {User} [user] - The user object, which may be available depending on the context.\n     * @returns {Promise<any>} - A promise that resolves to a possibly modified token or additional data to be included with the token.\n     * \n     * @example\n     * const callbacks = {\n     *     jwt: async (token, user) => {\n     *         // Add custom data to the token, like user role\n     *         token.role = user?.role || 'guest';\n     *         return token;\n     *     }\n     * };\n     */\n    jwt?: (token: any, user?: User) => Promise<any>;\n\n    /**\n     * Callback function for handling user session management.\n     * \n     * @param {any} session - The session object containing session data.\n     * @param {User} user - The user object containing the authenticated user's information.\n     * @returns {Promise<any>} - A promise that resolves to the modified session data or a session object.\n     * \n     * @example\n     * const callbacks = {\n     *     session: async (session, user) => {\n     *         // Modify session object, e.g., store user roles or permissions in the session\n     *         session.userRole = user?.role || 'guest';\n     *         return session;\n     *     }\n     * };\n     */\n    session?: (session: any, user: User) => Promise<any>;\n};\n\nexport type Callbacks = (ctx: Context) => CallbacksReturn;\n\ninterface VerifyParams {\n  authClient: OAuth2Client;\n  onError?: (error: string) => void;\n  onSuccess?: (tokens: any, response: any) => void;\n  Callbacks: Callbacks;\n}\n\n/**\n * Middleware that:\n * 1. Exchanges `code` for tokens  \n * 2. Validates `id_token` audience  \n * 3. Executes `signIn`, `jwt`, `session` callbacks  \n * 4. Calls onSuccess or onError  \n */\nexport function verifyGoogleToken(params: VerifyParams): Middleware<any>;\n```\n\n---\n\n### 🎓 `User` & `Credentials` Types\n\n```ts\n/** Google user info returned by tokeninfo endpoint */\nexport type GoogleUser = {\n    iss: string;\n    azp: string;\n    aud: string;\n    sub: string;\n    email: string;\n    email_verified: string;\n    at_hash: string;\n    name: string;\n    picture: string;\n    given_name: string;\n    family_name: string;\n    iat: string;\n    exp: string;\n    alg: string;\n    kid: string;\n    typ: string;\n  // ...other standard claims\n};\n\n/** OAuth2 token set returned by getToken() */\nexport interface Credentials {\n  access_token?: string;\n  refresh_token?: string;\n  expiry_date?: number;\n  id_token?: string;\n  token_type?: string;\n  scope?: string;\n}\n```\n\n---\n\n## 🛡 Security & Best Practices\n\n* **State parameter**: Mitigate CSRF by using `state`.\n* **Prompt & access\\_type**: Use `offline` + `prompt='consent'` to receive refresh tokens.\n* **Scope minimization**: Request only the scopes you need.\n* **Token handling**: Securely store `refresh_token` if you need long‑lived access.\n\n---\n"
    },
    {
      "id": 43,
      "path": "toolkit/middlewares/tezx-profiler",
      "name": "Tezx profiler",
      "folder": "Toolkit/Middlewares",
      "content": "# @tezx/profiler\n\nA lightweight, extensible profiling middleware for the [TezX](https://www.npmjs.com/package/tezx) framework. This module enables detailed tracking of runtime performance metrics, memory usage, CPU statistics, and supports custom plugins and rotating file storage.\n\n---\n\n## 🚀 Features\n\n- ⏱️ Measure route execution time.\n- 💾 Monitor memory usage in MB.\n- ⚙️ Capture CPU usage in milliseconds.\n- 📊 System stats endpoint (`/__profiler`) with a clean UI.\n- 🔌 Plugin hooks (`beforeProfile`, `afterProfile`).\n- 📁 Rotating file storage for logs.\n- ✅ Written in TypeScript with full type safety.\n- 🌍 Supports Node.js, Deno, and Bun environments.\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/profiler\n```\n\n---\n\n## 🛠️ Usage Example\n\n### Basic Setup\n\n```ts\nimport { TezX } from 'tezx';\nimport { profiler, createRotatingFileStorage } from '@tezx/profiler';\n\nconst app =new TezX();\n\napp.use(\n  profiler({\n    route: '/__profiler',\n    excludePaths: ['/favicon.ico'],\n    metrics: ['time', 'memory', 'cpu'],\n    storage: createRotatingFileStorage('./profiler.log', 1024 * 1024), // Rotate every 1MB\n    plugins: [],\n  })\n);\n\napp.get('/', (ctx) => ctx.json({ message: 'Hello World' }));\n\n```\n\n---\n\n## 🌐 Profiler UI\n\nVisit your app at:\n\n```bash\nhttp://localhost:3000/__profiler\n```\n\nYou'll see:\n\n- ✅ Uptime (seconds)\n- ✅ Timestamp\n- ✅ Memory Usage (rss, heapTotal, heapUsed, etc.) in MB\n- ✅ CPU Usage (user/system) in milliseconds\n\n---\n\n## ⚙️ Profiler Options\n\n| Option           | Type                                        | Default         | Description                             |\n|------------------|---------------------------------------------|-----------------|-----------------------------------------|\n| `route`          | `string`                                    | `/__profiler`   | Path to view system stats               |\n| `excludePaths`   | `string[]`                                  | `[]`            | Paths to ignore                         |\n| `metrics`        | `(\\\"time\\\" \\| \\\"memory\\\" \\| \\\"cpu\\\")[]`     | `['time', 'memory']` | Metrics to collect                |\n| `storage`        | `StorageAdapter`                            | `undefined`     | Save profile results                   |\n| `plugins`        | `ProfilerPlugin[]`                          | `[]`            | Hook into the profiling lifecycle      |\n\n---\n\n## 🔌 Plugins Example\n\n```typescript\nconst myPlugin = {\n  beforeProfile: () => console.log('Starting profiling...'),\n  afterProfile: (result) => console.log('Profile completed:', result),\n};\n\napp.use(profiler({ plugins: [myPlugin] }));\n```\n\n---\n\n## 🗃️ Rotating File Storage Example\n\n```typescript\nconst storage = createRotatingFileStorage('./profiler.log', 1024 * 1024); // 1MB rotation\n\napp.use(profiler({ storage }));\n```\n\n- File automatically rotates when it reaches the configured size.\n- Supports Node.js, Deno, Bun file systems.\n\n---\n\n## 🧑‍💻 Example Profile Output\n\n```json\n{\n  \"name\": \"default\",\n  \"duration\": 6.25,\n  \"timestamp\": \"2025-07-06T19:25:47.753Z\",\n  \"method\": \"GET\",\n  \"path\": \"/\",\n  \"memoryUsage\": {\n    \"rss\": 10485760,\n    \"heapTotal\": 6291456,\n    \"heapUsed\": 4194304,\n    \"external\": 102400,\n    \"arrayBuffers\": 51200\n  },\n  \"cpuUsage\": {\n    \"user\": 1416,\n    \"system\": 312\n  }\n}\n```\n\n---\n\n## ⚡ System Stats Breakdown\n\n### Memory Usage\n\n- `rss`: Resident Set Size (total memory allocated for the process)\n- `heapTotal`: Total size of allocated heap\n- `heapUsed`: Heap actually used\n- `external`: Memory used by C++ objects bound to JS\n- `arrayBuffers`: Memory allocated for ArrayBuffer\n\n### CPU Usage\n\n- `user`: Time spent in user mode (μs)\n- `system`: Time spent in kernel mode (μs)\n\n---\n\n## 🔐 Environment Support\n\n✔️ Node.js\n✔️ Deno\n✔️ Bun\n\n---\n<!-- \n## 🔎 Future Enhancements\n\n- 🔄 Redis or database storage adapters\n- 📈 Export metrics in Prometheus format\n- 🌐 Remote profiling dashboard -->\n\n---\n\n## 📜 License\n\nMIT © 2025 TezX Team\n"
    },
    {
      "id": 44,
      "path": "toolkit/helpers/devtools",
      "name": "Devtools",
      "folder": "Toolkit/Helpers",
      "content": "\n# 📊 TezX DevTools\n\n> Developer-friendly diagnostics and inspector panel for TezX-based applications. Plug in to see routes, middlewares, env variables, cookies, and add your own custom debug tabs.\n\n---\n\n## ✅ Installation\n\n```bash\nnpm install @tezx/devtools\n```\n\nEnsure you also have:\n\n```bash\nnpm install tezx\n```\n\n---\n\n## 🚀 Quick Usage\n\nIn your TezX app entry (e.g., `server.ts` or `index.ts`):\n\n```ts\nimport { TezX } from \"tezx\";\nimport DevTools from \"@tezx/devtools\";\n\nconst app = new TezX();\n\napp.get(\n  \"/devtools\",\n  DevTools(app, {\n    // Optional\n    // disableTabs: ['cookies', 'routes'],\n    // extraTabs: (ctx) => [ ... ]\n  })\n);\n\n```\n\nNow visit:\n**`http://localhost:3000/devtools`**\nto see a real-time diagnostic dashboard.\n\n---\n\n## 🧩 Built-in Tabs\n\n| Tab           | Description                                              |\n| ------------- | -------------------------------------------------------- |\n| `routes`      | Lists all loaded routes with method, path, and source    |\n| `middlewares` | Displays registered middleware and which routes use them |\n| `cookies`     | Shows request cookies (parsed from `ctx`)                |\n| `.env`        | Displays environment variables loaded via `.env`         |\n\n---\n\n## ⚙️ API: `DevTools(app, options)`\n\n```ts\nDevTools(app: TezX<any>, options?: Options): Callback\n```\n\n### Options\n\n| Option        | Type                                                      | Description             |\n| ------------- | --------------------------------------------------------- | ----------------------- |\n| `extraTabs`   | `(ctx) => TabType \\| Promise<TabType>`                    | Add your own tab panels |\n| `disableTabs` | `Array<'cookies' \\| 'routes' \\| '.env' \\| 'middlewares'>` | Hide built-in tabs      |\n\n---\n\n## 📚 Types\n\n```ts\ntype Tab = \"cookies\" | \"routes\" | \".env\" | \"middlewares\";\n\ntype TabType = {\n  doc_title: string;\n  label: string;\n  tab: Tab | string;\n  content: string; // Rendered HTML content\n}[];\n\ntype Options = {\n  extraTabs?: (ctx: Context) => Promise<TabType> | TabType;\n  disableTabs?: Tab[];\n};\n```\n\n---\n\n## 📁 Directory Example\n\n**Using `tezx/router`**\n\n```bash\nmy-app/\n├── routes/\n│   ├── _middleware.ts\n│   └── ...\n├── public/\n│   └── ...\n├── tezx.config.mjs             ← setup TezX + DevTools here\n├── .env\n├── package.json\n└── tsconfig.json\n```\n\n---\n"
    },
    {
      "id": 45,
      "path": "toolkit/helpers/tezx-localfs",
      "name": "TezX localfs",
      "folder": "Toolkit/Helpers",
      "content": "# @tezx/localfs\n\n`@tezx/localfs` is a simple, runtime-agnostic local file storage library that works with Node.js, Deno, and Bun.\n\nIt allows you to:\n\n* Save files to the local disk.\n* Automatically detect file types.\n* Auto-create directories.\n* Validate file size & type.\n* Generate public URLs for serving files.\n* List files (with recursive support).\n\n---\n\n## ✨ Features\n\n* 👍 TypeScript ready\n* ✅ Cross-runtime support (Node.js, Deno, Bun)\n* 📁 Auto-create directories when saving files\n* 🔍 Auto-detect MIME types from file extensions\n* ⚙️ Secure file-type filtering based on allowed MIME types\n* 🔗 Generate public URLs for serving files\n* 🏙️ Public file serving router (TezX Router)\n* 📂 List files recursively or non-recursively\n* 🧩 Built-in TezX Router for serving static files\n\n---\n\n## 📦 Installation\n\n### Node.js / Bun\n\n```bash\nnpm install @tezx/localfs\n# OR\nbun add @tezx/localfs\n```\n\n---\n\n## 🔧 Basic Example (Node.js)\n\n```ts\nimport { LocalFS } from \"@tezx/localfs\";\nimport { readFile } from \"node:fs/promises\";\n\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n\nasync function run() {\n  const buffer = await readFile(\"photo.jpg\");\n\n  const saved = await storage.saveFile(\"photo.jpg\", buffer);\n  console.log(\"File saved:\", saved);\n\n  const files = await storage.listFiles(\"\", true);\n  console.log(\"All files:\", files);\n}\n\nrun();\n```\n\n---\n\n## 🔹 API Reference\n\n### new LocalFS(options)\n\n| Option               | Type       | Default    | Description                    |\n| -------------------- | ---------- | ---------- | ------------------------------ |\n| basePath             | `string`   | `uploads`  | Folder to save files           |\n| publicUrl            | `string`   | `/uploads` | Public path prefix             |\n| allowPublicAccess    | `boolean`  | `true`     | Enable/disable public serving  |\n| autoRenameOnConflict | `boolean`  | `true`     | Rename files if name conflicts |\n| maxFileSize          | `number`   | `5MB`      | Max upload size in bytes       |\n| allowedTypes         | `string[]` | `image/*`  | Allowed MIME types             |\n\n---\n\n### saveFile(fileName, buffer, mimeType?)\n\nSaves a file to the storage.\n\nReturns:\n\n```json\n{\n  \"savedPath\": \"uploads/photo.jpg\",\n  \"fileName\": \"photo.jpg\",\n  \"publicUrl\": \"/uploads/photo.jpg\"\n}\n```\n\n---\n\n### readFile(fileName)\n\nReads file contents as a `Buffer`.\n\n---\n\n### deleteFile(fileName)\n\nDeletes a file from the disk.\n\n---\n\n### listFiles(folder = '', recursive = false)\n\nLists file names from a folder.\n\nExample output:\n\n```json\n[\n  \"photo.jpg\",\n  \"nested/file.pdf\"\n]\n```\n\n---\n\n### getPublicUrl(fileName)\n\nGenerates the public URL for a file.\n\nExample:\n\n```ts\nstorage.getPublicUrl(\"photo.jpg\");\n// \"/uploads/photo.jpg\"\n```\n\n---\n\n### serveFileResponse()\n\nReturns a TezX Router instance to serve static files from your storage folder.\n\nExample:\n\n```ts\napp.use(storage.serveFileResponse());\n```\n\nThen files are available at:\n\n```bash\n/uploads/photo.jpg\n```\n\n---\n\n## 🌐 Example Use with TezX API Router\n\n```ts\napp.post(\"/upload\", async (ctx) => {\n  const formData = await ctx.req.formData();\n  const file = formData?.files;\n  const buffer = Buffer.from(await file.arrayBuffer());\n  const result = await storage.saveFile(file.name, buffer);\n  return ctx.json(result);\n});\n\napp.use(storage.serveFileResponse());\n```\n\n---\n\n## 🔹 Runtime Support\n\n| Runtime | Supported |\n| ------- | --------- |\n| Node.js | ✅         |\n| Deno    | ✅         |\n| Bun     | ✅         |\n\n---\n\n# LocalFS Usage Docs\n\n## 🔹 Setup\n\n```ts\nconst storage = new LocalFS({\n  basePath: \"uploads\",\n  publicUrl: \"/uploads\",\n  allowedTypes: [\"image/*\", \"application/pdf\"]\n});\n```\n\n## 📂 Saving a File\n\n```ts\nconst buffer = await readFile(\"./logo.png\");\nconst saved = await storage.saveFile(\"logo.png\", buffer);\nconsole.log(saved);\n```\n\n---\n\n## 🔹 Listing Files\n\n```ts\nawait storage.listFiles(); // Non-recursive\nawait storage.listFiles(\"\", true); // Recursive\n```\n\n---\n\n## 🔹 Deleting Files\n\n```ts\nawait storage.deleteFile(\"logo.png\");\n```\n\n---\n\n## 🔹 Reading Files\n\n```ts\nconst content = await storage.readFile(\"logo.png\");\n```\n\n---\n\n## 🔹 Serving Public Files\n\n```ts\napp.use(storage.serveFileResponse());\n\n// Now accessible at: /uploads/logo.png\n```\n\n---\n\n## 🔹 Error Example\n\n```bash\nError: File type application/x-sh is not allowed\n```\n\n---\n"
    },
    {
      "id": 46,
      "path": "toolkit/helpers/tezx-session",
      "name": "TezX session",
      "folder": "Toolkit/Helpers",
      "content": "# ⚡ @tezx/session\n\n### Simple, Secure & Type-Safe Session Middleware for **TezX**\n\nBuild scalable applications with pluggable session storage, secure cookies, and developer-friendly TypeScript APIs.\n\n---\n\n## ✨ Features\n\n* ✅ **Type-Safe** session data (Generics support)\n* 🔐 Secure, HTTP-only cookie session IDs\n* ⚙️ Customizable session storage (Memory, Redis, etc.)\n* 🔄 Simple Middleware: `useSession()`, `createSession()`, `destroySession()`\n* 🌐 CORS-friendly: Supports `credentials: 'include'`\n* 🧩 Extensible for microservices & SSR apps\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/session\n```\n\nOR\n\n```bash\npnpm add @tezx/session\n```\n\n---\n\n## ⚙️ Quick Example\n\n```ts\nimport { TezX } from \"tezx\";\nimport { SessionManager } from \"@tezx/session\";\n\nconst app = new TezX();\n\nconst sessionManager = new SessionManager({\n  sessionName: \"tezx.sid\",\n  cookie: { maxAge: 1000 * 60 * 30, httpOnly: true, secure: true, sameSite: \"lax\" },\n});\n\n// Load session before routes\napp.use(sessionManager.useSession());\n\n// Login route → create session\napp.post(\"/login\", async (ctx) => {\n  await sessionManager.createSession({ userId: 99, role: \"admin\" }, ctx);\n  return ctx.json({ success: true });\n});\n\n// Protected route → read session\napp.get(\"/profile\", (ctx) => {\n  return ctx.json({ session: ctx.session?.data });\n});\n\n// Logout → destroy session\napp.post(\"/logout\", async (ctx) => {\n  await ctx.session?.destroy();\n  return ctx.json({ loggedOut: true });\n});\n```\n\n---\n\n## 🛡️ API Documentation\n\n### 🔑 SessionManager\n\n| Method             | Description                                 |\n| ------------------ | ------------------------------------------- |\n| `createSession()`  | Create and save a session                   |\n| `useSession()`     | Middleware: Load session from cookie        |\n| `destroySession()` | Destroy session from store and clear cookie |\n\n---\n\n### 📄 `createSession(data, ctx)`\n\n* Creates a session.\n* Automatically sets a session cookie in the response.\n* Saves session data to the configured storage.\n\nExample:\n\n```ts\nawait sessionManager.createSession({ userId: 101 }, ctx);\n```\n\n---\n\n### 🔄 `useSession()`\n\nMiddleware for **loading session** on every request:\n\n* Reads session cookie\n* Loads session data from storage\n* Adds `ctx.session` to your context.\n\nExample:\n\n```ts\napp.use(sessionManager.useSession());\n```\n\n---\n\n### ❌ `destroySession()`\n\nDeletes the session from storage and removes the cookie:\n\n```ts\nawait sessionManager.destroySession(sessionId);\n```\n\n---\n\n## 🔧 Configuration Options\n\n```ts\nconst sessionManager = new SessionManager({\n  sessionName: \"my_session\",\n  cookie: {\n    maxAge: 1000 * 60 * 30, // 30 min\n    secure: true,\n    httpOnly: true,\n    sameSite: \"lax\",\n  },\n  storage: new MemoryStore(), // Or your own adapter\n});\n```\n\n| Option          | Type                    | Description                            |\n| --------------- | ----------------------- | -------------------------------------- |\n| sessionName     | `string`                | Name of the cookie key                 |\n| sessionId       | `(ctx) => string`       | Custom session ID generator (optional) |\n| cookie.maxAge   | `number`                | Expiry in ms                           |\n| cookie.secure   | `boolean`               | Only send cookie on HTTPS              |\n| cookie.httpOnly | `boolean`               | Prevent JS access to cookie            |\n| cookie.sameSite | `\"lax\" \\| \"strict\" \\| \"none\"` | SameSite attribute             |\n| storage         | `SessionStorageAdapter` | Custom storage engine                  |\n\n---\n\n## 🧰 Example with Redis Storage\n\n```ts\n\nimport type { SessionStorageAdapter, SessionInstance } from \"@tezx/session\";\nimport type { RedisClientType } from \"redis\";\n\nexport class RedisStore implements SessionStorageAdapter {\n  private redisClient: RedisClientType;\n  private prefix: string;\n\n  /**\n   * Create RedisStore adapter.\n   * @param redisClient - Connected Redis client instance.\n   * @param prefix - Optional key prefix for session keys.\n   */\n  constructor(redisClient: RedisClientType, prefix = \"tezx:session:\") {\n    this.redisClient = redisClient;\n    this.prefix = prefix;\n  }\n\n  private getKey(sessionId: string) {\n    return `${this.prefix}${sessionId}`;\n  }\n\n  async get(sessionId: string): Promise<SessionInstance | undefined> {\n    const key = this.getKey(sessionId);\n    const data = await this.redisClient.get(key);\n    if (!data) return undefined;\n\n    try {\n      const parsed = JSON.parse(data);\n      const redisStore = this;\n      return {\n        sessionId: parsed.sessionId,\n        data: parsed.data,\n        async save() {\n          await redisStore.set(this.sessionId, this);\n        },\n        async destroy() {\n          await redisStore.destroy(this.sessionId);\n        },\n      } as SessionInstance;\n    } catch {\n      return undefined;\n    }\n  }\n\n  async set(sessionId: string, data: SessionInstance, maxAge?: number): Promise<void> {\n    const key = this.getKey(sessionId);\n    const value = JSON.stringify({ sessionId, data: data.data });\n    if (maxAge) {\n      // maxAge in ms, Redis EXPIRE in seconds\n      await this.redisClient.set(key, value, {\n        PX: maxAge,\n      });\n    } else {\n      await this.redisClient.set(key, value);\n    }\n  }\n\n  async destroy(sessionId: string): Promise<void> {\n    const key = this.getKey(sessionId);\n    await this.redisClient.del(key);\n  }\n}\n\nconst redisStore = new RedisStore(redisClient);\n\nconst sessionManager = new SessionManager({\n  storage: redisStore,\n  cookie: { maxAge: 1000 * 60 * 60 }, // 1 hour\n});\n```\n\n---\n\n## ⚠️ CORS & Cookie Notes\n\nFor frontend requests (if CORS enabled):\n\n* Set credentials in the fetch request:\n\n```js\nfetch(\"/profile\", { credentials: \"include\" });\n```\n\n* Server-side: Configure CORS to allow credentials and the origin.\n\n---\n\n## 🔨 Type Safety\n\n```ts\nconst sessionManager = new SessionManager<{ userId: number, role: string }>();\n\nawait sessionManager.createSession({ userId: 1, role: \"admin\" }, ctx);\n```\n\nNow your `ctx.session.data` will always have `userId` and `role`.\n\n---\n\n## 🔮 Advanced Topics\n\n* Redis, MongoDB, File storage adapters\n* Regenerate session IDs on login/logout\n* Auto session expiry + cleanup\n* Session encryption for sensitive data\n* Shared session across subdomains\n\n---\n\n## ✅ License\n\nMIT © TezX\n\n---\n"
    },
    {
      "id": 47,
      "path": "toolkit/utilities/tezx-rbac",
      "name": "TezX rbac",
      "folder": "Toolkit/Utilities",
      "content": "# 🔐 @tezx/rbac\n\nA powerful, fully type-safe **Role-Based Access Control (RBAC)** plugin for [TezX](https://www.npmjs.com/package/tezx), designed to help you **control access to routes, APIs, and resources** using simple, template-based permission keys with full IntelliSense support.\n\n---\n\n## 🚀 Highlights\n\n- 🎯 Type-safe permission system (`T extends string[]`)\n- 🧠 IntelliSense-based permission enforcement\n- 🔁 Multi-role support (`ctx.user.role` can be `string | string[]`)\n- ⚙️ Middleware-driven, plug-and-play\n- ❌ Built-in denial handling + custom `onDeny()` support\n- 🧩 Easy integration with auth middlewares (like `authChecker`)\n- 🧪 Battle-tested in production apps\n- 🔑 Use role IDs(Dynamically generated, flexible)\n- 🔍 Clean merge of all permissions (No manual logic needed)\n- 🏷️ Static roles still supported (Easy for default usage)\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/rbac\n````\n\n---\n\n## 🧠 How It Works\n\n```bash\n[Your Middleware]\n    ⬇️ sets ctx.user.role\n[RBAC Plugin]\n    ⬇️ loads permission map\n[Route Guard]\n    ⬇️ checks permission key\n[✓ ALLOW] or [❌ DENY]\n```\n\n---\n\n## ⚠️ Required: `ctx.user.role`\n\nTo work correctly, you **must set** `ctx.user.role` before using RBAC.\n\n✅ Example:\n\n```ts\nctx.user = {\n  id: 'user_001',\n  role: 'admin',  // ✅ Required\n  email: 'rakib@example.com'\n};\n```\n\n✅ If roles can be multiple:\n\n```ts\nctx.user = {\n  role: ['editor', 'viewer']\n};\n```\n\n> 💡 Use `authChecker()` middleware to assign `ctx.user` from token/session.\n\n---\n\n## 🧑‍💻 Usage Example\n\n```ts\n\nimport RBAC from '@tezx/rbac';\ntype Permissions = ['user:create', 'user:delete', 'order:read', 'property:approve'];\n\nconst rbac = new RBAC<Permissions>();\n\napp.use(authChecker()); // ✅ Assigns ctx.user + ctx.user.role\n\napp.use(rbac.plugin({\n  loadPermissions: async () => ({\n    admin: ['user:create', 'user:delete', 'order:read', 'property:approve'],\n    editor: ['order:read'],\n    guest: []\n  })\n}));\n\napp.get('/admin/users', rbac.authorize('user:create'), async (ctx) => {\n  return ctx.text('You can create users.');\n});\n\n```\n\n---\n\n## 📌 RBAC Lifecycle\n\n| Step | Action                                                            |\n| ---- | ----------------------------------------------------------------- |\n| 1️⃣  | `ctx.user.role` assigned by auth middleware                       |\n| 2️⃣  | `rbac.plugin()` loads Role→Permission map                         |\n| 3️⃣  | `rbac.authorize('permission:key')` checks merged role permissions |\n| 4️⃣  | If not allowed → return `403` (with `onDeny` if provided)         |\n\n---\n\n### 🔁 Replace `role` with Unique Role IDs (Advanced)\n\nRBAC system supports mapping **dynamic role identifiers** (like database IDs or UUIDs) instead of hardcoded role names.\n\nThis is helpful when:\n\n- ✅ Roles are created dynamically from a dashboard or DB\n- ✅ You want to map user roles like `\"role_8FaHq1\"` instead of just `\"admin\"`\n- ✅ Permission sets are assigned to these dynamic IDs\n\n#### 🧪 Example\n\n```ts\nctx.user = {\n  id: 'user_xyz',\n  role: 'role_8FaHq1' // ✅ Your actual role ID from database\n};\n```\n\n```ts\n// Load role-permission map based on DB role IDs\nloadPermissions: async () => ({\n  role_8FaHq1: ['user:create', 'order:read'],\n  role_7NbQt55: ['user:delete']\n})\n```\n\n> ✅ Internally, `RBAC` merges all permissions based on the provided `ctx.user.role`, whether it's `string` or `string[]`.\n\n#### ⚠️ Important\n\nMake sure the role ID you assign in `ctx.user.role` **exactly matches** the keys in your permission map.\n\n---\n\n### Bonus: Hybrid Role Support\n\nYou can even mix static roles with dynamic IDs if needed:\n\n```ts\nctx.user = {\n  role: ['admin', 'role_7bXy91']\n};\n\nloadPermissions: async () => ({\n  admin: ['dashboard:access'],\n  role_7bXy91: ['product:create']\n});\n```\n\n---\n\n## 🧩 Plugin API\n\n### `rbac.plugin(config)`\n\nInitializes the permission map.\n\n**Config options:**\n\n| Field             | Type                         | Required | Description           |\n| ----------------- | ---------------------------- | -------- | --------------------- |\n| `loadPermissions` | `(ctx) => RolePermissionMap` | ✅        | Role → permission map |\n| `isAuthorized`    | `(roles, permissions, ctx)`  | ❌        | Custom check hook     |\n| `onDeny`          | `(error, ctx)`               | ❌        | Custom deny response  |\n\n---\n\n### `rbac.authorize('permission:key')`\n\nMiddleware to protect routes.\n\n```ts\napp.post('/orders', rbac.authorize('order:read'), handler);\n```\n\n---\n\n## 💡 IntelliSense with Template Types\n\n```ts\ntype Permissions = ['user:create', 'order:read', 'admin:panel'];\n\nconst rbac = new RBAC<Permissions>();\n```\n\n✅ Now `rbac.authorize(...)` will auto-suggest only those permission keys.\n\n---\n\n## ❌ Custom Deny Example\n\n```ts\nrbac.plugin({\n  loadPermissions: ...,\n  onDeny: (error, ctx) => {\n    return ctx.json({\n      success: false,\n      reason: error.message,\n      permission: error.permission\n    });\n  }\n});\n```\n\n---\n\n## 🔍 Real-World Structure\n\n```ts\nconst permissionMap = {\n  admin: ['user:create', 'user:delete'],\n  editor: ['order:read'],\n  viewer: [],\n};\n```\n\nUser may have:\n\n```ts\nctx.user = {\n  id: 'u-001',\n  role: ['editor', 'viewer']\n};\n```\n\nRBAC will combine permissions from both roles.\n\n---\n\n## 🔥 Debug Tip\n\nTo check permissions being applied at runtime:\n\n```ts\nconsole.log(ctx.user.permissions); // all merged permissions\n```\n\n---\n\n## 📚 Types Summary\n\n```ts\ntype RolePermissionMap<T extends string[]> = Record<string, T[number][]>;\ntype DenyError<T extends string[]> = {\n  error: string;\n  message: string;\n  permission: T[number];\n};\n```\n\n---\n\n## 📦 Exported API\n\n```ts\nimport RBAC, { plugin, authorize } from '@tezx/rbac';\n```\n\n---\n\n## 🧪 Test Route Example\n\n```ts\napp.get('/secure', rbac.authorize('admin:panel'), async (ctx) => {\n  ctx.body = { status: 'Access granted.' };\n});\n```\n\n---\n\n## ✅ Best Practices\n\n- 🔄 Always assign `ctx.user.role` in `authChecker`\n- 🧠 Define permissions centrally as union literal type\n- 🔐 Protect all critical routes using `rbac.authorize()`\n- 🧪 Add logging inside `onDeny` for better traceability\n\n---\n"
    },
    {
      "id": 48,
      "path": "toolkit/utilities/view-engine",
      "name": "View Engine",
      "folder": "Toolkit/Utilities",
      "content": "# @tezx/view-engine\n\nA flexible, powerful, and runtime-aware view engine utility for server-side rendering (SSR) with support for **Node.js**, **Bun**, and **Deno**.\n\n**Latest Version:** ![npm version](https://img.shields.io/npm/v/@tezx/view-engine.svg)\n\n> 🔧 Supports `ejs`, `pug`, `handlebars`, `nunjucks`, and `mustache` templates out of the box.\n\n---\n\n## ✨ Features\n\n- ✅ Supports multiple template engines\n- 🧠 Built-in caching for improved performance\n- 🪄 Optional file extension overrides\n- 🌐 Cross-runtime support: Node.js, Bun, Deno\n- 📦 Lightweight and framework-agnostic\n- 🔍 Ideal for SSR in Tezx or any TS/JS backend\n\n---\n\n## 📦 Installation\n\n```bash\nnpm install @tezx/view-engine\n# or\nbun add @tezx/view-engine\n````\n\n### **Template**\n\n```bash\nnpm create tezx view-engine -- --template view-engine --y\n```\n\n### **Require**\n\n```bash\n# EJS\nnpm install ejs\n\n# Pug (formerly Jade)\nnpm install pug\n\n# Handlebars\nnpm install handlebars\n\n# Nunjucks (Jinja2-like templating)\nnpm install nunjucks\n\n# Mustache\nnpm install mustache\n\n```\n\n---\n\n## 🚀 Usage\n\n```ts\nimport { ViewEngine } from \"@tezx/view-engine\";\n\nconst views = new ViewEngine(\"ejs\", \"./views\");\n\nconst html = await views.render(\"home\", {\n  title: \"Welcome!\",\n  user: { name: \"Rakibul\" },\n});\n\n// In your Tezx handler:\nctx.html(html);\n```\n\n---\n\n## 🔧 Constructor\n\n```ts\nnew ViewEngine(engine: TemplateEngine, viewsPath: string, options?: ViewEngineOptions)\n```\n\n### Parameters\n\n| Name        | Type                   | Description                        |\n| ----------- | ---------------------- | ---------------------------------- |\n| `engine`    | `\"ejs\"`, `\"pug\"`, etc. | Template engine to use             |\n| `viewsPath` | `string`               | Path to the views/templates folder |\n| `options`   | `ViewEngineOptions`    | (Optional) Configuration options   |\n\n---\n\n## ⚙️ Options\n\n```ts\ninterface ViewEngineOptions {\n  cache?: boolean; // default: true\n  autoescape?: boolean; // default: true (nunjucks only)\n  extensionOverride?: Partial<Record<TemplateEngine, string>>;\n}\n```\n\n### Example\n\n```ts\nconst views = new ViewEngine(\"ejs\", \"./views\", {\n  cache: true,\n  extensionOverride: {\n    ejs: \".html.ejs\"\n  }\n});\n```\n\n---\n\n## 📚 Supported Engines\n\n| Engine       | Extension   | Notes                       |\n| ------------ | ----------- | --------------------------- |\n| `ejs`        | `.ejs`      | Supports includes/partials  |\n| `pug`        | `.pug`      | Indentation-based templates |\n| `handlebars` | `.hbs`      | Logic-less templates        |\n| `nunjucks`   | `.njk`      | Powerful and Django-like    |\n| `mustache`   | `.mustache` | Minimal and logic-less      |\n\n---\n\n## 🧠 Runtime Compatibility\n\n| Runtime | Supported  | Notes                     |\n| ------- | ---------- | ------------------------- |\n| Node.js | ✅          | Recommended               |\n| Bun     | ✅          | Fully supported           |\n| Deno     | ✅          | Fully supported           |\n\n---\n\n## 📂 Example View Structure\n\n```bash\nviews/\n├── home.ejs\n├── layout.pug\n├── about.hbs\n├── user/\n│   └── profile.mustache\n```\n\n---\n\n## ✅ Also include in your `docs/` folder\n\nYou can save this as:\n\n```bash\n/docs/view-engine.md\n````\n\nor\n\n```bash\nREADME.md → root of helpers/view-engine/\n```\n"
    },
    {
      "id": 49,
      "path": "examples/uploader",
      "name": "Uploader",
      "folder": "Examples",
      "content": "\n# 📤 File Upload Middleware\n\n## Overview\n\nTezX provides first-class support for file uploads via its `useFormData` utility, allowing you to handle file uploads with minimal setup. This example demonstrates how to accept, read, and save a file using native `fs/promises` and `path`.\n\n## Features\n\n* Parses incoming multipart/form-data requests.\n* Supports extracting and saving uploaded files.\n* Handles errors with clear responses.\n* Compatible with modern runtimes like Bun, Node.js, and Deno.\n\n---\n\n## Example Usage\n\n```ts\nimport { join } from \"path\";\nimport { writeFile } from \"fs/promises\";\nimport { useFormData } from \"tezx/helper\";\n\napp.post(\"/data\", async (ctx) => {\n  const formData = await useFormData(ctx);\n  const file = formData?.files as File; // Get uploaded file\n\n  if (!file) {\n    return ctx.json({ error: \"No file uploaded\" }, 400);\n  }\n\n  try {\n    const buffer = await file.arrayBuffer(); // Convert File to ArrayBuffer\n    const filePath = join(process.cwd(), \"uploads\", file.name); // Destination path\n\n    await writeFile(filePath, Buffer.from(buffer)); // Save to disk\n\n    return ctx.json({\n      message: \"File uploaded successfully\",\n      path: filePath,\n    });\n  } catch (error: any) {\n    return ctx.json(\n      {\n        error: \"File save failed\",\n        details: error.message,\n      },\n      500,\n    );\n  }\n});\n```\n\n---\n\n## 🔍 Notes\n\n* Make sure the `uploads` directory exists or create it before saving.\n* `formData.files` can also be an array if multiple files are submitted.\n* To support multiple files, iterate over `formData.files`:\n\n```ts\nconst files = formData?.files as File[];\nfor (const file of files) {\n  const buffer = await file.arrayBuffer();\n  await writeFile(join(process.cwd(), \"uploads\", file.name), Buffer.from(buffer));\n}\n```\n\n---\n\n## 🧪 Testing with cURL\n\n```bash\ncurl -F \"file=@/path/to/file.png\" http://localhost:3000/data\n```\n\n---\n"
    },
    {
      "id": 50,
      "path": "examples/swagger-ui",
      "name": "Swagger UI",
      "folder": "Examples",
      "content": "### [OpenAPI JSON Example](https://petstore3.swagger.io/api/v3/openapi.json)\n\n```typescript\n/**\n * Serves Swagger UI at the specified route using an HTML template.\n * \n * @param jsonPath - The relative or absolute path to the OpenAPI JSON file (default: \"docs.json\").\n * @param swaggerVersion - The Swagger UI distribution version to use (default: \"5.11.0\").\n * @param meta - Optional metadata to customize the Swagger UI HTML page.\n * @param meta.title - The title to display in the browser tab (default: \"SwaggerUI\").\n * @param meta.metaDescription - A short description for the page (used in <meta> tag).\n * \n * @returns A middleware function that returns Swagger UI HTML when invoked with a context object.\n * \n * @example\n * app.get('/docs', swaggerUI('openapi.json'));\n */\nexport function swaggerUI(\n  jsonPath: string = \"docs.json\",\n  swaggerVersion: string = \"5.11.0\",\n  meta?: {\n    title?: string;\n    metaDescription?: string;\n  }\n) {\n  return (ctx: any) => {\n    return ctx.html(`\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <title>${meta?.title || \"SwaggerUI\"}</title>\n  <meta name=\"description\" content=\"${meta?.metaDescription || \"SwaggerUI Documentation\"}\" />\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui.css\" />\n</head>\n<body>\n  <div id=\"swagger-ui\"></div>\n  <script src=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui-bundle.js\" crossorigin></script>\n  <script src=\"https://unpkg.com/swagger-ui-dist@${swaggerVersion}/swagger-ui-standalone-preset.js\" crossorigin></script>\n  <script>\n   window.onload = () => {\n      window.ui = SwaggerUIBundle({\n        url: \"${jsonPath}\",\n        dom_id: '#swagger-ui',\n        presets: [\n          SwaggerUIBundle.presets.apis,\n          SwaggerUIStandalonePreset\n        ],\n        layout: \"StandaloneLayout\",\n      });\n    };\n  </script>\n</body>\n</html>\n`);\n  };\n}\n```\n"
    },
    {
      "id": 51,
      "path": "examples/basic-auth-client",
      "name": "Basic Auth Client",
      "folder": "Examples",
      "content": "# 🔐 Accessing Protected Routes with Basic Authentication\n\nThis guide demonstrates how to access routes secured with HTTP Basic Authentication using various tools and libraries.\n\n---\n\n### **1. Using cURL**\n\n**Option 1: With `-u` flag (recommended)**\n\n```bash\ncurl -u username:password http://localhost:3000/protected\n```\n\n**Option 2: Manually set the `Authorization` header**\n\n```bash\ncurl -H \"Authorization: Basic $(echo -n 'username:password' | base64)\" http://localhost:3000/protected\n```\n\n✅ `-u` automatically encodes credentials using Base64.\n\n---\n\n### **2. Using Postman**\n\n1. Open a new request in Postman.\n2. Navigate to the **Authorization** tab.\n3. Choose **Basic Auth** as the type.\n4. Enter your `username` and `password`.\n5. Click **Send**.\n\nPostman automatically encodes and adds the `Authorization` header.\n\n---\n\n### **3. Using JavaScript (Fetch API)**\n\n```js\nconst username = \"admin\";\nconst password = \"password123\";\n\nfetch(\"http://localhost:3000/protected\", {\n  method: \"GET\",\n  headers: {\n    Authorization: `Basic ${btoa(`${username}:${password}`)}`,\n  },\n})\n  .then((res) => res.json())\n  .then((data) => console.log(data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\n🔍 `btoa()` encodes the credentials in Base64 format.\n\n---\n\n### **4. Using Axios**\n\n```js\nconst axios = require(\"axios\");\n\naxios\n  .get(\"http://localhost:3000/protected\", {\n    auth: {\n      username: \"admin\",\n      password: \"password123\",\n    },\n  })\n  .then((res) => console.log(res.data))\n  .catch((err) => console.error(\"Error:\", err));\n```\n\n💡 The `auth` option in Axios handles Base64 encoding internally.\n\n---\n"
    },
    {
      "id": 52,
      "path": "examples/sse-implement",
      "name": "SSE implement",
      "folder": "Examples",
      "content": "\n# 📡 `sse`\n\nRegisters a **Server-Sent Events (SSE)** route handler for the given path.\nSSE is a simple and efficient way to send real-time updates from the server to the browser over HTTP using a single, long-lived connection.\n\n---\n\n## ✅ Syntax\n\n## 🧠 Description\n\n* Registers an HTTP `GET` route at the given `path`.\n* Sends **real-time updates** to connected clients via a persistent HTTP connection using the `text/event-stream` MIME type.\n* Automatically handles connection cleanup when the client disconnects.\n\n## 📦 Headers set (automatically or manually)\n\n```http\nContent-Type: text/event-stream\nCache-Control: no-cache\nConnection: keep-alive\n```\n\nYou can override or customize headers inside `ctx.send(stream, { headers })`.\n\n---\n\n## 📋 Example\n\n```ts\nfunction encoder(str: string) {\n  return new TextEncoder().encode(str);\n}\n\napp.get(\"/events\", (ctx) => {\n  const stream = new ReadableStream({\n    start(controller) {\n      // Initial event\n      controller.enqueue(encoder(\"data: Connected\\n\\n\"));\n\n      // Periodic event\n      const interval = setInterval(() => {\n        const message = `data: ${new Date().toISOString()}\\n\\n`;\n        controller.enqueue(encoder(message));\n      }, 2000);\n\n      // Cleanup on client disconnect\n      ctx.rawRequest?.signal?.addEventListener(\"abort\", () => {\n        clearInterval(interval);\n        controller.close()\n      });\n    },\n  });\n\n  return ctx.send(stream, {\n      \"Content-Type\": \"text/event-stream\",\n      \"Cache-Control\": \"no-cache\",\n      \"Connection\": \"keep-alive\",\n  });\n});\n```\n\n---\n\n## 🧪 Test Client (HTML)\n\n```ts\napp.get(\"/\", async (ctx) => {\n  return ctx.html`\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <title>SSE Demo</title>\n  </head>\n  <body>\n    <h1>Server-Sent Events</h1>\n    <pre id=\"output\"></pre>\n    <script>\n      const output = document.getElementById(\"output\");\n      const eventSource = new EventSource(\"/events\");\n\n      eventSource.onmessage = (event) => {\n        output.textContent += event.data + \"\\\\n\";\n      };\n\n      eventSource.onerror = () => {\n        output.textContent += \"🔴 Connection lost\\\\n\";\n      };\n    </script>\n  </body>\n</html>\n  `;\n});\n```\n\n---\n"
    },
    {
      "id": 53,
      "path": "examples/detect-locale",
      "name": "Detect Locale",
      "folder": "Examples",
      "content": "```ts\nimport { Context, Middleware } from \"tezx\";\nimport { getCookie } from \"tezx/helper\";\n\n/**\n * Options for the detectLocale middleware.\n */\nexport type DetectLocaleOptions = {\n  /**\n   * 🌐 List of allowed locales.\n   * e.g., [\"en\", \"fr\", \"bn\"]\n   */\n  supportedLocales: string[];\n\n  /**\n   * 🏠 Default locale if none is matched from query, cookie, or headers.\n   * @default \"en\"\n   */\n  defaultLocale?: string;\n\n  /**\n   * 🔍 Name of the query parameter to check for locale.\n   * Example: /?lang=fr\n   * @default \"lang\"\n   */\n  queryKeyLocale?: string;\n\n  /**\n   * 🍪 Name of the cookie used to store locale preference.\n   * @default \"locale\"\n   */\n  cookieKeyLocale?: string;\n\n  /**\n   * 🗺️ Key under which the locale will be attached to the context object.\n   * Example: ctx.locale = \"en\"\n   * @default \"locale\"\n   */\n  localeContextKey?: string;\n\n  /**\n   * 🛠️ Optional custom function to programmatically detect locale.\n   * Called last before fallback.\n   * Should return a supported locale or undefined.\n   */\n  customLocaleDetector?: (ctx: Context) => string | undefined;\n};\n\n/**\n * 🌍 Middleware that detects and sets the user's preferred locale.\n *\n * Detection order:\n * 1. Query parameter (e.g., ?lang=fr)\n * 2. Cookie value (e.g., locale=fr)\n * 3. Accept-Language HTTP header\n * 4. Custom detector function (if provided)\n * 5. Default locale (fallback)\n *\n * The detected locale is stored in `ctx[localeContextKey]`.\n *\n * @param options - Configuration options for locale detection.\n * @returns Middleware function that attaches locale to the context.\n */\nconst detectLocale = (options: DetectLocaleOptions): Middleware => {\n  const {\n    supportedLocales,\n    defaultLocale = \"en\",\n    queryKeyLocale = \"lang\",\n    cookieKeyLocale = \"locale\",\n    localeContextKey = \"locale\",\n    customLocaleDetector,\n  } = options;\n\n  return async function detectLocale(ctx, next) {\n    let detectedLocale: string | undefined;\n    // Step 1: Check query parameter\n    const queryLocale = ctx.req.query[queryKeyLocale];\n\n    if (queryLocale && supportedLocales.includes(queryLocale)) {\n      detectedLocale = queryLocale;\n    }\n\n    // Step 2: Check cookies\n    if (!detectedLocale) {\n      const cookieLocale = getCookie(ctx, cookieKeyLocale);\n      if (cookieLocale && supportedLocales.includes(cookieLocale)) {\n        detectedLocale = cookieLocale;\n      }\n    }\n\n    // Step 3: Check Accept-Language header\n    if (!detectedLocale) {\n      const acceptLanguage = ctx.req.header(\"accept-language\");\n      if (acceptLanguage) {\n        const preferredLocales = acceptLanguage\n          .split(\",\")\n          .map((lang) => lang.split(\";\")[0].trim())\n          .filter((lang) => supportedLocales.includes(lang));\n        detectedLocale = preferredLocales[0];\n      }\n    }\n\n    // Step 4: Check custom locale detector\n    if (!detectedLocale && customLocaleDetector) {\n      const customLocale = customLocaleDetector(ctx);\n      if (customLocale && supportedLocales.includes(customLocale)) {\n        detectedLocale = customLocale;\n      }\n    }\n\n    // Step 5: Fall back to default locale\n    if (!detectedLocale) {\n      detectedLocale = defaultLocale;\n    }\n    // Attach the detected locale to the context\n    ctx[localeContextKey] = detectedLocale;\n    // Proceed to the next middleware\n    return await next();\n  };\n};\n\nexport { detectLocale as default, detectLocale };\n\n```\n"
    }
  ]
}